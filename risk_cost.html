<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Discernment — Mini (Risk-Cost Cutoff)</title>
<style>
  :root { color-scheme: light dark; }
  :root {
    --bg:#f7f7f7; --card:#ffffff; --text:#111; --subtle:#333; --border:#ddd; --shadow:0 2px 6px rgba(0,0,0,.1);
    --btn-yes:#4CAF50; --btn-no:#F44336; --btn-next:#2196F3; --btn-muted:#9E9E9E; --btn-text:#fff;
    --panel:#fafafa; --line:#999;
  }
  @media (prefers-color-scheme: dark) {
    :root {
      --bg:#0f1115; --card:#171a21; --text:#e9edf1; --subtle:#c7cbd2; --border:#2a2f3a; --shadow:0 2px 6px rgba(0,0,0,.35);
      --btn-yes:#4CAF50; --btn-no:#EF5350; --btn-next:#42A5F5; --btn-muted:#6c6f76; --btn-text:#fff;
      --panel: color-mix(in oklab, #171a21, #0f1115 8%); --line:#b7b7b7;
    }
  }

  body { margin:0; background:var(--bg); color:var(--text); font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
  .container{max-width:650px;margin:auto;padding:20px;}
  .card{background:var(--card);border:1px solid var(--border);border-radius:8px;box-shadow:var(--shadow);min-height:280px;display:flex;flex-direction:column;}
  .segment-heading{display:flex;align-items:center;justify-content:space-between;font-size:1.6em;font-weight:700;margin:0;padding:14px;border-bottom:2px solid var(--border);}
  .segment-title{display:flex;align-items:center;gap:8px}
  .content{padding:16px 16px 0}
  .text{font-size:1.05em;margin-bottom:12px}
  .controls-row{display:flex;gap:10px;margin:6px 0 14px}
  .left-controls,.right-controls{flex:1;display:flex;gap:10px}
  .panel{display:none;border:1px solid var(--border);border-radius:6px;background:var(--panel);padding:12px;margin-bottom:14px;overscroll-behavior:contain}
  .panel svg{overflow:visible}
  .buttons{display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-start;padding:0 16px 16px}
  button{border:0;border-radius:6px;padding:10px 12px;cursor:pointer;color:var(--btn-text);background:var(--btn-muted)}
  .next{background:var(--btn-next)} .examples-btn{background:var(--btn-muted)} .viz-btn{background:var(--btn-muted)}
  .yes{background:var(--btn-yes)} .no{background:var(--btn-no)}
  .field-row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .field{display:flex;flex-direction:column;gap:6px;margin:6px 0}
  input[type="number"], select{padding:10px 12px;border:1px solid var(--border);border-radius:10px;background:var(--card);color:var(--text)}
  input[disabled], select[disabled]{opacity:.65; cursor:not-allowed;}
  .statline{display:flex;gap:10px;flex-wrap:wrap;margin:8px 0}
  .pill{border:1px solid var(--border);border-radius:12px;padding:8px 10px;background:color-mix(in oklab, var(--card), var(--bg) 8%)}
  .rule{font-weight:700;margin-top:6px}
  .badgelike{display:inline-block;padding:4px 6px;border-radius:6px;border:1px solid var(--border);background:color-mix(in oklab, var(--card), var(--bg) 8%)}

  /* chart */
  svg{width:100%;height:auto;display:block;touch-action:none}
  .axis text{font-size:12px;fill:#777}
  .curve{fill:none;stroke:#1f4cff;stroke-width:2.5}
  .shade-in{fill:#6cbf6c22}
  .shade-out{fill:#c7c7c733}
  .handle{fill:#ff3b3b;stroke:#fff;stroke-width:2;cursor:pointer;touch-action:none}
  .ptlabel{font-size:15px;font-weight:700;pointer-events:none}
  .ptlabel-bg{fill:#fff;fill-opacity:.98;stroke:var(--border)}
</style>
</head>
<body>
<div class="container">
  <div class="card">
    <div class="segment-heading">
      <span class="segment-title">⚖️ Mini Slide 1 — Preventative Action Cutoff</span>
      <span class="badgelike" id="miniStepTag">Step 1 of 3</span>
    </div>

    <div class="content">
      <div id="text" class="text">
        Enter the severity, cost, and per-instance probability of the downside if you don’t act now. We’ll show when action becomes justified (conservative rule: on the line = Act).
      </div>

      <!-- SLIDE 1 -->
      <div id="mini1" class="slide">
        <div class="field-row">
          <div class="field">
            <label for="sev">Severity (S) — up to 10</label>
            <input id="sev" type="number" max="10" step="0.01" value="5" inputmode="decimal" />
          </div>
          <div class="field">
            <label for="cost">Cost (C) — up to 10</label>
            <input id="cost" type="number" max="10" step="0.01" value="1" inputmode="decimal" />
          </div>
        </div>

        <div class="field-row">
          <div class="field">
            <label for="probMode">Probability input mode</label>
            <select id="probMode">
              <option value="oneInX">1 in X</option>
              <option value="percent">Percentage (%)</option>
              <option value="micromort">Micromorts</option>
            </select>
          </div>
          <div class="field" id="probInputWrap">
            <label id="probLabel" for="probVal">Enter X (for “1 in X”)</label>
            <input id="probVal" type="number" min="2" step="1" placeholder="e.g., 1000000"/>
          </div>
        </div>

        <div class="controls-row">
          <div class="left-controls">
            <button type="button" class="examples-btn" id="exBtn1">Show Examples</button>
          </div>
          <div class="right-controls">
            <button type="button" class="viz-btn" id="vizBtn1">Show Calculation Visualization</button>
          </div>
        </div>

        <div id="sharedPanel" class="panel" aria-hidden="true"></div>

        <div class="statline">
          <div class="pill"><span id="cutoffLabel">Cutoff (X)</span>: <span id="cutoffOut">1,000,000</span></div>
          <div class="pill">Cutoff (S/C): <span id="ratioCutOut">1.00</span></div>
        </div>
        <div class="rule" id="ruleLine">
          Rule: Only if <span id="probRuleName">X</span> ≥ <b>Probability Cutoff</b> and <b>S/C ≥ Cutoff (S/C)</b> can action be considered.
        </div>
      </div>

      <!-- SLIDE 2 (Don’t act path) -->
      <div id="mini2" class="slide" style="display:none;">
        <div class="text">
          It’s not worth acting based on the current values. Could any inputs reasonably change soon (e.g., higher probability, or severity vs. cost) that would flip the verdict?
        </div>
        <div class="controls-row">
          <div class="left-controls">
            <button type="button" class="examples-btn" id="exBtn2">Show Examples</button>
          </div>
          <div class="right-controls">
            <button type="button" class="viz-btn" id="vizBtn2">Show Calculation Reasoning</button>
          </div>
        </div>
        <div id="sharedPanel2" class="panel" aria-hidden="true"></div>
      </div>

      <!-- SLIDE 3 (Act path) -->
      <div id="mini3" class="slide" style="display:none;">
        <div class="text">✅ <b>Verdict: Act.</b> (Placeholder for “Mini Slide 3”.)</div>
      </div>
    </div>

    <div class="buttons" id="btnRow1">
      <button type="button" class="next" id="continueBtn">Continue</button>
    </div>

    <div class="buttons" id="btnRow2" style="display:none;">
      <button type="button" class="yes">Yes</button>
      <button type="button" class="no">No</button>
    </div>
  </div>
</div>

<script>
/* =========================
   Utilities & Core Formula
   ========================= */
const $ = id => document.getElementById(id);

// Accept any positive S/C; forbid zero only via epsilon
const EPS = 1e-9;
const MAX_SC = 10;

const state = { S:5, C:1, probMode:'oneInX', probVal:1000000, X_user:1000000, act:null };

// alpha (≈0.486...) from the earlier calibration
const ALPHA = Math.log(0.5) / Math.log((Math.sqrt(10) - 1) / 9);

function Xcutoff_from_ratio(r) {
  // r in (0, +∞) but we plot 1..10; outside range will clamp visually
  const tRaw = (r - 1) / 9;
  const t = Math.max(0, Math.min(1, tRaw));
  const exponent = 6 * Math.pow(t, ALPHA);
  return Math.pow(10, exponent);
}
function clamp(v, lo, hi){ return Math.min(hi, Math.max(lo, v)); }
function ceilPlaces(x,p=2){ const f=10**p; return Math.ceil(x*f)/f; }

function normalizeToX(mode, val){
  if (mode === 'oneInX') { if (!(val>1)) return null; return val; }
  if (mode === 'percent') { if (!(val>0 && val<100)) return null; return 100/val; }
  if (mode === 'micromort'){ if (!(val>0 && val<1e6)) return null; return 1e6/val; }
  return null;
}
function cutoffInUnit(Xc, mode){
  if (mode==='percent') return 100/Xc;
  if (mode==='micromort') return 1e6/Xc;
  return Xc;
}
function cutoffLabelForMode(mode){
  if (mode==='percent') return 'Cutoff (%)';
  if (mode==='micromort') return 'Cutoff (µm)';
  return 'Cutoff (X)';
}
function probRuleName(mode){
  if (mode==='percent') return '%';
  if (mode==='micromort') return 'µm';
  return 'X';
}
function computeSCutoffForX(X){
  return 1 + 9 * Math.pow((Math.log10(X)/6), 1/ALPHA);
}

/* =========================
   Inputs & early DOM refs
   ========================= */
const sevEl = $('sev'), costEl = $('cost'), probModeEl = $('probMode'), probValEl = $('probVal');
const cutoffLabel = $('cutoffLabel'), cutoffOut = $('cutoffOut'), ratioCutOut = $('ratioCutOut'), probRuleNameEl = $('probRuleName');

/* Declare panels & example buttons EARLY so updateStats can see them */
const exBtn1 = $('exBtn1'), exBtn2 = $('exBtn2');
const panel1 = $('sharedPanel'), panel2 = $('sharedPanel2');

function setProbInputConstraints(){
  const mode = probModeEl.value;
  const lab = $('probLabel');
  if (mode==='oneInX'){ lab.textContent='Enter X (for “1 in X”)'; probValEl.type='number'; probValEl.min='2'; probValEl.max=''; probValEl.step='1'; probValEl.placeholder='e.g., 1000000'; }
  else if (mode==='percent'){ lab.textContent='Enter percentage (%)'; probValEl.type='number'; probValEl.min='0.000001'; probValEl.max='99.999999'; probValEl.step='0.0001'; probValEl.placeholder='e.g., 0.01'; }
  else { lab.textContent='Enter micromorts (µm)'; probValEl.type='number'; probValEl.min='0.0001'; probValEl.max='999999.99'; probValEl.step='0.01'; probValEl.placeholder='e.g., 1'; }
  probRuleNameEl.textContent = probRuleName(mode);
}

/* Read/commit values but allow partial typing */
function commitInputs() {
  let S = parseFloat(sevEl.value); if (!isFinite(S)) S = state.S;
  let C = parseFloat(costEl.value); if (!isFinite(C)) C = state.C;

  // Enforce only upper bound here; lower bound = any positive (snap zeros to EPS)
  if (S <= 0) S = EPS; if (C <= 0) C = EPS;
  S = Math.min(S, MAX_SC); C = Math.min(C, MAX_SC);

  const mode = probModeEl.value;
  let pv = parseFloat(probValEl.value);
  if (!isFinite(pv)) pv = state.probVal;

  if (mode==='oneInX' && pv < 2) pv = 2;
  if (mode==='percent'){ if (pv<=0) pv=0.000001; if (pv>=100) pv=99.999999; }
  if (mode==='micromort'){ if (pv<=0) pv=0.0001; if (pv>=1e6) pv=999999.99; }

  sevEl.value = (+S).toString();
  costEl.value = (+C).toString();
  probValEl.value = pv;

  state.S=S; state.C=C; state.probMode=mode; state.probVal=pv; state.X_user = normalizeToX(mode, pv);

  updateStatsAndMaybeViz();
}

/* Update stats + refresh open viz (guarded to avoid init errors) */
function updateStatsAndMaybeViz(){
  const r = state.S / state.C;
  const Xc = Xcutoff_from_ratio(r);
  const mode = state.probMode;

  cutoffLabel.textContent = cutoffLabelForMode(mode);
  probRuleNameEl.textContent = probRuleName(mode);

  const c = cutoffInUnit(Xc, mode);
  cutoffOut.textContent = (mode==='oneInX') ? Math.round(c).toLocaleString()
                     : (mode==='percent' ? ceilPlaces(c,6) : ceilPlaces(c,2));

  const xForSCut = (state.X_user ?? 2);
  const rCut = computeSCutoffForX(xForSCut);
  ratioCutOut.textContent = rCut.toFixed(2);

  state.act = (state.X_user != null) ? (state.X_user <= Xc + 1e-15) : null;

  // Hardened guard so init order can’t break buttons
  if (typeof panel1 !== 'undefined' &&
      panel1 && panel1.style &&
      panel1.style.display === 'block' &&
      panel1.dataset && panel1.dataset.mode === 'viz' &&
      typeof window.__updateVizShared === 'function') {
    window.__updateVizShared();
  }
}

/* Input events — commit on change/blur only (typing stays free) */
sevEl.addEventListener('change', commitInputs);
sevEl.addEventListener('blur', commitInputs);
sevEl.addEventListener('input', ()=>{});

costEl.addEventListener('change', commitInputs);
costEl.addEventListener('blur', commitInputs);
costEl.addEventListener('input', ()=>{});

probModeEl.addEventListener('change', ()=>{ setProbInputConstraints(); commitInputs(); });
probValEl.addEventListener('change', commitInputs);
probValEl.addEventListener('blur', commitInputs);
probValEl.addEventListener('input', ()=>{});

setProbInputConstraints();
probValEl.value='1000000';
commitInputs();

/* =========================
   Examples toggles
   ========================= */
function toggleExamples(panel, btn){
  const open = panel.style.display==='block' && panel.dataset.mode==='examples';
  if (open){ panel.style.display='none'; panel.dataset.mode=''; btn.textContent='Show Examples'; }
  else {
    panel.innerHTML=''; const p=document.createElement('p'); p.textContent='Examples:'; const ul=document.createElement('ul');
    ['Boiling water for nasal irrigation at micromort-level risk.',
     'Replacing fraying charging cable before failure.',
     'Wearing a seatbelt: huge severity, minimal cost.'].forEach(t=>{ const li=document.createElement('li'); li.textContent=t; ul.appendChild(li); });
    panel.appendChild(p); panel.appendChild(ul);
    panel.style.display='block'; panel.dataset.mode='examples'; btn.textContent='Hide Examples';
  }
}
exBtn1.addEventListener('click', ()=>toggleExamples(panel1, exBtn1));
exBtn2.addEventListener('click', ()=>toggleExamples(panel2, exBtn2));

/* =========================
   Visualization (shared)
   ========================= */
const vizBtn1 = $('vizBtn1'), vizBtn2 = $('vizBtn2');

function openVizInto(panel, withMirrors){
  panel.innerHTML = '';
  panel.style.display='block'; panel.dataset.mode='viz';

  // Slide-2 shows greyed mirrors; Slide-1 does not
  if (withMirrors){
    const row = document.createElement('div'); row.className='field-row';
    row.innerHTML =
      `<div class="field"><label>Severity (S)</label><input id="editS" type="number" value="${state.S}" disabled/></div>
       <div class="field"><label>Cost (C)</label><input id="editC" type="number" value="${state.C}" disabled/></div>`;
    const row2 = document.createElement('div'); row2.className='field-row';
    const label = (state.probMode==='oneInX'?'Enter X (for “1 in X”)': state.probMode==='percent'?'Enter percentage (%)':'Enter micromorts (µm)');
    row2.innerHTML =
      `<div class="field"><label>Probability input mode</label>
        <select id="editMode" disabled>
          <option value="oneInX"${state.probMode==='oneInX'?' selected':''}>1 in X</option>
          <option value="percent"${state.probMode==='percent'?' selected':''}>Percentage (%)</option>
          <option value="micromort"${state.probMode==='micromort'?' selected':''}>Micromorts</option>
        </select></div>
       <div class="field"><label id="editProbLabel">${label}</label><input id="editProb" type="number" value="${state.probVal}" disabled/></div>`;
    panel.appendChild(row); panel.appendChild(row2);
  }

  // SVG
  const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.setAttribute('viewBox','0 0 900 580'); // extra space for labels
  svg.style.touchAction='none';
  panel.appendChild(svg);

  const axesG = document.createElementNS('http://www.w3.org/2000/svg','g'); svg.appendChild(axesG);
  const shadeIn = document.createElementNS('http://www.w3.org/2000/svg','path'); shadeIn.setAttribute('class','shade-in'); svg.appendChild(shadeIn);
  const shadeOut= document.createElementNS('http://www.w3.org/2000/svg','path'); shadeOut.setAttribute('class','shade-out'); svg.appendChild(shadeOut);
  const curve = document.createElementNS('http://www.w3.org/2000/svg','path'); curve.setAttribute('class','curve'); svg.appendChild(curve);
  const hLine = document.createElementNS('http://www.w3.org/2000/svg','line'); hLine.setAttribute('stroke','var(--line)'); hLine.setAttribute('stroke-dasharray','5,5'); svg.appendChild(hLine);
  const vLine = document.createElementNS('http://www.w3.org/2000/svg','line'); vLine.setAttribute('stroke','var(--line)'); vLine.setAttribute('stroke-dasharray','5,5'); svg.appendChild(vLine);
  const handle = document.createElementNS('http://www.w3.org/2000/svg','circle'); handle.setAttribute('class','handle'); handle.setAttribute('r','11'); svg.appendChild(handle);
  handle.style.touchAction='none';

  // Label group LAST (above everything)
  const labelG = document.createElementNS('http://www.w3.org/2000/svg','g'); svg.appendChild(labelG);
  const labelBg = document.createElementNS('http://www.w3.org/2000/svg','rect'); labelBg.setAttribute('class','ptlabel-bg'); labelBg.setAttribute('rx','10'); labelBg.setAttribute('ry','10'); labelG.appendChild(labelBg);
  const labelTx = document.createElementNS('http://www.w3.org/2000/svg','text'); labelTx.setAttribute('class','ptlabel'); labelG.appendChild(labelTx);

  // Scales
  const pad = { left:78, right:24, top:28, bottom:72 };
  const W=900, H=580, plotW=W-pad.left-pad.right, plotH=H-pad.top-pad.bottom;
  const rMin=1, rMax=10;

  function getYRange(mode){
    if (mode==='percent') return { yMin: 0.0001, yMax: 100, ticks:[100,10,1,0.1,0.01,0.001,0.0001], label: "Cutoff Probability (%) (log scale)" };
    if (mode==='micromort') return { yMin: 1, yMax: 1e6, ticks:[1e6,1e5,1e4,1e3,100,10,1], label: "Cutoff Probability (µm) (log scale)" };
    return { yMin: 1, yMax: 1e6, ticks:[1,10,100,1e3,1e4,1e5,1e6], label: "Cutoff Probability as '1 in X' (log scale)" };
  }
  const rToPx = (r)=> pad.left + (r-rMin)/(rMax-rMin)*plotW;
  const pxToR = (px)=> (rMin + (px-pad.left)/plotW*(rMax-rMin));
  function yToPx(y,yMin,yMax){ return pad.top + plotH * (1 - (Math.log10(y)-Math.log10(yMin))/(Math.log10(yMax)-Math.log10(yMin))); }

  function drawAxes(mode){
    axesG.innerHTML='';
    for (let r=1;r<=10;r++){
      const x=rToPx(r);
      const l=document.createElementNS('http://www.w3.org/2000/svg','line'); l.setAttribute('x1',x); l.setAttribute('x2',x); l.setAttribute('y1',pad.top); l.setAttribute('y2',pad.top+plotH); l.setAttribute('stroke','#ddd'); axesG.appendChild(l);
      const tx=document.createElementNS('http://www.w3.org/2000/svg','text');
      tx.setAttribute('x',x); tx.setAttribute('y',H-28); tx.setAttribute('text-anchor','middle'); tx.setAttribute('class','axis');
      tx.textContent=r; axesG.appendChild(tx);
    }
    const {yMin,yMax,ticks,label} = getYRange(mode);
    ticks.forEach(y=>{
      const ty=document.createElementNS('http://www.w3.org/2000/svg','text');
      ty.setAttribute('x',12); ty.setAttribute('y',yToPx(y,yMin,yMax)+5); ty.setAttribute('class','axis');
      ty.textContent = (mode==='percent' ? (y>=1?y.toString():y.toExponential(1)) : y.toLocaleString());
      axesG.appendChild(ty);
    });
    const xlab=document.createElementNS('http://www.w3.org/2000/svg','text');
    xlab.setAttribute('x', pad.left+plotW/2); xlab.setAttribute('y', H-8); xlab.setAttribute('text-anchor','middle'); xlab.setAttribute('class','axis');
    xlab.textContent="Severity / Cost Ratio (S / C)"; axesG.appendChild(xlab);
    const ylab=document.createElementNS('http://www.w3.org/2000/svg','text');
    ylab.setAttribute('transform',`translate(16 ${pad.top+plotH/2}) rotate(-90)`); ylab.setAttribute('text-anchor','middle'); ylab.setAttribute('class','axis');
    ylab.textContent=label; axesG.appendChild(ylab);
  }

  function XtoYUnit(X,mode){ return (mode==='percent') ? (100/X) : (mode==='micromort' ? (1e6/X) : X); }

  function buildCurve(mode){
    const {yMin,yMax} = getYRange(mode);
    const N=800, pts=[];
    for(let i=0;i<=N;i++){
      const r = 1 + 9*(i/N);
      const X = Xcutoff_from_ratio(r);
      const Y = XtoYUnit(X, mode);
      pts.push([rToPx(r), yToPx(Y, yMin, yMax)]);
    }
    const d = pts.map(([x,y],i)=> (i?`L ${x},${y}`:`M ${x},${y}`)).join(' ');
    curve.setAttribute('d', d);
    shadeIn.setAttribute('d', d + ` L ${rToPx(10)},${yToPx(getYRange(mode).yMin, getYRange(mode).yMin, getYRange(mode).yMax)} L ${rToPx(1)},${yToPx(getYRange(mode).yMin, getYRange(mode).yMin, getYRange(mode).yMax)} Z`);
    shadeOut.setAttribute('d', d + ` L ${rToPx(10)},${yToPx(getYRange(mode).yMax, getYRange(mode).yMin, getYRange(mode).yMax)} L ${rToPx(1)},${yToPx(getYRange(mode).yMax, getYRange(mode).yMin, getYRange(mode).yMax)} Z`);
  }

  // choose (S,C) > 0, ≤ MAX_SC for a desired ratio r, staying close to current
  function chooseSCFromRatio(r, prevS, prevC){
    // Try keep S near prevS; compute C = S/r
    let S = Math.max(prevS, EPS); S = Math.min(S, MAX_SC);
    let C = S / r;
    if (C <= EPS || C > MAX_SC){
      // Try keep C near prevC; compute S = r*C
      C = Math.max(prevC, EPS); C = Math.min(C, MAX_SC);
      S = r * C;
      if (S <= EPS || S > MAX_SC){
        // fallback: snap S to nearest bound
        S = Math.min(Math.max(S, EPS), MAX_SC);
        C = Math.min(Math.max(S / r, EPS), MAX_SC);
      }
    }
    // Final safety
    S = Math.min(Math.max(S, EPS), MAX_SC);
    C = Math.min(Math.max(C, EPS), MAX_SC);
    return {S, C};
  }

  // local mirrors
  let eMode = state.probMode;
  let eS = state.S, eC = state.C;
  let eX = state.X_user;

  function updateVizCore(){
    const {yMin,yMax} = getYRange(eMode);
    drawAxes(eMode);
    buildCurve(eMode);

    // lines
    const Yuser = XtoYUnit(eX, eMode);
    const hy = yToPx(Yuser, yMin, yMax);
    hLine.setAttribute('x1', rToPx(1)); hLine.setAttribute('x2', rToPx(10));
    hLine.setAttribute('y1', hy); hLine.setAttribute('y2', hy);

    const rCut = computeSCutoffForX(eX);
    const vx = rToPx(clamp(rCut,1,10));
    vLine.setAttribute('x1', vx); vLine.setAttribute('x2', vx);
    vLine.setAttribute('y1', yToPx(yMin,yMin,yMax)); vLine.setAttribute('y2', yToPx(yMax,yMin,yMax));

    const r = eS / eC;
    const Xc = Xcutoff_from_ratio(r);
    const Yc = XtoYUnit(Xc, eMode);
    const cx = rToPx(clamp(r,1,10)); const cy = yToPx(Yc, yMin, yMax);
    handle.setAttribute('cx', cx); handle.setAttribute('cy', cy);

    // label (on top)
    const label = `S=${eS} , C=${eC}  ·  S/C=${(r).toFixed(3)}  ·  ${
      (eMode==='percent' ? 'Cutoff≈'+ceilPlaces(100/Xc,6)+'%' : (eMode==='micromort' ? 'Cutoff≈'+ceilPlaces(1e6/Xc,2)+' µm' : 'Cutoff≈'+Math.round(Xc).toLocaleString()))
    }`;
    labelTx.textContent=label; labelTx.setAttribute('text-anchor','middle');
    const offsetY=32; let ly = cy - offsetY; const minTop=pad.top + 18; if (ly<minTop) ly=minTop;
    labelTx.setAttribute('x', cx); labelTx.setAttribute('y', ly);
    const bb = labelTx.getBBox(); const padBox=10;
    labelBg.setAttribute('x', bb.x-padBox); labelBg.setAttribute('y', bb.y-padBox);
    labelBg.setAttribute('width', bb.width+2*padBox); labelBg.setAttribute('height', bb.height+2*padBox);

    // reflect back to Slide-1 statline/rule live
    document.getElementById('cutoffLabel').textContent = cutoffLabelForMode(eMode);
    document.getElementById('cutoffOut').textContent = (eMode==='oneInX') ? Math.round(Xc).toLocaleString() : (eMode==='percent' ? ceilPlaces(100/Xc,6) : ceilPlaces(1e6/Xc,2));
    document.getElementById('ratioCutOut').textContent = rCut.toFixed(2);
    document.getElementById('probRuleName').textContent = probRuleName(eMode);
  }

  // Dragging (mobile-safe); adjusts BOTH S and C to match dragged ratio
  let dragging=false;
  function onPointerDown(e){ e.preventDefault(); dragging=true; try{handle.setPointerCapture(e.pointerId);}catch(_){} onPointerMove(e); }
  function onPointerMove(e){
    if(!dragging) return; e.preventDefault();
    const pt = svg.createSVGPoint(); pt.x=e.clientX; pt.y=e.clientY;
    const sp = pt.matrixTransform(svg.getScreenCTM().inverse());
    const px = clamp(sp.x, pad.left, pad.left+plotW);
    const r = pxToR(px);

    const chosen = chooseSCFromRatio(r, state.S, state.C);
    eS = chosen.S; eC = chosen.C;

    // push into global state + inputs so everything mirrors
    state.S = eS; state.C = eC;
    $('sev').value = eS;
    $('cost').value = eC;

    updateVizCore(); updateStatsAndMaybeViz();
  }
  function onPointerUp(e){ dragging=false; try{handle.releasePointerCapture(e.pointerId);}catch(_){} }

  handle.addEventListener('pointerdown', onPointerDown, {passive:false});
  svg.addEventListener('pointermove', onPointerMove, {passive:false});
  window.addEventListener('pointerup', onPointerUp, {passive:false});

  // keep in sync with Slide-1 while open
  window.__updateVizShared = function(){
    eMode = state.probMode; eS = state.S; eC = state.C; eX = state.X_user;
    updateVizCore();
  };

  // initial render
  eMode = state.probMode; eS = state.S; eC = state.C; eX = state.X_user;
  updateVizCore();
}

const vizBtn1 = $('vizBtn1'), vizBtn2 = $('vizBtn2');
vizBtn1.addEventListener('click', ()=>{
  const open = panel1.style.display==='block' && panel1.dataset.mode==='viz';
  if (open){ panel1.style.display='none'; panel1.dataset.mode=''; vizBtn1.textContent='Show Calculation Visualization'; }
  else { openVizInto(panel1, /*withMirrors=*/false); vizBtn1.textContent='Hide Calculation Visualization'; }
});
vizBtn2.addEventListener('click', ()=>{
  const open = panel2.style.display==='block' && panel2.dataset.mode==='viz';
  if (open){ panel2.style.display='none'; panel2.dataset.mode=''; vizBtn2.textContent='Show Calculation Reasoning'; }
  else { openVizInto(panel2, /*withMirrors=*/true); vizBtn2.textContent='Hide Calculation Reasoning'; }
});

/* =========================
   Continue → route
   ========================= */
const continueBtn = $('continueBtn');
const mini1 = $('mini1'), mini2 = $('mini2'), mini3 = $('mini3');
const miniTag = $('miniStepTag'), btnRow1=$('btnRow1'), btnRow2=$('btnRow2');

continueBtn.addEventListener('click', ()=>{
  const r = state.S / state.C;
  const Xc = Xcutoff_from_ratio(r);
  const act = (state.X_user !== null) ? (state.X_user <= Xc + 1e-15) : null;

  if (act) { mini1.style.display='none'; mini2.style.display='none'; mini3.style.display='block'; miniTag.textContent='Step 3 of 3'; btnRow1.style.display='none'; btnRow2.style.display='none'; }
  else { mini1.style.display='none'; mini2.style.display='block'; mini3.style.display='none'; miniTag.textContent='Step 2 of 3'; btnRow1.style.display='none'; btnRow2.style.display='flex'; }
});
</script>
</body>
</html>