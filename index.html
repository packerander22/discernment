<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Discernment: A Decision-Making Guide</title>

<!-- 🔹 Preload the first-screen logo to avoid pop-in -->
<link rel="preload" as="image" href="./favicon_256_transparent.png">

<link rel="manifest" href="./site.webmanifest?v=4">
<meta name="theme-color" content="#ffffff">
<!-- 🔹 Address bar / browser UI color that follows system theme -->
<meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#0b0b0d" media="(prefers-color-scheme: dark)">

<!-- Icons -->
<link rel="icon" type="image/svg+xml" href="./favicon_transparent.svg">
<link rel="icon" type="image/png" sizes="16x16" href="./favicon_16_transparent.png">
<link rel="icon" type="image/png" sizes="32x32" href="./favicon_32_transparent.png">
<link rel="icon" type="image/png" sizes="48x48" href="./favicon_48_transparent.png">
<link rel="icon" type="image/png" sizes="64x64" href="./favicon_64_transparent.png">
<link rel="icon" type="image/png" sizes="192x192" href="./favicon_192_transparent.png">
<link rel="icon" type="image/png" sizes="256x256" href="./favicon_256_transparent.png">
<link rel="icon" type="image/png" sizes="384x384" href="./favicon_384_transparent.png">
<link rel="icon" type="image/png" sizes="512x512" href="./favicon_512_transparent.png">
<link rel="shortcut icon" href="./favicon_transparent.ico">

<!-- iOS homescreen -->
<link rel="apple-touch-icon" sizes="180x180" href="./favicon_180_transparent.png">

<script>
  // MathJax v3 config: allow \( … \) inline TeX
  window.MathJax = {
    tex: {inlineMath: [['\\(','\\)']]},
    options: {skipHtmlTags: ['script','noscript','style','textarea','pre','code']}
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

<style>
  :root {
    --btn-pad-y:10px; --btn-pad-x:12px;
    --flash-dur: 1500ms;           /* <- top-level; now it exists */


    /* slider custom props */
    --track-height: 8px;
    --thumb-size: 28px;
    --thumb-shadow: 0 1px 3px rgba(0,0,0,.25);
    --track-bg: #e0e0e0;
    --fill: #2d6cdf;
    --pct: 0%;
    --tick-color: rgba(0,0,0,.35);
    --tick-thickness: 2px;
    --tick-length: 6px;
  }

  body { font-family: Arial, sans-serif; background:#f7f7f7; margin:0; padding:0; }
  .container { max-width: 650px; margin:auto; padding:20px; }
  .top-bar { display:flex; justify-content:space-between; margin-bottom:10px; }
  .card {
    background:#fff; padding:20px; border-radius:8px;
    box-shadow:0 2px 6px rgba(0,0,0,0.1); min-height:280px;
    display:flex; flex-direction:column; justify-content:space-between;
  }

  /* Header */
  .segment-heading {
    display:flex; align-items:center; justify-content:space-between;
    font-size:1.8em; font-weight:bold; margin-bottom:15px; padding:8px;
    border-bottom:2px solid #ddd; gap:12px; transition: color var(--flash-dur) cubic-bezier(.4,0,.6,1);
  }
  .segment-title { display:inline-flex; align-items:center; gap:8px; }
  .segment-title img.logo {
    height:1.2em; width:auto; vertical-align:middle; margin-right:6px;
    aspect-ratio: 1 / 1;
  }
  .flash-green  { color: var(--flash-green); }
  .flash-gold   { color: var(--flash-gold); }
  .flash-purple { color: var(--flash-purple); }

  /* Give AB2 headings the same fade behavior as the verdict header */
  .about-wrapper h1,
  .about-wrapper h2,
  .about-wrapper h3 {
    transition: color var(--flash-dur) cubic-bezier(.4,0,.6,1);
  }

  /* Buttons */
  button { flex:1; padding:var(--btn-pad-y) var(--btn-pad-x); font-size:1em; border:none; border-radius:5px; cursor:pointer; }
  button.yes { background:#4CAF50; color:#fff; }
  button.no { background:#F44336; color:#fff; }
  button.same { background:#1E88E5; color:#fff; }
  button.next { background:#2196F3; color:#fff; }
  button.back { background:#555; color:#fff; flex:0 0 auto; }
  button.restart { background:#9C27B0; color:#fff; flex:0 0 auto; }
  button.examples-btn, button.viz-btn, button.reasoning-btn { background:#9E9E9E; color:#fff; }
  .ctrl-btn { flex:1; }
  button.active { outline:2px solid #000; }
  
  button.next:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .segment-heading .skip-btn {
    display:inline-flex; align-items:center; justify-content:center;
    flex:0 0 auto; padding:var(--btn-pad-y) var(--btn-pad-x);
    font-size:1rem; line-height:1; border:none; border-radius:5px; cursor:pointer;
    background:#e9e9e9; color:#333;
  }
  .segment-heading .skip-btn:hover { background:#dedede; }

  .text { font-size:1.3em; margin-bottom:12px; white-space:pre-wrap; }

  .controls-row { display:flex; gap:10px; margin:6px 0 18px 0; }
  .left-controls, .right-controls { flex:1; display:flex; gap:10px; }

  .panel {
    display:none; border:1px solid #eee; border-radius:6px; padding:10px; background:#fafafa;
    margin-bottom:18px;
  }
  .panel p { margin:6px 0; }
  .panel img { width:100%; height:auto; display:block; }

  .buttons { display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-start; }
  .buttons.center { justify-content:center; }

  /* Slider container */
  .risk-inline { display:none; border:1px solid #eee; border-radius:6px; padding:12px; background:#fafafa; margin:8px 0 18px 0; }
  .sev-display { text-align:center; font-size:1.8em; font-weight:bold; margin-bottom:8px; }
  .risk-row { display:flex; align-items:center; gap:10px; margin:0; }
  .risk-row input[type="range"] { width:100%; }
  .risk-ticks { display:block; width:100%; }

  .error { color:#B00020; font-size:0.95em; }

  /* === Slider visual customization === */
  .slider-wrap {
    position: relative;
    width: 100%;
    height: calc(var(--thumb-size) + var(--tick-length) * 2 + 8px);
    display: flex;
    align-items: center;
    justify-content: center;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    touch-action: pan-x;
  }
  
  /* defaults (only needed once) */
  .heat-slider{
    --fill: #3b82f6;            /* start: blue */
    --track-bg: #e5e7eb;        /* unfilled track */
    --track-height: 8px;
    --thumb-size: 22px;
    --thumb-shadow: 0 1px 2px rgba(0,0,0,.2);
    --tick-length: 8px;
    --tick-thickness: 2px;
    --tick-color: #cbd5e1;
  }
  
  .heat-slider {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: var(--thumb-size);
    background: transparent;
    position: relative;
    z-index: 1;
  }
  .heat-slider::-webkit-slider-runnable-track {
    height: var(--track-height);
    border-radius: calc(var(--track-height) / 2);
    background:
      linear-gradient(to right,
        var(--fill) 0%,
        var(--fill) var(--pct),
        var(--track-bg) var(--pct),
        var(--track-bg) 100%);
  }
  .heat-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: var(--thumb-size);
    height: var(--thumb-size);
    border-radius: 50%;
    background: #fff;
    border: 2px solid #999;
    box-shadow: var(--thumb-shadow);
    margin-top: calc((var(--thumb-size) - var(--track-height)) / -2);
    cursor: pointer;
  }

  .tick-row {
    position: absolute;
    left: calc(var(--thumb-size) / 2);
    right: calc(var(--thumb-size) / 2);
    height: var(--tick-length);
    pointer-events: none;
    z-index: 0;
  }
  .tick-row.top { top: 50%; transform: translateY(calc(-50% - var(--track-height)/2 - 2px)); }
  .tick-row.bottom { top: 50%; transform: translateY(calc(-50% + var(--track-height)/2 + 2px)); }
  .tick { position: absolute; width: var(--tick-thickness); height: 100%; background: var(--tick-color); transform: translateX(-50%); }

  .heat-slider::-moz-range-track { height: var(--track-height); border-radius: calc(var(--track-height) / 2); background: var(--track-bg); }
  .heat-slider::-moz-range-progress { height: var(--track-height); border-radius: calc(var(--track-height) / 2); background: var(--fill); }
  .heat-slider::-moz-range-thumb { width: var(--thumb-size); height: var(--thumb-size); border-radius: 50%; background: #fff; border: 2px solid #999; box-shadow: var(--thumb-shadow); cursor: pointer; }
  .heat-slider::-ms-track { height: var(--track-height); border-color: transparent; color: transparent; background: transparent; }
  .heat-slider::-ms-fill-lower { background: var(--fill); border-radius: calc(var(--track-height)/2); }
  .heat-slider::-ms-fill-upper { background: var(--track-bg); border-radius: calc(var(--track-height)/2); }
  .heat-slider::-ms-thumb { width: var(--thumb-size); height: var(--thumb-size); border-radius: 50%; background: #fff; border:2px solid #999; box-shadow: var(--thumb-shadow); }


  /* Math-style text for inline formulas */
  .math {
    font-family: "Times New Roman", "STIX Two Math", "Cambria Math", serif;
    font-style: italic;
    font-size: 1.05em;
    letter-spacing: 0.5px;
    white-space: nowrap;   /* keep formulas together */
    color: var(--text);    /* default = light theme text */
  }
  
  .math sub,
  .math sup {
    font-size: 0.75em;
    font-style: normal;    /* keep subscripts/superscripts upright */
    vertical-align: baseline;
    position: relative;
  }
  
  .math sub { bottom: -0.2em; }
  .math sup { top: -0.4em; }
  
  /* Dark mode override */
  @media (prefers-color-scheme: dark) {
    .math {
      color: var(--label-text);  /* lighter tone in dark theme */
    }
  }
  
  /* Manual toggle support */
  :root[data-theme="dark"] .math {
    color: var(--label-text);
  }
  :root[data-theme="light"] .math {
    color: var(--text);
  }

  /* anchors/sections that deep-link should respect sticky headers etc. */
  [id] { scroll-margin-top: 16px; } /* or the height of any sticky header */

  /* Make the injected back button the same purple as Restart (#9C27B0) */
  .about-wrapper .concept-back {
    display: inline-block;
    margin: 8px 0 12px 0;
    padding: 8px 12px;
    font: inherit;
    border: none;
    border-radius: 6px;
    color: #fff;
    cursor: pointer;
  }
  .about-wrapper .concept-back:hover { filter: brightness(1.06); }
  .about-wrapper .concept-back:active { filter: brightness(0.96); }
    
  /* Ensure anchored headings scroll clear of any sticky header */
  .about-wrapper [id] { 
    scroll-margin-top: 72px; /* adjust to your sticky header height */
  }
  
  .about-wrapper .concept-back:focus {
    outline: 2px solid rgba(31, 76, 255, .4);
    outline-offset: 2px;
  }
  
  /* grey out a locked control (micromorts) */
  .is-disabled { opacity: .55; pointer-events: none; }

  /* ================================
     THEME TOKENS + OVERRIDES
     ================================ */
  :root { color-scheme: light dark; }

  /* Light defaults */
  :root {
    --bg: #f7f7f7;
    --card: #ffffff;
    --text: #111111;
    --subtle-text: #333333;
    --border: #dddddd;
    --shadow: 0 2px 6px rgba(0,0,0,0.10);

    --btn-yes: #4CAF50;
    --btn-no: #F44336;
    --btn-same: #1E88E5;
    --btn-next: #2196F3;
    --btn-back: #555555;
    --btn-restart: #9C27B0;
    --btn-muted: #9E9E9E;
    --btn-text: #ffffff;

    --thumb-border: #999999;
    --tick-color: rgba(0,0,0,.35);
    --track-bg: #e0e0e0;

    --if-accent: #2e7d32;        /* ✅ used for Verdict green + graph shading */
    --when-accent: goldenrod;
    --result-accent: #9C27B0;

    /* Graph theme tokens */
    --axis-color: #555;
    --axis-color-dim: #777;
    --grid-color: rgba(0,0,0,.12);
    --curve-color: #1f4cff;
    --handle-fill: #ff3b3b;
    --handle-stroke: #ffffff;
    --shade-in: color-mix(in oklab, var(--if-accent), #ffffff 84%);
    --shade-out: rgba(0,0,0,.06);
    --label-bg: #ffffff;
    --label-text: #111111;
  }

  /* Dark overrides follow system */
  @media (prefers-color-scheme: dark) {
    :root {
      --bg: #0f1115;
      --card: #171a21;
      --text: #e9edf1;
      --subtle-text: #c7cbd2;
      --border: #2a2f3a;
      --shadow: 0 2px 6px rgba(0,0,0,0.35);

      --btn-yes: #4CAF50;
      --btn-no: #EF5350;
      --btn-same: #42A5F5;
      --btn-next: #42A5F5;
      --btn-back: #8e8e93;
      --btn-restart: #BA68C8;
      --btn-muted: #6c6f76;
      --btn-text: #ffffff;

      --thumb-border: #b5bcc8;
      --tick-color: rgba(255,255,255,.38);
      --track-bg: #2a2f3a;

      --if-accent: #5bd36a;   /* ✅ same green family for dark */
      --when-accent: #f1c24c;
      --result-accent: #c77dff;

      /* Graph in dark */
      --axis-color: #e9edf1;         /* ✅ tick/label white-ish */
      --axis-color-dim: #c7cbd2;
      --grid-color: rgba(255,255,255,.18);
      --curve-color: #8fb3ff;
      --handle-fill: #ff6b6b;
      --handle-stroke: #171a21;
      --shade-in: color-mix(in oklab, var(--if-accent), #000 70%); /* subtle green */
      --shade-out: rgba(255,255,255,.05);
      --label-bg: #0f1115;
      --label-text: #e9edf1;
    }
  }

  /* Manual override via data-theme (appears only if user toggles) */
  :root[data-theme="light"] {
    color-scheme: light;
    /* (re-apply the same LIGHT tokens as above) */
    --bg: #f7f7f7; --card:#ffffff; --text:#111111; --subtle-text:#333333; --border:#dddddd; --shadow:0 2px 6px rgba(0,0,0,0.10);
    --btn-yes:#4CAF50; --btn-no:#F44336; --btn-same:#1E88E5; --btn-next:#2196F3; --btn-back:#555; --btn-restart:#9C27B0; --btn-muted:#9E9E9E; --btn-text:#fff;
    --thumb-border:#999; --tick-color:rgba(0,0,0,.35); --track-bg:#e0e0e0;
    --if-accent:#2e7d32; --when-accent:goldenrod; --result-accent:#9C27B0;
    --axis-color:#555; --axis-color-dim:#777; --grid-color:rgba(0,0,0,.12);
    --curve-color:#1f4cff; --handle-fill:#ff3b3b; --handle-stroke:#fff;
    --shade-in: color-mix(in oklab, var(--if-accent), #ffffff 84%);
    --shade-out: rgba(0,0,0,.06);
    --label-bg:#fff; --label-text:#111;
  }
  :root[data-theme="dark"]  {
    color-scheme: dark;
    --bg:#0f1115; --card:#171a21; --text:#e9edf1; --subtle-text:#c7cbd2;
    --border:#2a2f3a; --shadow:0 2px 6px rgba(0,0,0,0.35);
    --btn-yes:#4CAF50; --btn-no:#EF5350; --btn-same:#42A5F5; --btn-next:#42A5F5;
    --btn-back:#8e8e93; --btn-restart:#BA68C8; --btn-muted:#6c6f76; --btn-text:#fff;
    --thumb-border:#b5bcc8; --tick-color:rgba(255,255,255,.38); --track-bg:#2a2f3a;
    --if-accent:#5bd36a; --when-accent:#f1c24c; --result-accent:#c77dff;

    --axis-color:#e9edf1; --axis-color-dim:#c7cbd2; --grid-color:rgba(255,255,255,.18);
    --curve-color:#8fb3ff; --handle-fill:#ff6b6b; --handle-stroke:#171a21;
    --shade-in: color-mix(in oklab, var(--if-accent), #000 70%);
    --shade-out: rgba(255,255,255,.05);
    --label-bg:#0f1115; --label-text:#e9edf1;
  }

  /* Map existing components to tokens (non-destructive overrides) */
  body { background: var(--bg); color: var(--text); }
  .card { background: var(--card); color: var(--text); box-shadow: var(--shadow); border: 1px solid var(--border); }
  .segment-heading { border-bottom: 2px solid var(--border); }
  .flash-gold  { color: var(--when-accent) !important; }
  .flash-green { color: var(--if-accent) !important; }
  .flash-purple{ color: var(--result-accent) !important; }

  .panel { background: color-mix(in oklab, var(--card), var(--bg) 8%); border:1px solid var(--border); }
  .risk-inline { background: color-mix(in oklab, var(--card), var(--bg) 8%); border:1px solid var(--border); }
  .tick { background: var(--tick-color); }
  .heat-slider::-webkit-slider-thumb { border: 2px solid var(--thumb-border); }
  .heat-slider::-moz-range-thumb { border: 2px solid var(--thumb-border); }
  .heat-slider::-ms-thumb { border: 2px solid var(--thumb-border); }

  .segment-heading .skip-btn {
    background: color-mix(in oklab, var(--card), var(--text) 12%);
    color: var(--subtle-text);
  }
  .segment-heading .skip-btn:hover {
    background: color-mix(in oklab, var(--card), var(--text) 20%);
  }

  /* Buttons pick up theme tokens */
  button { color: var(--btn-text); }
  button.yes      { background: var(--btn-yes); }
  button.no       { background: var(--btn-no); }
  button.same     { background: var(--btn-same); }
  button.next     { background: var(--btn-next); }
  button.back     { background: var(--btn-back); }
  button.restart  { background: var(--btn-restart); }
  button.examples-btn, button.viz-btn, button.reasoning-btn { background: var(--btn-muted); }

  /* ====== Graph typography & spacing (bigger, bolder, more outside) ====== */
  .graph-axis text { font-size: 14px; font-weight: 600; fill: var(--axis-color); }
  .graph-axis .dim  { fill: var(--axis-color-dim); }
  .graph-grid line  { stroke: var(--grid-color); stroke-width: 1; }
  .graph-curve      { fill:none; stroke: var(--curve-color); stroke-width: 2.5; }
  .graph-handle     { fill: var(--handle-fill); stroke: var(--handle-stroke); stroke-width: 2; cursor: pointer; touch-action:none; }
  .graph-shade-in   { fill: var(--if-accent); fill-opacity: .18; }  /* ✅ green shading */
  .graph-shade-out  { fill: var(--shade-out); }

  .ptlabel    { font-size: 16px; font-weight: 700; fill: var(--label-text); pointer-events:none; }
  .ptlabel-bg { fill: var(--label-bg); fill-opacity:.98; stroke: var(--border); rx:10; ry:10; }
  
  /* ===== Rule + Verdict unified styles ===== */
  .rule    { font-weight:700; margin-top:14px; }
  .verdict { margin-top:12px; font-weight:700; }  /* top-only spacing */
  .verdict.ok { color: var(--if-accent); }
  .verdict.no { color: var(--subtle-text); }

  /* ==== MINI GRAPH styles (additive) ==== */
  .mini-lead { margin-bottom: 10px; }
  .mini-wrap { display:block; border:1px solid var(--border); border-radius:8px; background: color-mix(in oklab, var(--card), var(--bg) 6%); padding:12px; margin:10px 0 16px; overflow: visible; }
  .mini-wrap > a{font-size:.95rem;text-decoration:underline;color:var(--curve-color);margin-top:8px;display:inline-block}
  .mini-fields { display: grid; grid-template-columns: 1fr; gap: 12px; }
  @media (min-width: 560px){ .mini-fields { grid-template-columns: 1fr 1fr; } }
  .mini-field { display:flex; flex-direction:column; gap:6px; }
  .mini-field input[type="number"], .mini-field select{
    padding:10px 12px; border:1px solid var(--border); border-radius:10px; background:var(--card); color:var(--text); width: 100%; box-sizing: border-box;
  }
  
  .mini-muted { opacity:.65; }
  .verdict.ok { color: var(--if-accent); }
  .verdict.no { color: var(--subtle-text); }
  
  /* SVG */
  .mini-svg{width:100%;height:auto;display:block;touch-action:none;overflow:visible}
  .mini-axis line{stroke: var(--grid-color);stroke-width: 1;opacity: .35}
  .mini-axis text{font-size:14px; fill: var(--text); opacity:0.85; font-weight:600}
  .mini-curve{fill:none;stroke:#1f4cff;stroke-width:2.5}
  @media (prefers-color-scheme: dark) {
    .mini-curve{stroke:#7ea3ff}
  }
  .mini-shade-in{fill:color-mix(in oklab, var(--if-accent), transparent 80%)}
  .mini-shade-out{fill:transparent}
  .mini-handle{fill:#ff3b3b;stroke:#fff;stroke-width:2;cursor:pointer;touch-action:none}
  .mini-ptlabel{font-size:16px;font-weight:800;pointer-events:none; fill: var(--text); }
  .mini-ptlabel-bg{fill:var(--card);fill-opacity:.98;stroke:var(--border)}
  .mini-axes-label{font-weight:800; font-size:16px; fill: var(--text); opacity:.9}
  
</style>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VJSYRKHSRM"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-VJSYRKHSRM');
</script>
</head>
<body>
<div class="container">
  <div class="top-bar">
    <button class="back" id="backBtn" onclick="goBack()" type="button">Back</button>
    <!-- 🔹 Theme toggle -->
    <button class="back" id="themeToggle" type="button" style="display:none;">Theme</button>
    <button class="restart" id="restartTop" onclick="restart()" type="button">Restart</button>
  </div>

  <div class="card">
    <div id="segmentHeading" class="segment-heading">
      <span id="segmentTitle" class="segment-title">
        <img
          src="./favicon_256_transparent.png"
          alt="Discernment Logo"
          class="logo"
          width="256"
          height="256"
          loading="eager"
          fetchpriority="high"
          decoding="sync"
        >
        Discernment: A Decision-Making Guide
      </span>
      <button id="skipBtn" class="skip-btn" style="display:none;" title="Skip to When You Should Act" type="button">Skip ⏭</button>
    </div>

    <div>
      <div id="text" class="text"></div>

      <div class="controls-row">
        <div id="leftControlsWrapper" class="left-controls"></div>
        <div id="rightControlsWrapper" class="right-controls"></div>
      </div>

      <!-- Shared panel for examples, viz, reasoning -->
      <div id="sharedPanel" class="panel" aria-hidden="true" role="region" aria-live="polite"></div>
      <!-- Inline risk UI -->
      <div id="riskInline" class="risk-inline" aria-hidden="true"></div>
      <div id="errorBox" class="error" role="alert" aria-live="assertive"></div>
    </div>

    <div id="buttons" class="buttons"></div>
  </div>
</div>

<script>
/* ======= THEME INIT + TOGGLE ======= */
(function initTheme(){
  const root = document.documentElement;
  const themeBtn = document.getElementById('themeToggle');
  const mqDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)');

  let metaTheme = document.querySelector('meta[name="theme-color"]:not([media])');
  if (!metaTheme) {
    metaTheme = document.createElement('meta');
    metaTheme.name = 'theme-color';
    document.head.appendChild(metaTheme);
  }

  function getSetting() {
    const saved = localStorage.getItem('theme');
    return (saved === 'light' || saved === 'dark' || saved === 'system') ? saved : 'system';
  }
  function getEffectiveTheme(setting) {
    if (setting === 'dark') return 'dark';
    if (setting === 'light') return 'light';
    return (mqDark && mqDark.matches) ? 'dark' : 'light';
  }
  function setThemeColor(effective) {
    metaTheme.setAttribute('content', effective === 'dark' ? '#0b0b0d' : '#ffffff');
  }
  function setButtonLabel() {
    if (!themeBtn) return;
    const setting = getSetting();
    const effective = getEffectiveTheme(setting);
    themeBtn.textContent = 'Theme: ' + (setting.charAt(0).toUpperCase() + setting.slice(1));
    themeBtn.title = 'Effective: ' + (effective === 'dark' ? 'Dark' : 'Light');
  }
  function applySetting(setting) {
    if (setting === 'system') {
      root.removeAttribute('data-theme');
      localStorage.setItem('theme', 'system');
    } else {
      root.dataset.theme = setting;
      localStorage.setItem('theme', setting);
    }
    const effective = getEffectiveTheme(setting);
    setThemeColor(effective);
    setButtonLabel();
  }

  applySetting(getSetting());

  if (themeBtn) {
    themeBtn.onclick = function(){
      const setting = getSetting();
      const next = (setting === 'system') ? 'dark' :
                   (setting === 'dark')   ? 'light' : 'system';
      applySetting(next);
    };
  }

  if (mqDark) {
    mqDark.addEventListener('change', () => {
      if (getSetting() === 'system') {
        setButtonLabel();
        setThemeColor(getEffectiveTheme('system'));
      }
    });
  }
  window.__refreshThemeButtonLabel = setButtonLabel;
})();

/* ======= FLOW JSON (Q0–Q47 + About) ======= */
var flowchart = [
  { "id": "Q0",  "type": "info", "text": "Welcome! This guide helps you determine both <i>IF</i> and <i>WHEN</i> you should act on an issue. This will help to avoid wasting resources and time, and getting stuck in <i>analysis paralysis</i>.\nYou’ll answer simple Yes/No questions (and sliders later). Answer everything to the best of your knowledge, and if you don't know something, do what you can to find out (once there aren't any other more important things to do).", "next": "Q1" },
  /* ===== IF YOU SHOULD ACT ===== */
  { "id": "Q1",  "type": "question", "text": "Are there any other more important things to do or think about right now?", "yes": "R1",  "no": "Q2" },
  { "id": "Q2",  "type": "question", "text": "Is there a current <i>real problem</i> or desired functional QoL (quality of life) improvement, rather than just a <i>“problem”</i> or preference that doesn’t affect performance or outcomes?", "yes": "Q10",  "no": "Q3" },
  { "id": "Q3",  "type": "question", "text": "Is there cause for a potential <i>real problem</i>, rather than just a <i>“problem”</i> that doesn’t affect performance or outcomes?", "yes": "Q5",  "no": "Q4" },
  { "id": "Q4",  "type": "question", "text": "Is there cause for a POTENTIAL cause for a POTENTIAL <i>real problem</i>, rather than just a <i>“problem”</i> that doesn’t affect performance or outcomes?", "yes": "Q5",  "no": "R2" },

  { "id": "Q5",  "type": "question", "text": "Is the potential problem inevitable if left unaddressed?", "yes": "Q10",  "no": "Q6" },

  /* ==== NEW Q6: mini interactive slide ==== */
  { "id": "Q6", "type": "mini", "text": "Use the interactive tool below to weigh <b>Severity</b>, <b>Cost</b>, and <b>Probability</b>. Fill the boxes (up to 10 for S/C, probability as % or 1 in X, or micromorts). Drag the dot to see the cutoff curve.", "yes": "Q10", "no": "Q7" },

  /* ==== NEW Q7: visualization-only slide ==== */
  { "id": "Q7", "type": "miniViz", "text": "Visualization (read-only): These values mirror what you entered on the previous step, but are greyed out. You can drag the point to see how Severity/Cost interacts with Probability. This slide does not change the actual decision unless you go back and edit the last slide.", "yes": "Q10", "no": "Q20" },
  { "id": "Q10", "type": "question", "text": "Is there a solution (or at least partial solution) to the problem/potential problem even if it’s currently unavailable (or a means of bringing about the QoL improvement)?", "yes": "Q11",  "no": "R4" },
  { "id": "Q11", "type": "question", "text": "Can this solution or QoL improvement be <i>guaranteed</i> to be fully brought about as a result of <i>your</i> influence?", "yes": "Q14", "no": "Q12" },
  { "id": "Q12", "type": "question", "text": "Do everything in your power first to achieve the desired result, but know that past that it’s out of your hands, and <i>worrying and obsessing won’t change anything and is unhealthy</i>. Is there anything further you can do?", "yes": "Q14", "no": "Q13" },
  { "id": "Q13", "type": "question", "text": "Is there an <i>alternative solution</i> that would solve the problem (or improve QoL) in a way that’s within your control or perhaps even in a <i>better overall way</i>?", "yes": "R5",  "no": "R2" },

  { "id": "Q14", "type": "question", "text": "Does this solution or QoL improvement involve gaining information that would be <i>valuable in the future</i>?", "yes": "Q15", "no": "Q16" },
  { "id": "Q15", "type": "question", "text": "Would the <i>information alone</i> gained from doing this outweigh the downsides it would likely cause to make this happen?", "yes": "Q31", "no": "Q16" },
  /* ==== Q16 split into trio (cost-before, cost-after, total) ==== */
  { "id": "Q16", "type": "question", "text": "Would the expected benefits of addressing this issue outweigh the expected <i>upfront</i> costs/efforts of addressing it (for just this instance)?", "yes": "Q17", "no": "Q20" },
  { "id": "Q17", "type": "question", "text": "Would the expected benefits of addressing this issue outweigh any negative consequences that would likely arise <i>as a result</i> of addressing it (for just this instance)?", "yes": "Q18", "no": "Q20" },
  { "id": "Q18", "type": "question", "text": "Would the overall benefits of addressing this issue outweigh the <i>combined total</i> of both the upfront costs and any resulting downsides (for just this instance)?", "yes": "Q22", "no": "Q20", "same": "Q19" },

  { "id": "Q19", "type": "question", "text": "All things considered, would you <i>rather</i> address it than not?", "yes": "Q22", "no": "Q20" },
  { "id": "Q20", "type": "question", "text": "Is there a time further down the road that the answer to the <i>previous question</i> could be yes?", "yes": "R3", "no": "Q21" },
  { "id": "Q21", "type": "question", "text": "Is there an <i>alternative solution</i> that would solve the problem (or improve QoL) in a way that’s worth it or perhaps even in a <i>better overall way</i>?", "yes": "R5",  "no": "R2" },
  { "id": "Q22", "type": "question", "text": "Does addressing this issue involve a <i>diminishing returns</i> curve for effort applied?", "yes": "Q23", "no": "Q24" },
  { "id": "Q23", "type": "info",     "text": "Find the <i>point of diminishing returns</i> and stop there. If you tend to get absorbed in an activity, find an alternative approach that solves the problem or improves QoL <i>without the addictive pull</i> and possibly even in a <i>better overall way</i>. Treat this approach as a \"better\", more effective overall solution, and <i>ALWAYS</i> use this approach over the original if it's available; if not, you may use the original approach if needed—but <i>only</i> with a pre-set time limit and timer, after which you must stop and re-evaluate.", "next": "Q24" },
  { "id": "Q24", "type": "question", "text": "Does addressing this issue directly involve an <i>inverted-U curve</i> for specific effort applied with an <i>objective sweet spot</i> where clear information is available to you?", "yes": "Q25", "no": "Q26" },
  { "id": "Q25", "type": "info",     "text": "Wait until there aren’t any other more important things to do, then if it’s worth it to you, find that <i>sweet spot</i>. If not, put in as much effort as you deem worth it.", "next": "Q31" },

  { "id": "Q26", "type": "question", "text": "In practice and given time, would a <i>functional difference</i>—like in a blind test compared side by side—likely be noticed if the issue was solved/addressed (assuming any potential future problems would occur)?", "yes": "Q27", "no": "R2" },
  { "id": "Q27", "type": "question", "text": "Would solving/addressing it help get rid of/prevent the problem (or improve QoL) in the <i>long term</i>?", "yes": "Q31", "no": "Q28" },
  { "id": "Q28", "type": "question", "text": "Would solving/addressing it help get rid of/prevent the problem (or improve QoL) in the <i>short term</i>?", "yes": "Q29", "no": "R2" },
  { "id": "Q29", "type": "question", "text": "Is it logically worth solving/addressing <i>EVERY time this situation arises</i>? (Or at least this time knowing it’s <i>temporary</i>?)", "yes": "Q31", "no": "Q30" },
  { "id": "Q30", "type": "question", "text": "Is there an <i>alternative solution</i> that would solve the problem (or improve QoL), in the long term or perhaps even in a <i>better overall way</i>?", "yes": "R5",  "no": "R2" },
  /* ===== WHEN YOU SHOULD ACT ===== */
  { "id": "Q31", "type": "question", "text": "Does this address a potential <i>future</i> problem?", "yes": "Q32", "no": "Q35" },
  { "id": "Q32", "type": "question", "text": "Does addressing this issue involve <i>preventative maintenance</i>?", "yes": "Q37", "no": "Q35" },

  /* Severity selection */
  { "id": "Q33", "type": "info",     "text": "Set the estimated catastrophic severity if you waited too long to act. (1-10)", "next": "Q34" },
  { "id": "Q34", "type": "question", "text": "Would there be <i>guaranteed clear telltale signs</i> of future functional failure before it actually happened, with a big enough window of time to address it properly in advance?", "yes": "Q46", "no": "Q47" },

  /* Availability / timing */
  { "id": "Q35", "type": "question", "text": "Is this the <i>most effective solution</i> you know of (that meets the previous criteria), assuming you could do it whenever you wanted?", "yes": "Q39", "no": "Q36" },
  { "id": "Q36", "type": "question", "text": "Have you considered <i>all better solutions</i> you know of?", "yes": "Q39", "no": "R5" },

  { "id": "Q37", "type": "question", "text": "Is this the <i>most effective solution</i> you know of (that meets the previous criteria)?", "yes": "Q33", "no": "Q38" },
  { "id": "Q38", "type": "question", "text": "Have you considered <i>all better solutions</i> you know of?", "yes": "Q33", "no": "R5" },
  { "id": "Q39", "type": "question", "text": "Is this solution <i>currently</i> available?", "yes": "Q40", "no": "Q41" },
  { "id": "Q40", "type": "question", "text": "Is there a <i>better time</i> down the road to solve/address this to <i>maximize value</i>?", "yes": "Q41", "no": "R7" },

  { "id": "Q41", "type": "question", "text": "Assuming you waited until it was available, would the expected <i>overall benefits</i> of using this solution outweigh the expected <i>overall downsides</i> of having to wait?", "yes": "Q44", "no": "Q43", "same": "Q42" },
  { "id": "Q42", "type": "question", "text": "All things considered, would you <i>rather</i> use this solution?", "yes": "Q44", "no": "Q43" },

  { "id": "Q43", "type": "question", "text": "Is there a <i>next best</i> solution you know of?", "yes": "R5",  "no": "R4" },
  { "id": "Q44", "type": "question", "text": "Is there a <i>better time</i> further down the road than when this solution is available to solve/address this to <i>maximize value</i>?", "yes": "R8",  "no": "R6" },
  { "id": "Q45", "type": "question", "text": "Is there a <i>better time</i> further down the road than at that time to solve/address this to <i>maximize value</i>?", "yes": "R8",  "no": "R6" },

  /* WHEN thresholds */
  { "id": "Q46", "type": "question", "text": "Normally you should solve/address it as soon as both of the following are true: <ul><li><i>Those telltale signs</i> indicate that failure is approaching.</li><li>The <i>estimated chance of failure</i> is nearing or greater than 50%.</li></ul>\nHowever, is there a <i>better time</i> before or after that time to solve/address this to <i>maximize value</i>?", "yes": "R8", "no": "R9" },
  { "id": "Q47", "type": "question", "text": "Normally you should solve/address it as soon as the <i>estimated chance of failure</i> is nearing or greater than 50%.\nHowever, is there a <i>better time</i> before or after that time to solve/address this to <i>maximize value</i>?", "yes": "R8", "no": "R9" },
  /* RESULTS */
  { "id": "R1",  "type": "result",   "text": "Worry about this <i>once those things are addressed</i> and the time is right." },
  { "id": "R2",  "type": "result",   "text": "<i>Don’t worry about it:)</i>" },
  { "id": "R3",  "type": "result",   "text": "If that time ever does come, re-evaluate the issue. Until then, (once there aren't any other more important things to do), consider any other solutions that could work and be worth it, or perhaps even be <i>better overall</i>." },
  { "id": "R4",  "type": "result",   "text": "Wait until there aren’t any other more important things to do, then if it’s worth it to you, <i>find a solution or solutions</i>. If not, put in as much effort as you deem worth it." },
  { "id": "R5",  "type": "result",   "text": "Consider any other solutions, from best to worst, if you haven’t already. Run them through the chart." },
  { "id": "R6",  "type": "result",   "text": "Wait until this solution is available, then solve it once there aren’t any other more important things to do. Until then, (once there aren't any other more important things to do, and if you'd like), consider any other solutions that could also work and be worth it." },
  { "id": "R7",  "type": "result",   "text": "Address it <i>sooner than later</i>, once there aren’t any other more important things to do." },
  { "id": "R8",  "type": "result",   "text": "Wait until that better time, then solve/address it once there aren't any other more important things to do. Until then, (once there aren't any other more important things to do, and if you'd like), consider any other solutions that could either also work and be worth it, or—in the case of preventative maintenance—mitigate consequences if failure did occur." },
  { "id": "R9",  "type": "result",   "text": "Solve/address it as soon as the criteria from the <i>previous slide</i> (before the question) are met, once there aren’t any other more important things to do. Until then, (once there aren't any other more important things to do, and if you'd like), consider any solutions that would mitigate consequences if failure did occur." },

  /* ===== ABOUT MENU + PAGES ===== */
  { "id": "AB0", "type": "aboutMenu", "heading": "About", "text": "Choose a section to learn more about the guide and its background." },
  { "id": "AB1", "type": "about", "heading": "About Me", "text": "Hi! My name is Packer, I’m the creator of this guide. I've had OCD for as long as I can remember, and one of the most difficult things for me is knowing whether or not I should worry about or address something, which led me to create this guide over the course of a year and a half—molded from many, <i>many</i> mistakes in my actions. I've learned it's not about being content with imperfection, or striving to make everything perfect, but rather about <i>discerning</i> what to do (or not do), and when to do it. This guide aims to help others make decision—regardless of if they suffer from OCD, anxiety, or not—as the logic it uses can be applied to all areas of life.\n\nTo contact or support me, I'm reachable at:\npackerander22@gmail.com" },
  { "id":"AB2","type":"about","heading":"Guide Concepts Explained","text":"<p>This guide is built to prevent wasted effort, “analysis paralysis,” and unhealthy worry, by walking through the two essential questions of decision-making: <b>Should I act?</b> (IF) and <b>When should I act?</b> (WHEN). Along the way, it uses concepts from psychology, economics, and systems thinking. Below is a deep dive into each principle, ordered as they appear in the guide.</p><h2 id='concepts-top'>IF You Should Act</h2><h3 id='concept-real-vs-cosmetic'>1. Real Problems vs. Cosmetic Problems</h3><p>Not every “problem” is a <i>real</i> problem.</p><ul><li><b>Real problems</b> affect functionality, outcomes, or safety.</li><li><b>Cosmetic or preference problems</b> only affect comfort, appearance, or personal taste.</li></ul><p><b>How it works:</b> By sorting issues into these two categories, you focus only on what actually changes results. Cosmetic issues can be ignored without consequence.</p><h3 id='concept-potential-vs-inevitable'>2. Potential vs. Inevitable Problems</h3><p>A potential problem may or may not happen. An inevitable problem <i>will</i> happen if ignored.</p><ul><li>Example: a frayed charging cable is <i>inevitably</i> going to fail.</li><li>Example: a squeaky door hinge <i>might</i> get worse, but may never actually break.</li></ul><p><b>How it works:</b> If a problem is inevitable, fixing it early prevents larger costs later. Potential problems require more analysis, especially when severity is high.</p><h3 id='concept-costs-benefits'>3. Costs vs. Benefits</h3><p>Every action carries a trade-off:</p><ul><li><b>Upfront costs/efforts:</b> time, money, or energy you spend right now.</li><li><b>Resulting downsides:</b> risks or hassles created by the fix itself.</li><li><b>Combined total:</b> both categories together, compared against what happens if you do nothing.</li></ul><p><b>Simple Rule:</b> Act if D<sub>nothing</sub> > (C<sub>upfront</sub> + D<sub>action</sub>)</p><p><b>Full Formula:</b> Act if <i>D<sub>nothing</sub> > C<sub>upfront</sub> + D<sub>action</sub></i></p><p><b>Worked Example:</b> If ignoring a car repair will eventually cost $500, while fixing now costs $100 and creates $50 in hassles, then 500 > (100+50) → 500 > 150 → Act now.</p><h3 id='concept-prob-sev-cost'>4. Probability vs. Severity vs. Cost</h3><p>Applies to <i>non-inevitable potential future problems</i>. Even if failure is unlikely, severity matters; and even if severe, cost of prevention matters.</p><ul><li><b>Low P + Low S:</b> usually safe to ignore.</li><li><b>Low P + High S:</b> worth preventing (example: helmet).</li><li><b>High P + Low S:</b> acceptable if prevention costs more than the nuisance.</li><li><b>High P + High S:</b> always act.</li></ul><p><b>Simple Rule:</b> Act if \\( P \\times S > C \\).</p><p><b>Full Cutoff Formula:</b> \\( X_{\\text{cutoff}} = 10^{\\;6 \\cdot \\left(\\frac{S/C - 1}{9}\\right)^{\\alpha}} \\).</p><p><b>Calibration:</b> \\( \\alpha = \\frac{\\ln(0.5)}{\\ln\\!\\left(\\tfrac{\\sqrt{10}-1}{9}\\right)} \\approx 0.48606 \\).</p><p><i>Checks:</i> \\(S/C=1 \\Rightarrow X=1\\) (only act if certain). \\(S/C=10 \\Rightarrow X=10^{6}\\) (one-in-a-million). \\(S/C=\\sqrt{10} \\Rightarrow X\\approx10^{3}\\) (one-in-a-thousand).</p><p><b>Worked Example:</b> Suppose a 10% chance (\\(P=0.1\\)) of severity 8 (\\(S=8\\)) with cost 5 (\\(C=5\\)). Expected downside \\(=0.1\\times 8=0.8\\); since \\(0.8 > 0.5\\) threshold, action is justified.</p><figure style='margin:8px 0;'><img src='./prob_sev_cost_chart.png' alt='Probability × Severity × Cost Decision Boundary (X-axis S/C from 1–10; Y-axis 1 in X up to 1,000,000; green region = act)' style='max-width:100%;height:auto;'/></figure><h3 id='concept-alternatives'>5. Alternative Solutions</h3><p>The first idea isn’t always best. Consider simpler fixes, substitutes, or better long-term approaches.</p><p><b>How it works:</b> Surveying alternatives reduces downside and can add unexpected upsides.</p><h3 id='concept-info-value'>6. Information Value</h3><p>Sometimes action is worth it for the <i>learning</i> alone.</p><p><b>How it works:</b> Small experiments reduce uncertainty and improve future choices.</p><h3 id='concept-diminishing-returns'>7. Diminishing Returns</h3><p>Beyond a point, extra effort yields smaller improvements.</p><p><b>Rule of thumb:</b> Stop when marginal benefit < marginal cost.</p><figure style='margin:8px 0;'><img src='./diminishing_returns_curve.png' alt='Diminishing Returns Curve' style='max-width:100%;height:auto;'/></figure><h3 id='concept-inverted-u'>8. Inverted-U Curve (Sweet Spot)</h3><p>Too little or too much effort hurts results; there’s an objective optimum.</p><p><b>Why invest:</b> You’re not chasing perfection; you’re closing in on a measurable optimum, so extra effort to find it is justified.</p><figure style='margin:8px 0;'><img src='./inverted_u_curve.png' alt='Inverted-U Curve' style='max-width:100%;height:auto;'/></figure><h3 id='concept-functional-diff'>9. Functional Difference (Blind Test)</h3><p>Only differences you can actually detect (and that matter for purpose) count.</p><p><b>How it works:</b> If a change isn’t noticeable in use, it shouldn’t drive the decision.</p><h3 id='concept-long-vs-short'>10. Long-Term vs. Short-Term Benefits</h3><p>Short-term relief vs. root-cause fixes.</p><p><b>How it works:</b> Temporary fixes are fine for temporary issues; root-cause fixes justify more cost because they stop repeats.</p><h3 id='concept-always-vs-sometimes'>11. Always vs. Sometimes Worth It</h3><p>Some actions are habit-worthy (always worth it); others depend on context.</p><p><b>How it works:</b> Make the universal ones automatic; evaluate the conditional ones each time.</p><h3 id='concept-preventative'>12. Preventative Maintenance</h3><p>Prevent small issues from becoming large failures.</p><p><b>How it works:</b> Small predictable costs now avert large unpredictable costs later.</p><h2 id='when-top'>WHEN You Should Act</h2><h3 id='concept-severity-threshold'>13. Severity and Thresholds</h3><p>Severity is worst-case impact; threshold is your acceptable limit.</p><p><b>Simple Rule:</b> Act if \\( \\frac{S}{T} \\ge 1 \\).</p><p><b>Worked Example:</b> If severity \\(=7.5\\) and your threshold \\(=5.0\\), then \\(7.5/5.0=1.5\\ge 1\\) → Act now.</p><figure style='margin:8px 0;'><img src='./linear_threshold_chart.png' alt='Linear Severity to Action Threshold' style='max-width:100%;height:auto;'/></figure><h3 id='concept-telltale-signs'>14. Telltale Signs</h3><p>Warnings before failure (e.g., brake squeal, storage warnings) give safe buffer time.</p><p><b>How it works:</b> Use the buffer to plan; ignoring signs risks urgent, expensive fixes.</p><h3 id='concept-timing'>15. Timing and Availability</h3><p>When you act changes value.</p><p><b>How it works:</b> Wait for better conditions or act now to prevent escalation—whichever maximizes benefit vs. cost.</p><h3 id='concept-better-later'>16. Better Alternatives Down the Road</h3><p>Sometimes waiting yields a clearly superior option.</p><p><b>How it works:</b> Avoid near-term obsolescence by delaying when a better option is imminent.</p><h2 id='concepts-summary'>Putting It All Together</h2><h3 id='concept-decision-logic'>17. The Decision Logic</h3><p>The guide’s structure reflects real-world logic:</p><ol><li>Is this a real or inevitable problem?</li><li>Do benefits outweigh costs?</li><li>How do probability, severity, and cost balance out?</li><li>Are alternatives better?</li><li>Is the solution functional and noticeable?</li><li>Where’s the sweet spot for effort?</li><li>Is it a long-term or short-term fix?</li><li>Is it universally worth it, or conditional?</li><li>Should you prevent it early?</li><li>How severe is it compared to your threshold?</li><li>Are there warning signs?</li><li>Is the timing right, or should you wait for a better alternative?</li></ol><p><b>How it works:</b> Layering these concepts prevents wasted energy, avoids unhealthy overthinking, and leads to decisions that are rational, balanced, and sustainable.</p>" }
];

/* ===== EXAMPLES (two per question; no info or results) ===== */
window.examples = {
  "Q1":  ["Finish homework due tonight before reorganizing the closet.", "Call the dentist first if you’re in pain instead of tweaking your workout plan."],
  "Q2":  ["Laptop battery dies quickly during class; you need reliable runtime.", "Your shoe tread is worn and you slip when running on wet pavement."],
  "Q3":  ["Small coolant drip under the car might lead to overheating later.", "Recurring mild chest tightness during runs that’s trending worse."],
  "Q4":  ["A faint clicking in a hard drive on boot once this month.", "Occasional wobble in a chair leg that’s starting to loosen."],
  "Q5":  ["Unsealed wood deck will inevitably weather and crack without treatment.", "Frayed charging cable will eventually fail if kept in use."],
  "Q6":  ["Skipping a tetanus booster could mean a serious infection later vs. quick clinic visit now.", "Ignoring a leaky faucet risks mold and higher bills vs. a simple repair."],
  "Q7":  ["Upgrading firmware may mean brief downtime, but stops data corruption.", "Aligning car wheels takes time, but avoids uneven tire wear after."],
  "Q8":  ["Replacing a dangerously cracked phone screen beats cost + setup + short learning curve.", "Booking a medical evaluation now outweighs copay + scheduling hassle."],
  "Q9":  ["Unpatched server is more likely than not to get compromised over months.", "Bald tire is more likely than not to blow out on a highway trip."],
  "Q10": ["There’s a software update that fixes the crash you’re seeing.", "A waterproof spray exists to protect your suede shoes."],
  "Q11": ["You can directly set the thermostat schedule yourself.", "You can swap the noisy fan on your PC today."],
  "Q12": ["You can follow up with support once more before waiting.", "You can gather better measurements before concluding it’s out of your hands."],
  "Q13": ["Use a lint roller daily instead of buying a new couch cover.", "Switch to a simpler training plan that still builds endurance."],
  "Q14": ["Running a small pilot teaches you if the workflow scales.", "Testing two camera angles tells you what boosts watch time."],
  "Q15": ["Doing a small A/B test is worth it just for the learning.", "Exploring a new note system is useful knowledge even if you keep the old one."],
  "Q16": ["Replacing air filter improves HVAC and is cheap/quick.", "Organizing your tool drawer speeds every repair you do."],
  "Q17": ["Changing to ergonomic keyboard helps wrists despite brief adjustment.", "Moving files to a sane folder system beats the re-indexing hassle."],
  "Q18": ["Buying earplugs for sleep beats cost + carrying them + brief adaptation.", "Installing a password manager beats subscription + setup time."],
  "Q19": ["You’d rather meal-prep Sundays than eat randomly all week.", "You’d rather patch the jacket now than buy a new one later."],
  "Q20": ["Wait to buy winter tires until temperatures reliably drop.", "Postpone the camera upgrade until your next paid shoot."],
  "Q21": ["Borrow a neighbor’s specialty tool instead of buying one.", "Use public transit route that’s nearly as fast and much cheaper."],
  "Q22": ["Editing a video: each extra pass improves less and less.", "Polishing a resume: beyond a few rounds, gains are tiny."],
  "Q24": ["Strength training: too light or too heavy both underperform; there’s a sweet spot.", "Caffeine: too little or too much is worse than a moderate dose."],
  "Q26": ["Switching to noise-isolating tips yields clearly clearer audio in a blind test.", "Adding under-desk lighting makes reading small labels noticeably easier."],
  "Q27": ["Sealing the driveway prevents cracks for years.", "Setting up automatic cloud backups prevents permanent data loss."],
  "Q28": ["Ice ankle now to reduce swelling even if full recovery takes longer.", "Use a temporary phone battery case for this weekend event."],
  "Q29": ["Wiping counters after each meal is always worth it.", "Running antivirus when a new USB is used is always worth it."],
  "Q30": ["Use pre-cut veggies service instead of spending hours chopping.", "Switch to a simpler CMS that meets needs with fewer headaches."],
  "Q31": ["Replace the washing machine hose before it bursts.", "Get a dental night guard to prevent grinding damage."],
  "Q32": ["Oil changes at the recommended interval.", "Descaling the espresso machine on schedule."],
  "Q33": ["If a brake failure would be catastrophic, set a higher severity; if a sticky cabinet hinge would be minor, set a low severity.", "For data loss on your main work laptop, pick higher severity; for a dead light bulb in a spare room, pick lower severity."],
  "Q34": ["Brake pad sensor squeal gives plenty of warning before rotor damage.", "Battery health app alerts you before the phone shuts off randomly."],
  "Q35": ["This sanding method gives the best finish among what you know.", "This study technique retains more than your alternatives."],
  "Q36": ["You compared spaced-repetition vs. rereading.", "You evaluated vinegar soak vs. descaling solution."],
  "Q37": ["Of all fixes, replacing the gasket stops the leak best.", "Of all methods, this interval plan builds speed most reliably."],
  "Q38": ["You checked if a pro service does it better for less net cost.", "You considered switching brands with better reliability."],
  "Q39": ["The repair kit is in stock today.", "Your mentor is free for a coaching session now."],
  "Q40": ["Booking during off-season lowers cost and stress.", "Doing it after your finals yields better focus."],
  "Q41": ["Waiting 2 weeks for the sale saves enough to justify the delay.", "Holding off until the skilled friend can help beats rushing today."],
  "Q42": ["You’d rather take the evening class even if self-study is possible now.", "You’d rather buy once-cry-once than patch a stopgap twice."],
  "Q43": ["Use the library’s 3D printer while you wait for parts.", "Try a nearby clinic that can see you tomorrow morning."],
  "Q44": ["Do yard work in spring for best results instead of winter now.", "Schedule the upgrade after the current project ships."],
  "Q45": ["Push the long trip until after the car service appointment.", "Delay filming until the new lights arrive next week."],
  "Q46": ["Replace the bike chain when stretch indicator hits the mark and creaks start.", "Service the A/C when airflow drops and pressure readings trend bad."],
  "Q47": ["Replace smoke alarm batteries when failure probability approaches your set threshold.", "Swap the UPS battery when charge-holding dips near your limit."]
};

/* ===== Special threshold-based examples for Q46/Q47 at extremes ===== */
window.examplesThreshold = {
  "Q46": {
    "0": [
      "Replace safety-critical parts at the first reliable warning—don’t wait for higher odds.",
      "Schedule service immediately if early signs appear and you treat any chance of failure as unacceptable."
    ],
    "90": [
      "Hold until clear warning signs stack up to near-certain failure, then act promptly.",
      "Plan replacement when indicators are overwhelmingly pointing to imminent failure."
    ]
  },
  "Q47": {
    "0": [
      "Change smoke-alarm batteries now if you’d lose sleep over even a tiny failure risk.",
      "Replace a worn climbing sling immediately if any fraying makes you uneasy."
    ],
    "90": [
      "Wait until the battery barely holds charge, then replace before it dies unpredictably.",
      "Run shoes until cushioning is clearly shot, then swap just before the next big run."
    ]
  }
};

/* ============== MINI MATH + STATE (additive, no removals) ============== */

// Shared master state for Q6 entries
var miniMaster = {
  S: 5, C: 1,             // up to 10; can be <1; not 0
  mode: 'oneInX',         // 'oneInX' | 'percent' | 'micromort'
  val: 1000000,           // user-entered value in selected mode
  X_user: 1000000         // normalized to 1 in X
};

// Blank-on-first-visit flag for Q6 (keeps user values if they come back)
if (typeof window.miniPristine === 'undefined') window.miniPristine = true;
  
// constants (match the mini prototype)
var MINI_EPS = 1e-9, MINI_MAX = 10;
var MINI_ALPHA = Math.log(0.5) / Math.log((Math.sqrt(10) - 1) / 9);

// math helpers
function miniClamp(v, lo, hi){ return Math.min(hi, Math.max(lo, v)); }
function miniCeilPlaces(x,p){ var f=Math.pow(10,p); return Math.ceil(x*f)/f; }

function miniNormalizeToX(mode, val){
  if (mode === 'oneInX')   { if (!(val>1)) return null; return val; }
  if (mode === 'percent')  { if (!(val>0 && val<100)) return null; return 100/val; }
  if (mode === 'micromort'){ if (!(val>0 && val<1e6)) return null; return 1e6/val; }
  return null;
}
function miniXcutoff_from_ratio(r) {
  var tRaw = (r - 1) / 9;
  var t = Math.max(0, Math.min(1, tRaw));
  var exponent = 6 * Math.pow(t, MINI_ALPHA);
  return Math.pow(10, exponent);
}
function miniComputeSCutoffForX(X){
  return 1 + 9 * Math.pow((Math.log10(X)/6), 1/MINI_ALPHA);
}

function miniProbSymbol(mode){ return mode==='percent' ? '%' : (mode==='micromort' ? 'µm' : 'X'); }
function miniXtoUnit(X,mode){ return mode==='percent' ? (100/X) : (mode==='micromort' ? (1e6/X) : X); }
function unitToX(Y, mode){
  // inverse of miniXtoUnit
  if (mode === 'percent')   return 100 / Y;          // X = 100 / %
  if (mode === 'micromort') return 1e6 / Y;          // X = 1e6 / µm
  return Y;                                           // 1 in X scale -> X = Y
}

// Helper: fast fade-in → HOLD → fast fade-out (total time = --flash-dur)
function flashWithPlateau(el, cls, opts) {
  if (!el) return;

  // Read global duration (fallback 1500ms), then derive phase timings if not passed
  const root = getComputedStyle(document.documentElement);
  const durStr = (root.getPropertyValue('--flash-dur').trim() || '1500ms');
  const totalMs = durStr.endsWith('ms') ? parseFloat(durStr) : parseFloat(durStr) * 1000;

  const inMs   = opts?.inMs  ?? 180;   // fast in
  const outMs  = opts?.outMs ?? 420;   // fast out
  const holdMs = opts?.holdMs ?? Math.max(0, totalMs - inMs - outMs); // fill the rest

  // Clear any prior flash classes
  el.classList.remove('flash-purple','flash-green','flash-gold');

  // PHASE 1: fast fade-in
  el.style.setProperty('--flash-dur', inMs + 'ms');
  requestAnimationFrame(() => {
    el.classList.add(cls);

    // After fade-in completes, HOLD solid (no transition running)
    setTimeout(() => {
      el.style.setProperty('--flash-dur', '0ms'); // instant changes while holding

      // PHASE 3: fast fade-out back to base
      setTimeout(() => {
        el.style.setProperty('--flash-dur', outMs + 'ms');
        requestAnimationFrame(() => {
          el.classList.remove(cls);

          // Cleanup: restore element to using the stylesheet’s --flash-dur
          setTimeout(() => {
            el.style.removeProperty('--flash-dur');
          }, outMs + 50);
        });
      }, holdMs);

    }, inMs + 20); // tiny buffer to ensure the first transition has finished
  });
}
  
function flashAb2Heading(id) {
  const h = document.getElementById(id);
  if (!h) return;

  // Reuse the same purple flash as verdict header
  flashWithPlateau(h, 'flash-purple', { inMs: 300, holdMs: 900, outMs: 300 });
}

function formatCShort(c){
  // show a compact C in the tooltip while preserving full-precision in state
  if (!isFinite(c)) return String(c);
  if (c >= 1) return Number(c).toFixed(3).replace(/\.?0+$/,'');
  // for small values, show up to 4 significant digits
  return Number(c.toPrecision(4)) + '';
}

// ---- persistence helpers (use for Q6/Q33/etc.) ----
function saveNodeState(key, obj){
  try { sessionStorage.setItem('node:'+key, JSON.stringify(obj)); } catch(_) {}
}
function loadNodeState(key){
  try { const raw = sessionStorage.getItem('node:'+key); return raw ? JSON.parse(raw) : null; }
  catch(_) { return null; }
}
function collectFormValues(root){
  const out = {};
  if (!root) return out;
  root.querySelectorAll('input[name], select[name], textarea[name]').forEach(el => {
    if (el.type === 'checkbox') out[el.name] = !!el.checked;
    else if (el.type === 'radio') { if (el.checked) out[el.name] = el.value; }
    else out[el.name] = el.value;
  });
  return out;
}
function applyFormValues(root, vals){
  if (!root || !vals) return;
  Object.keys(vals).forEach(name => {
    root.querySelectorAll(`[name="${CSS.escape(name)}"]`).forEach(el => {
      const v = vals[name];
      if (el.type === 'checkbox') el.checked = !!v;
      else if (el.type === 'radio') el.checked = (el.value === v);
      else el.value = v;
      el.dispatchEvent(new Event('input',  { bubbles:true }));
      el.dispatchEvent(new Event('change', { bubbles:true }));
    });
  });
}
  
/* ============== MINI RENDERERS FOR Q6 & Q7 ============== */
/* -----------------------------------------------------------
   Shared tiny haptic helper (safe no-op on iOS Safari)
----------------------------------------------------------- */
window.hapticBump = window.hapticBump || function () {
  try { if (navigator.vibrate) navigator.vibrate(12); } catch (_) {}
};

// Cosmetic: shorten long decimals for the floating label (does not change actual values)
function trimDeci(val, places = 3) {
  const n = Number(val);
  if (!isFinite(n)) return String(val);
  // keep small integers untouched; otherwise trim without trailing zeros
  const s = n.toFixed(places);
  return s.indexOf('.') === -1 ? s : s.replace(/\.?0+$/, '');
}

// Given a ratio r and the current mode, return the curve's **pixel Y** at that r
function curveYPxAtRatio(r, mode, pad, plotH, yToPx) {
  const Xc = miniXcutoff_from_ratio(r);
  const yr = (function yRange(m){
    if (m==='percent')   return { yMin: 0.0001, yMax: 100 };
    if (m==='micromort') return { yMin: 1,      yMax: 1e6  };
    return { yMin: 1,     yMax: 1e6  }; // 1 in X
  })(mode);
  const Yc = miniXtoUnit(Xc, mode);
  return yToPx(Yc, yr.yMin, yr.yMax);
}

// --- GLOBAL: smooth scroll + back injection (single source of truth) ---
function scrollToConcept(targetId, backQId) {
  if (window.__isScrollingConcept) return;
  window.__isScrollingConcept = true;

  const START = performance.now();
  const MAX_MS = 3000;
  const INTERVAL = 120;

  function scrollAndInject() {
    const el = document.getElementById(targetId);
    if (!el) return false;
    el.scrollIntoView({ behavior: 'smooth', block: 'start' });
    ensureConceptBackButton(targetId, backQId);
    flashAb2Heading(targetId); // 👈 smooth purple pulse here
    return true;
  }

  if (scrollAndInject()) { window.__isScrollingConcept = false; return; }
  (function tick(){
    if (scrollAndInject()) { window.__isScrollingConcept = false; return; }
    if (performance.now() - START >= MAX_MS) { window.__isScrollingConcept = false; return; }
    setTimeout(tick, INTERVAL);
  })();
}

// Back button injected directly *below* the heading, blue-styled
function ensureConceptBackButton(targetId, backQId) {
  const heading = document.getElementById(targetId);
  if (!heading) return;
  if (heading.dataset.backInjected === '1') return;

  const btn = document.createElement('button');
  btn.type = 'button';
  // Add both classes: keeps the semantic 'concept-back' marker,
  // but also inherits the Restart button styling.
  btn.className = 'concept-back restart';
  btn.textContent = '← Back';

  btn.addEventListener('click', (ev) => {
    ev.preventDefault();
    if (typeof goBack === 'function') goBack();
  });

  heading.insertAdjacentElement('afterend', btn);
  heading.dataset.backInjected = '1';
}

function jumpToConcept(conceptId, backQId) {
  window.__pendingConceptScroll = { conceptId, backQId: backQId || __lastQuestionId || 'Q0' };
  window.__ab2TempVisit = true; // 🔹 mark this visit as temporary
  goToNode('AB2');
}

/* ===========================================================
   Q6 — interactive: inputs + 2D drag + snap + correct shading
=========================================================== */
function renderMiniQ6(intoEl, node){
  // first-visit flag (keeps user values if they come back later)
  if (typeof window.miniPristine === 'undefined') window.miniPristine = true;
  let cont;

  intoEl.innerHTML = '';

  // Top text
  const top = document.createElement('div');
  top.className = 'mini-top';
  top.innerHTML = node.text || '';
  intoEl.appendChild(top);

  // Wrapper + fields
  const wrap = document.createElement('div'); wrap.className = 'mini-wrap';
  const fields = document.createElement('div'); fields.className = 'mini-fields';

  // IMPORTANT: use type="text" so we can allow interim states while typing
  const sBox = document.createElement('div'); sBox.className='mini-field';
  sBox.innerHTML = '<label>Severity (S) — up to 10</label><input id="miniS" type="number" step="0.01" max="10" placeholder="e.g. 5">';
  const cBox = document.createElement('div'); cBox.className='mini-field';
  cBox.innerHTML = '<label>Cost (C) — up to 10</label><input id="miniC" type="number" step="0.01" max="10" placeholder="e.g. 1">';
  fields.appendChild(sBox); fields.appendChild(cBox);

  const pRow = document.createElement('div'); pRow.className='mini-fields';
  const mBox = document.createElement('div'); mBox.className='mini-field';
  mBox.innerHTML = '<label>Probability input mode</label>\
    <select id="miniMode" name="q6Units">\
      <option value="oneInX">1 in X</option>\
      <option value="percent">Percentage (%)</option>\
      <option value="micromort">Micromorts</option>\
    </select>';
  const vBox = document.createElement('div'); vBox.className='mini-field';
  vBox.innerHTML = '<label id="miniProbLabel">Enter X (for “1 in X”)</label><input id="miniVal" type="number" min="2" step="1" placeholder="e.g. 1,000,000">';
  pRow.appendChild(mBox); pRow.appendChild(vBox);

  wrap.appendChild(fields); wrap.appendChild(pRow);

  const q6Root = intoEl;  // this is the DOM container for Q6

  // SVG
  const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.classList.add('mini-svg');
  svg.setAttribute('viewBox','0 0 940 620');
  svg.style.overflow = 'visible';
  wrap.appendChild(svg);

  // Rule + verdict
  const rule = document.createElement('div'); rule.className='rule';
  rule.innerHTML = 'Rule: Only if <span id="miniProbName">X</span> ≥ <b>Probability Cutoff</b> and <b>S/C ≥ S/C Cutoff</b> can action be considered.';
  const verdict = document.createElement('div'); verdict.className='verdict'; verdict.id='miniVerdict';
  verdict.textContent = 'Enter values to see if action should be considered.';
  wrap.appendChild(rule); wrap.appendChild(verdict);

  // 🔗 Inline “See Probability Concept” link (kept)
  const link = document.createElement('a');
  link.href = '#concept-prob-sev-cost';
  link.textContent = 'See full explanation of Probability × Severity × Cost';
  link.style.display = 'inline-block';
  link.style.marginTop = '8px';
  link.addEventListener('click', function(e){
    e.preventDefault();
    const target = 'concept-prob-sev-cost';
    history.replaceState(null, '', `#${target}`);
    jumpToConcept(target, /* back */ node.id);
  });
  wrap.appendChild(link);

  intoEl.appendChild(wrap);

  // Inputs
  const elS  = wrap.querySelector('#miniS');
  const elC  = wrap.querySelector('#miniC');
  const elM  = wrap.querySelector('#miniMode');
  const elV  = wrap.querySelector('#miniVal');
  const labV = wrap.querySelector('#miniProbLabel');
  const probName = wrap.querySelector('#miniProbName');

  // ===== Persistence (restore first) =====
  const savedQ6 = loadNodeState('Q6');
  if (savedQ6) applyFormValues(q6Root, savedQ6);

  // helpers
  function trimDeci(x,n=3){ if (!isFinite(x)) return String(x); const s=Number(x).toFixed(n).replace(/\.?0+$/,''); return s; }
  function yRange(mode){
    if (mode==='percent')   return { yMin: 0.0001, yMax: 100,   ticks:[100,10,1,0.1,0.01,0.001,0.0001], label:"Cutoff Probability (%) (log scale)" };
    if (mode==='micromort') return { yMin: 1,      yMax: 1e6,   ticks:[1e6,1e5,1e4,1e3,100,10,1],        label:"Cutoff Probability (µm) (log scale)" };
    return { yMin: 1, yMax: 1e6, ticks:[1,10,100,1e3,1e4,1e5,1e6], label:"Cutoff Probability as '1 in X' (log scale)" };
  }

  elM.value = miniMaster.mode;
  probName.textContent = miniProbSymbol(miniMaster.mode);
  function updateProbLabelForMode(mode){
    if (mode==='oneInX'){ labV.textContent='Enter X (for “1 in X”)'; elV.placeholder='e.g. 1,000,000'; }
    else if (mode==='percent'){ labV.textContent='Enter percentage (%)'; elV.placeholder='e.g. 0.01'; }
    else { labV.textContent='Enter micromorts (µm)'; elV.placeholder='e.g. 1'; }
    probName.textContent = miniProbSymbol(mode);
  }
  updateProbLabelForMode(miniMaster.mode);

  // hydrate or blank based on pristine
  if (!window.miniPristine) {
    if (!elS.value) elS.value = String(miniMaster.S);
    if (!elC.value) elC.value = String(miniMaster.C);
    if (!elV.value) elV.value = String(miniMaster.val);
  } else {
    if (!savedQ6) {
      elS.value = ''; elC.value = ''; elV.value = '';
      miniMaster.X_user = null;
    }
  }

  // SVG layers (unchanged)
  const axesG  = document.createElementNS('http://www.w3.org/2000/svg','g'); axesG.setAttribute('class','mini-axis'); svg.appendChild(axesG);
  const shadeIn= document.createElementNS('http://www.w3.org/2000/svg','path'); shadeIn.setAttribute('class','mini-shade-in'); svg.appendChild(shadeIn);
  const curve  = document.createElementNS('http://www.w3.org/2000/svg','path'); curve.setAttribute('class','mini-curve'); svg.appendChild(curve);
  const handle = document.createElementNS('http://www.w3.org/2000/svg','circle'); handle.setAttribute('class','mini-handle'); handle.setAttribute('r','12'); svg.appendChild(handle);

  const labelG = document.createElementNS('http://www.w3.org/2000/svg','g'); labelG.style.pointerEvents='none'; svg.appendChild(labelG);
  const labelBg= document.createElementNS('http://www.w3.org/2000/svg','rect'); labelBg.setAttribute('class','mini-ptlabel-bg'); labelBg.setAttribute('rx','10'); labelBg.setAttribute('ry','10'); labelG.appendChild(labelBg);
  const labelTx= document.createElementNS('http://www.w3.org/2000/svg','text'); labelTx.setAttribute('class','mini-ptlabel'); labelG.appendChild(labelTx);

  const xLab = document.createElementNS('http://www.w3.org/2000/svg','text'); xLab.setAttribute('class','mini-axes-label'); xLab.setAttribute('text-anchor','middle'); svg.appendChild(xLab);
  const yLab = document.createElementNS('http://www.w3.org/2000/svg','text'); yLab.setAttribute('class','mini-axes-label'); yLab.setAttribute('text-anchor','middle'); svg.appendChild(yLab);

  // geometry (unchanged)
  const pad = { left:120, right:30, top:34, bottom:96 };
  const W=940, H=620, plotW=W-pad.left-pad.right, plotH=H-pad.top-pad.bottom;
  const rMin=1, rMax=10;
  function rToPx(r){ return pad.left + (r-rMin)/(rMax-rMin)*plotW; }
  function pxToR(px){ return (rMin + (px-pad.left)/plotW*(rMax-rMin)); }
  function yToPx(y,yMin,yMax){ return pad.top + plotH * (1 - (Math.log10(y)-Math.log10(yMin))/(Math.log10(yMax)-Math.log10(yMin))); }

  function drawAxes(mode){
    axesG.innerHTML='';
    // x grid + ticks
    for (let r=1;r<=10;r++){
      const x = rToPx(r);
      const v = document.createElementNS('http://www.w3.org/2000/svg','line');
      v.setAttribute('x1',x); v.setAttribute('x2',x); v.setAttribute('y1',pad.top); v.setAttribute('y2',pad.top+plotH);
      axesG.appendChild(v);
      const t=document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x',x); t.setAttribute('y', pad.top + plotH + 16);
      t.setAttribute('dominant-baseline','hanging'); t.setAttribute('text-anchor','middle'); t.textContent=r;
      axesG.appendChild(t);
    }
    // y grid + ticks
    const yr=yRange(mode);
    yr.ticks.forEach(yv=>{
      const y = yToPx(yv, yr.yMin, yr.yMax);
      const h=document.createElementNS('http://www.w3.org/2000/svg','line');
      h.setAttribute('x1',pad.left); h.setAttribute('x2',pad.left+plotW); h.setAttribute('y1',y); h.setAttribute('y2',y);
      axesG.appendChild(h);
      const yt=document.createElementNS('http://www.w3.org/2000/svg','text');
      yt.setAttribute('x', pad.left - 10); yt.setAttribute('y', y);
      yt.setAttribute('text-anchor','end'); yt.setAttribute('dominant-baseline','middle');
      yt.textContent = (mode==='percent' ? (yv>=1?String(yv):yv.toExponential(1)) : yv.toLocaleString());
      axesG.appendChild(yt);
    });
    // labels
    xLab.setAttribute('x', pad.left+plotW/2); xLab.setAttribute('y', H-10);
    xLab.textContent = 'Severity / Cost Ratio (S / C)';

    const Y_LABEL_OFFSET = 90, desiredLeftPadding=8;
    yLab.textContent = yRange(mode).label;
    yLab.setAttribute('text-anchor','middle'); yLab.setAttribute('dominant-baseline','middle');
    const cy = pad.top + plotH/2, cx0 = pad.left - Y_LABEL_OFFSET;
    yLab.setAttribute('transform', `translate(${cx0} ${cy}) rotate(-90)`);
    const bb = yLab.getBBox(); const currentLeft = cx0 - (bb.height/2);
    const dx = Math.max(0, desiredLeftPadding - currentLeft);
    yLab.setAttribute('transform', `translate(${cx0 + dx} ${cy}) rotate(-90)`);
  }

  function buildCurve(mode){
    const yr=yRange(mode), N=800;
    let d='';
    for (let i=0;i<=N;i++){
      const r = 1 + 9*(i/N);
      const X = miniXcutoff_from_ratio(r);
      const Y = miniXtoUnit(X, mode);
      const x = rToPx(r), y = yToPx(Y, yr.yMin, yr.yMax);
      d += (i? 'L ':'M ') + x + ',' + y + ' ';
    }
    curve.setAttribute('d', d);

    // shaded region (act region)
    const leftX=rToPx(1), rightX=rToPx(10);
    if (mode === 'oneInX'){
      const bottom = yToPx(yr.yMin, yr.yMin, yr.yMax);
      shadeIn.setAttribute('d', d + ' L ' + rightX + ',' + bottom + ' L ' + leftX + ',' + bottom + ' Z');
    } else {
      const top = yToPx(yr.yMax, yr.yMin, yr.yMax);
      shadeIn.setAttribute('d', d + ' L ' + rightX + ',' + top + ' L ' + leftX + ',' + top + ' Z');
    }
  }

  function curveYPxAtRatio(r, mode){
    const yr = yRange(mode);
    const Xc = miniXcutoff_from_ratio(r);
    const Yc = miniXtoUnit(Xc, mode);
    return yToPx(Yc, yr.yMin, yr.yMax);
  }

  function snapInputs(){
    if (window.miniPristine) return;
    let S = parseFloat(elS.value);
    let C = parseFloat(elC.value);
    const mode = elM.value;
    let vv = parseFloat(elV.value);

    if (!isFinite(S)) S = miniMaster.S;
    if (!isFinite(C)) C = miniMaster.C;
    if (S<=0) S = MINI_EPS; if (C<=0) C = MINI_EPS;
    S = Math.min(S, MINI_MAX); C = Math.min(C, MINI_MAX);

    if (!isFinite(vv)) vv = miniMaster.val;
    if (mode==='oneInX' && vv < 2) vv = 2;
    if (mode==='percent'){ if (vv<=0) vv=0.000001; if (vv>=100) vv=99.999999; }
    if (mode==='micromort'){ if (vv<=0) vv=0.0001; if (vv>=1e6) vv=999999.99; }

    elS.value = String(S); elC.value = String(C); elV.value = String(vv);

    miniMaster.S=S; miniMaster.C=C; miniMaster.mode=mode; miniMaster.val=vv;
    miniMaster.X_user = miniNormalizeToX(mode, vv);
  }

  const SNAP_PX = 22;
  let isSnapped = false;

  function draw(){
    const mode = elM.value;
    drawAxes(mode);
    buildCurve(mode);

    if (window.miniPristine){
      verdict.textContent = 'Enter values to see if action should be considered.';
      verdict.classList.remove('ok','no');
      handle.setAttribute('visibility','hidden');
      labelG.setAttribute('visibility','hidden');
      if (cont) cont.disabled = true;
      return;
    } else {
      handle.removeAttribute('visibility');
      labelG.removeAttribute('visibility');
    }

    snapInputs();

    const r  = miniMaster.S/miniMaster.C;
    const Xc = miniXcutoff_from_ratio(r);
    const yr = yRange(mode);

    const Yuser = (miniMaster.X_user != null)
      ? miniXtoUnit(miniMaster.X_user, mode)
      : miniXtoUnit(Xc, mode);

    const cx = rToPx(miniClamp(r,1,10));
    const cy = yToPx(Yuser, yr.yMin, yr.yMax);
    handle.setAttribute('cx', cx); handle.setAttribute('cy', cy);

    const label = 'S=' + trimDeci(miniMaster.S) + ' , C=' + trimDeci(miniMaster.C) + ' · S/C=' + trimDeci(r) + ' · ' +
      (mode==='percent' ? ('X≈' + trimDeci(100/Xc,6) + '%') : (mode==='micromort' ? ('X≈' + trimDeci(1e6/Xc,2) + ' µm') : ('X≈' + Math.round(Xc).toLocaleString())));
    labelTx.textContent = label;
    labelTx.setAttribute('text-anchor','middle');
    let ly = cy - 34; const minTop = pad.top + 20; if (ly < minTop) ly = minTop;
    labelTx.setAttribute('x', cx); labelTx.setAttribute('y', ly);
    const bb = labelTx.getBBox(); const padBox=10;
    labelBg.setAttribute('x', bb.x-padBox); labelBg.setAttribute('y', bb.y-padBox);
    labelBg.setAttribute('width', bb.width+2*padBox); labelBg.setAttribute('height', bb.height+2*padBox);

    const act = (miniMaster.X_user != null) ? (miniMaster.X_user <= Xc + 1e-15) : false;
    verdict.textContent = act ? 'Verdict: Action should be considered.' : 'Verdict: Action should NOT be considered.';
    verdict.classList.toggle('ok', act);
    verdict.classList.toggle('no', !act);

    renderMiniQ6._act = act;
    if (cont) cont.disabled = false;
  }

  // pointer helpers (unchanged)
  function svgPoint(evt){
    const pt = svg.createSVGPoint();
    pt.x = (evt.touches && evt.touches[0] ? evt.touches[0].clientX : evt.clientX);
    pt.y = (evt.touches && evt.touches[0] ? evt.touches[0].clientY : evt.clientY);
    return pt.matrixTransform(svg.getScreenCTM().inverse());
  }

  let dragging=false;
  function onPointerDown(e){ e.preventDefault(); window.miniPristine=false; dragging=true; try{handle.setPointerCapture(e.pointerId);}catch(_){ } onPointerMove(e); }
  function onPointerMove(e){
    if(!dragging) return; e.preventDefault();
    const sp = svgPoint(e);
    const px = miniClamp(sp.x, pad.left, pad.left+plotW);
    const r  = pxToR(px);

    // snapping (vertical)
    const yCursor = Math.max(pad.top, Math.min(pad.top+plotH, sp.y));
    const yCurve  = curveYPxAtRatio(r, elM.value);
    const willSnap = Math.abs(yCursor - yCurve) <= SNAP_PX;
    if (willSnap && !isSnapped && typeof window.hapticBump === 'function') window.hapticBump();
    isSnapped = willSnap;

    // vary C to follow r = S/C, keep within bounds
    let S = miniClamp(parseFloat(elS.value)||miniMaster.S||5, MINI_EPS, MINI_MAX);
    let C = S / r;
    if (C <= MINI_EPS || C > MINI_MAX){
      C = miniClamp(parseFloat(elC.value)||miniMaster.C||1, MINI_EPS, MINI_MAX);
      S = r * C;
      if (S <= MINI_EPS || S > MINI_MAX){
        S = miniClamp(S, MINI_EPS, MINI_MAX);
        C = miniClamp(S / r, MINI_EPS, MINI_MAX);
      }
    }
    elS.value = String(S); elC.value = String(C);

    // compute user probability from yCursor (snap to curve if close)
    const mode = elM.value;
    const yr = yRange(mode);
    let yPix = Math.min(pad.top+plotH, Math.max(pad.top, sp.y));
    if (willSnap) yPix = yCurve;
    const frac = 1 - (yPix - pad.top) / plotH;
    const logY = Math.log10(yr.yMin) + frac * (Math.log10(yr.yMax) - Math.log10(yr.yMin));
    const Y = Math.pow(10, logY);
    const X_user = unitToX(Y, mode);
    miniMaster.S = S; miniMaster.C = C; miniMaster.mode = mode; miniMaster.X_user = X_user;

    // reflect into the input in chosen unit
    let valOut = (mode==='oneInX') ? X_user : (mode==='percent' ? (100/X_user) : (1e6/X_user));
    if (mode==='oneInX') { if (valOut < 2) valOut = 2; }
    else if (mode==='percent') { if (valOut<=0) valOut=0.000001; if (valOut>=100) valOut=99.999999; }
    else { if (valOut<=0) valOut=0.0001; if (valOut>=1e6) valOut=999999.99; }
    elV.value = String(valOut);
    miniMaster.val = valOut;

    draw();
  }
  function onPointerUp(e){ dragging=false; try{handle.releasePointerCapture(e.pointerId);}catch(_){} }

  handle.addEventListener('pointerdown', onPointerDown, {passive:false});
  svg.addEventListener('pointermove', onPointerMove, {passive:false});
  svg.addEventListener('pointerup', onPointerUp, {passive:false});
  svg.addEventListener('touchstart', onPointerDown, {passive:false});
  svg.addEventListener('touchmove', onPointerMove, {passive:false});
  svg.addEventListener('touchend', onPointerUp, {passive:false});

  // ===== Micromorts lock (S=10 + grey out) & friendly inputs =====

  // lock/unlock severity when micromorts is chosen
  function lockSeverity(val = 10){
    elS.value = String(val);
    elS.disabled = true;
    elS.classList.add('is-disabled');
  }
  function unlockSeverity(){
    elS.disabled = false;
    elS.classList.remove('is-disabled');
  }
  function applyUnitsRule(){
    const mode = elM.value;
    if (mode === 'micromort' || mode === 'micromorts') lockSeverity(10);
    else unlockSeverity();
  }
  applyUnitsRule();
  elM.addEventListener('change', () => { updateProbLabelForMode(elM.value); applyUnitsRule(); });

  // backspace-friendly inputs: sanitize on blur (NOT on every keystroke)
  function wireNumericInput(inp, { min=-Infinity, max=Infinity, decimals=null } = {}){
    if (!inp) return;

    // Allow free typing; just strip obvious junk
    inp.addEventListener('input', () => {
      const s = inp.value;
      const cleaned = s
        .replace(/[^0-9.\-]/g, '')
        .replace(/(.*\..*)\./, '$1')
        .replace(/(.*-).*-/ , '$1');
      if (cleaned !== s) inp.value = cleaned;
    });

    function normalize(){
      const raw = (inp.value || '').trim();
      if (raw === '' || raw === '-' || raw === '.' || raw === '-.') { inp.value = ''; return; }
      let n = Number(raw);
      if (!Number.isFinite(n)) { inp.value = ''; return; }
      n = Math.min(max, Math.max(min, n));
      inp.value = (decimals == null) ? String(n) : String(Number(n.toFixed(decimals)));
      // After we accept a value, update visuals
      window.miniPristine = false;
      draw();
    }
    inp.addEventListener('blur', normalize);
    inp.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); inp.blur(); } });
  }

  wireNumericInput(elS, { min:0, max:10,   decimals:2 });
  wireNumericInput(elC, { min:0, max:10,   decimals:2 });
  wireNumericInput(elV, { min:0, max:1e12, decimals:6 });

  // inputs: no snap-back while typing; we only redraw on blur/Enter
  elS.addEventListener('input', ()=>{ window.miniPristine=false; });
  elC.addEventListener('input', ()=>{ window.miniPristine=false; });
  elV.addEventListener('input', ()=>{ window.miniPristine=false; });

  // Persist on any edit
  const persistQ6 = () => saveNodeState('Q6', collectFormValues(q6Root));
  q6Root.addEventListener('input',  persistQ6);
  q6Root.addEventListener('change', persistQ6);

  // initial paint
  draw();

  // Bottom buttons
  const btns = document.getElementById('buttons');
  btns.innerHTML = '';
  cont = document.createElement('button'); cont.className='next'; cont.type='button'; cont.textContent='Continue'; cont.disabled=true;
  cont.onclick = function(){
    miniActGate = !!renderMiniQ6._act;
    goToNode(miniActGate ? 'Q10' : 'Q7');
  };
  btns.appendChild(cont);
}

/* ===========================================================
   Q7 — visualization-only mirror (draggable; inputs greyed)
=========================================================== */
function renderMiniQ7(intoEl, node){
  intoEl.innerHTML = '';

  const top = document.createElement('div');
  top.className = 'mini-top';
  top.innerHTML = node.text || '';
  intoEl.appendChild(top);

  const local = { S: miniMaster.S, C: miniMaster.C, mode: miniMaster.mode, val: miniMaster.val, X_user: miniMaster.X_user };

  const wrap = document.createElement('div'); wrap.className = 'mini-wrap';
  const fields = document.createElement('div'); fields.className = 'mini-fields mini-muted';

  const sBox = document.createElement('div'); sBox.className='mini-field';
  sBox.innerHTML = '<label>Severity (S) — up to 10</label><input id="miniS2" type="number" step="0.01" max="10" inputmode="decimal" disabled>';
  const cBox = document.createElement('div'); cBox.className='mini-field';
  cBox.innerHTML = '<label>Cost (C) — up to 10</label><input id="miniC2" type="number" step="0.01" max="10" inputmode="decimal" disabled>';
  fields.appendChild(sBox); fields.appendChild(cBox);

  const pRow = document.createElement('div'); pRow.className='mini-fields mini-muted';
  const mBox = document.createElement('div'); mBox.className='mini-field';
  mBox.innerHTML = '<label>Probability input mode</label>\
    <select id="miniMode2" disabled>\
      <option value="oneInX">1 in X</option>\
      <option value="percent">Percentage (%)</option>\
      <option value="micromort">Micromorts</option>\
    </select>';
  const vBox = document.createElement('div'); vBox.className='mini-field';
  vBox.innerHTML = '<label id="miniProbLabel2">Enter X (for “1 in X”)</label><input id="miniVal2" type="number" disabled>';
  pRow.appendChild(mBox); pRow.appendChild(vBox);

  wrap.appendChild(fields); wrap.appendChild(pRow);

  const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.classList.add('mini-svg'); svg.setAttribute('viewBox','0 0 940 620'); svg.style.overflow='visible';
  wrap.appendChild(svg);

  const rule = document.createElement('div'); rule.className='rule';
  rule.innerHTML = 'Rule: Only if <span id="miniProbName2">X</span> ≥ <b>Probability Cutoff</b> and <b>S/C ≥ S/C Cutoff</b> can action be considered.';
  const verdict = document.createElement('div'); verdict.className='verdict'; verdict.id='miniVerdict2';
  verdict.textContent = 'Verdict: Action should NOT be considered.';
  wrap.appendChild(rule); wrap.appendChild(verdict);

  intoEl.appendChild(wrap);

  // 🔗 Inline link on Q7 — force visible + jump with back context
  const link = document.createElement('a');
  link.href = '#concept-prob-sev-cost';                // real hash (not javascript:)
  link.textContent = 'See full explanation and formulas';
  link.className = 'concept-link';
  link.style.cssText =
    'display:inline-block;margin-top:12px;text-decoration:underline;' +
    'color:var(--accent,#3b82f6);cursor:pointer;';
  link.addEventListener('click', function (e) {
    e.preventDefault();
    history.replaceState(null, '', '#concept-prob-sev-cost');   // keep URL in sync
    jumpToConcept('concept-prob-sev-cost', __lastQuestionId || node.id);
  })
  wrap.appendChild(link);
  
  const elS = wrap.querySelector('#miniS2');
  const elC = wrap.querySelector('#miniC2');
  const elM = wrap.querySelector('#miniMode2');
  const elV = wrap.querySelector('#miniVal2');
  const labV= wrap.querySelector('#miniProbLabel2');
  const probName2 = wrap.querySelector('#miniProbName2');

  function trimDeci(x,n=3){ if (!isFinite(x)) return String(x); const s=Number(x).toFixed(n).replace(/\.?0+$/,''); return s; }
  function yRange(mode){
    if (mode==='percent')   return { yMin: 0.0001, yMax: 100,   ticks:[100,10,1,0.1,0.01,0.001,0.0001], label:"Cutoff Probability (%) (log scale)" };
    if (mode==='micromort') return { yMin: 1,      yMax: 1e6,  ticks:[1e6,1e5,1e4,1e3,100,10,1],        label:"Cutoff Probability (µm) (log scale)" };
    return { yMin: 1, yMax: 1e6, ticks:[1,10,100,1e3,1e4,1e5,1e6], label:"Cutoff Probability as '1 in X' (log scale)" };
  }
  function setModeLabel(mode){
    if (mode==='oneInX'){
      labV.textContent='Enter X (for “1 in X”)';
      elV.placeholder='e.g. 1,000,000';
    } else if (mode==='percent'){
      labV.textContent='Enter percentage (%)';
      elV.placeholder='e.g. 0.01';
    } else {
      labV.textContent='Enter micromorts (µm)';
      elV.placeholder='e.g. 1';
    }
    probName2.textContent = miniProbSymbol(mode);
  }
  function hydrate(){
    elS.value = String(local.S);
    elC.value = String(local.C);
    elM.value = local.mode;
    elV.value = String(local.val);
    setModeLabel(local.mode);
  }
  hydrate();

  // layers
  const axesG  = document.createElementNS('http://www.w3.org/2000/svg','g'); axesG.setAttribute('class','mini-axis'); svg.appendChild(axesG);
  const shadeIn= document.createElementNS('http://www.w3.org/2000/svg','path'); shadeIn.setAttribute('class','mini-shade-in'); svg.appendChild(shadeIn);
  const curve  = document.createElementNS('http://www.w3.org/2000/svg','path'); curve.setAttribute('class','mini-curve'); svg.appendChild(curve);
  const handle = document.createElementNS('http://www.w3.org/2000/svg','circle'); handle.setAttribute('class','mini-handle'); handle.setAttribute('r','12'); svg.appendChild(handle);

  const labelG = document.createElementNS('http://www.w3.org/2000/svg','g'); labelG.style.pointerEvents='none'; svg.appendChild(labelG);
  const labelBg= document.createElementNS('http://www.w3.org/2000/svg','rect'); labelBg.setAttribute('class','mini-ptlabel-bg'); labelBg.setAttribute('rx','10'); labelBg.setAttribute('ry','10'); labelG.appendChild(labelBg);
  const labelTx= document.createElementNS('http://www.w3.org/2000/svg','text'); labelTx.setAttribute('class','mini-ptlabel'); labelG.appendChild(labelTx);

  const xLab = document.createElementNS('http://www.w3.org/2000/svg','text'); xLab.setAttribute('class','mini-axes-label'); xLab.setAttribute('text-anchor','middle'); svg.appendChild(xLab);
  const yLab = document.createElementNS('http://www.w3.org/2000/svg','text'); yLab.setAttribute('class','mini-axes-label'); yLab.setAttribute('text-anchor','middle'); svg.appendChild(yLab);

  // Geometry
  const pad = { left:120, right:30, top:34, bottom:96 };
  const W=940, H=620, plotW=W-pad.left-pad.right, plotH=H-pad.top-pad.bottom;
  const rMin=1, rMax=10;
  function rToPx(r){ return pad.left + (r-rMin)/(rMax-rMin)*plotW; }
  function pxToR(px){ return (rMin + (px-pad.left)/plotW*(rMax-rMin)); }
  function yToPx(y,yMin,yMax){ return pad.top + plotH * (1 - (Math.log10(y)-Math.log10(yMin))/(Math.log10(yMax)-Math.log10(yMin))); }

  function drawAxes(mode){
    axesG.innerHTML='';
    for (let r=1;r<=10;r++){
      const x=rToPx(r);
      const v=document.createElementNS('http://www.w3.org/2000/svg','line');
      v.setAttribute('x1',x); v.setAttribute('x2',x); v.setAttribute('y1',pad.top); v.setAttribute('y2',pad.top+plotH);
      axesG.appendChild(v);
      const t=document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x',x); t.setAttribute('y', pad.top + plotH + 16);
      t.setAttribute('dominant-baseline','hanging'); t.setAttribute('text-anchor','middle'); t.textContent=r;
      axesG.appendChild(t);
    }
    const yr = yRange(mode);
    yr.ticks.forEach(yv=>{
      const y = yToPx(yv, yr.yMin, yr.yMax);
      const h=document.createElementNS('http://www.w3.org/2000/svg','line');
      h.setAttribute('x1',pad.left); h.setAttribute('x2',pad.left+plotW); h.setAttribute('y1',y); h.setAttribute('y2',y);
      axesG.appendChild(h);
      const yt=document.createElementNS('http://www.w3.org/2000/svg','text');
      yt.setAttribute('x', pad.left - 10); yt.setAttribute('y', y);
      yt.setAttribute('text-anchor','end'); yt.setAttribute('dominant-baseline','middle');
      yt.textContent = (mode==='percent' ? (yv>=1?String(yv):yv.toExponential(1)) : yv.toLocaleString());
      axesG.appendChild(yt);
    });
    xLab.setAttribute('x', pad.left+plotW/2); xLab.setAttribute('y', H-10);
    xLab.textContent = 'Severity / Cost Ratio (S / C)';

    const Y_LABEL_OFFSET=90, desiredLeftPadding=8;
    yLab.textContent = yRange(mode).label;
    yLab.setAttribute('text-anchor','middle'); yLab.setAttribute('dominant-baseline','middle');
    const cy = pad.top + plotH/2, cx0 = pad.left - Y_LABEL_OFFSET;
    yLab.setAttribute('transform', `translate(${cx0} ${cy}) rotate(-90)`);
    const bb = yLab.getBBox(); const currentLeft = cx0 - (bb.height/2);
    const dx = Math.max(0, desiredLeftPadding - currentLeft);
    yLab.setAttribute('transform', `translate(${cx0 + dx} ${cy}) rotate(-90)`);
  }

  function buildCurve(mode){
    const yr=yRange(mode), N=800; let d='';
    for (let i=0;i<=N;i++){
      const r = 1 + 9*(i/N);
      const X = miniXcutoff_from_ratio(r);
      const Y = miniXtoUnit(X, mode);
      const x = rToPx(r), y = yToPx(Y, yr.yMin, yr.yMax);
      d += (i? 'L ':'M ') + x + ',' + y + ' ';
    }
    curve.setAttribute('d', d);
    const leftX=rToPx(1), rightX=rToPx(10);
    if (mode==='oneInX'){
      const bottom = yToPx(yr.yMin, yr.yMin, yr.yMax);
      shadeIn.setAttribute('d', d + ' L ' + rightX + ',' + bottom + ' L ' + leftX + ',' + bottom + ' Z');
    } else {
      const top = yToPx(yr.yMax, yr.yMin, yr.yMax);
      shadeIn.setAttribute('d', d + ' L ' + rightX + ',' + top + ' L ' + leftX + ',' + top + ' Z');
    }
  }

  function curveYPxAtRatio(r, mode){
    const yr = yRange(mode);
    const Xc = miniXcutoff_from_ratio(r);
    const Yc = miniXtoUnit(Xc, mode);
    return yToPx(Yc, yr.yMin, yr.yMax);
  }

  const SNAP_PX = 22;
  let isSnapped = false;

  function draw(){
    drawAxes(local.mode); buildCurve(local.mode);

    const r = local.S/local.C;
    const Xc = miniXcutoff_from_ratio(r);
    const yr = yRange(local.mode);
    const Y = (local.X_user != null) ? miniXtoUnit(local.X_user, local.mode) : miniXtoUnit(Xc, local.mode);

    const cx = rToPx(miniClamp(r,1,10));
    const cy = yToPx(Y, yr.yMin, yr.yMax);
    handle.setAttribute('cx', cx); handle.setAttribute('cy', cy);

    const label = 'S=' + trimDeci(local.S) + ' , C=' + trimDeci(local.C) + ' · S/C=' + trimDeci(r) + ' · ' +
      (local.mode==='percent' ? ('X≈' + trimDeci(100/Xc,6) + '%') : (local.mode==='micromort' ? ('X≈' + trimDeci(1e6/Xc,2) + ' µm') : ('X≈' + Math.round(Xc).toLocaleString())));
    labelTx.textContent = label; labelTx.setAttribute('text-anchor','middle');
    let ly = cy - 34; const minTop=pad.top+20; if (ly<minTop) ly=minTop;
    labelTx.setAttribute('x', cx); labelTx.setAttribute('y', ly);
    const bb = labelTx.getBBox(); const padBox=10;
    labelBg.setAttribute('x', bb.x-padBox); labelBg.setAttribute('y', bb.y-padBox);
    labelBg.setAttribute('width', bb.width+2*padBox); labelBg.setAttribute('height', bb.height+2*padBox);

    const act = (local.X_user != null) ? (local.X_user <= Xc + 1e-15) : false;
    const vEl = document.getElementById('miniVerdict2');
    vEl.textContent = act ? 'Verdict: Action should be considered.' : 'Verdict: Action should NOT be considered.';
    vEl.classList.toggle('ok', act); vEl.classList.toggle('no', !act);

    elS.value = String(local.S); elC.value = String(local.C); elM.value = local.mode; elV.value = String(local.val);
  }

  // 2D drag with snapping (local copy only)
  function svgPoint(evt){ const pt = svg.createSVGPoint(); pt.x=(evt.touches&&evt.touches[0]?evt.touches[0].clientX:evt.clientX); pt.y=(evt.touches&&evt.touches[0]?evt.touches[0].clientY:evt.clientY); return pt.matrixTransform(svg.getScreenCTM().inverse()); }
  let dragging=false;
  function onPointerDown(e){ e.preventDefault(); dragging=true; try{handle.setPointerCapture(e.pointerId);}catch(_){ } onPointerMove(e); }
  function onPointerMove(e){
    if(!dragging) return; e.preventDefault();
    const sp = svgPoint(e);
    const px = miniClamp(sp.x, pad.left, pad.left+plotW);
    const r  = pxToR(px);

    const yCursor = Math.max(pad.top, Math.min(pad.top+plotH, sp.y));
    const yCurve  = curveYPxAtRatio(r, local.mode);
    const willSnap = Math.abs(yCursor - yCurve) <= SNAP_PX;
    if (willSnap && !isSnapped && typeof window.hapticBump === 'function') window.hapticBump();
    isSnapped = willSnap;

    // vary C to follow r = S/C, keep within bounds
    let S = miniClamp(local.S, MINI_EPS, MINI_MAX);
    let C = S / r;
    if (C <= MINI_EPS || C > MINI_MAX){
      C = miniClamp(local.C, MINI_EPS, MINI_MAX);
      S = r * C;
      if (S <= MINI_EPS || S > MINI_MAX){
        S = miniClamp(S, MINI_EPS, MINI_MAX);
        C = miniClamp(S / r, MINI_EPS, MINI_MAX);
      }
    }
    local.S=S; local.C=C;

    // update user Y from pointer (snap to curve if close)
    const yr = yRange(local.mode);
    let yPix = Math.min(pad.top+plotH, Math.max(pad.top, sp.y));
    if (willSnap) yPix = yCurve;
    const frac = 1 - (yPix - pad.top) / plotH;
    const logY = Math.log10(yr.yMin) + frac * (Math.log10(yr.yMax) - Math.log10(yr.yMin));
    const Y = Math.pow(10, logY);
    const X_user = unitToX(Y, local.mode);
    local.X_user = X_user;

    // reflect into mirror inputs
    let valOut = (local.mode==='oneInX') ? X_user : (local.mode==='percent' ? (100/X_user) : (1e6/X_user));
    if (local.mode==='oneInX') { if (valOut < 2) valOut = 2; }
    else if (local.mode==='percent') { if (valOut<=0) valOut=0.000001; if (valOut>=100) valOut=99.999999; }
    else { if (valOut<=0) valOut=0.0001; if (valOut>=1e6) valOut=999999.99; }
    elS.value=String(local.S); elC.value=String(local.C); elV.value=String(valOut);

    draw();
  }
  function onPointerUp(e){ dragging=false; try{handle.releasePointerCapture(e.pointerId);}catch(_){} }

  handle.addEventListener('pointerdown', onPointerDown, {passive:false});
  svg.addEventListener('pointermove', onPointerMove, {passive:false});
  svg.addEventListener('pointerup', onPointerUp, {passive:false});
  svg.addEventListener('touchstart', onPointerDown, {passive:false});
  svg.addEventListener('touchmove', onPointerMove, {passive:false});
  svg.addEventListener('touchend', onPointerUp, {passive:false});

  draw();

  // Bottom buttons
  const btns = document.getElementById('buttons');
  btns.innerHTML = '';
  const yesBtn = document.createElement('button'); yesBtn.type='button'; yesBtn.className='yes'; yesBtn.textContent='Yes';
  yesBtn.onclick = function(){ goToNode(node.yes); };
  const noBtn = document.createElement('button'); noBtn.type='button'; noBtn.className='no'; noBtn.textContent='No';
  noBtn.onclick  = function(){ goToNode(node.no); };
  btns.appendChild(yesBtn); btns.appendChild(noBtn);
}

/* ======= STATE ======= */
var currentThresholdPct = 90;
var miniActGate = false; // If Q6 verdict said "Act should be considered", skip Q16–Q18 later
var hasFlashedIf = false;
var hasFlashedWhen = false;
var lastWasResult = false;
var originalTitleHTML = null;

/* ======= APP LOGIC ======= */
var historyStack = [];
var currentNode = flowchart.find(function(n){ return n.id === "Q0"; });
var currentSegment = "If You Should Act";

function getSegmentForNodeId(id) {
  if (!id || id.charAt(0) !== 'Q') return currentSegment;
  var m = /^Q(\d+)$/.exec(id);
  if (!m) return currentSegment;
  var num = parseInt(m[1], 10);
  return num >= 31 ? "When You Should Act" : "If You Should Act";
}

/* Verdict/custom heading */
function setHeadingText(node) {
  var title = document.getElementById('segmentTitle');
  var skipBtn = document.getElementById('skipBtn');

  if (!node) { title.textContent = ''; skipBtn.style.display='none'; return; }

  if ((node.type === 'about' || node.type === 'aboutMenu') && node.heading) {
    title.textContent = node.heading;
    skipBtn.style.display = 'none';
    return;
  }

  if (node.id === 'Q0') {
    if (originalTitleHTML) title.innerHTML = originalTitleHTML;
    skipBtn.style.display = 'none';
    return;
  }

  if (node.type === 'result') {
    title.textContent = "👍👎 Verdict";
    skipBtn.style.display = 'none';
    return;
  }

  var segText = (currentSegment === "If You Should Act")
    ? "⚖️ If You Should Act"
    : "⏳ When You Should Act";

  title.textContent = segText;
  skipBtn.style.display = (currentSegment === "If You Should Act" && node.type !== 'result')
    ? 'inline-block'
    : 'none';
}

/* Flash heading */
function flashHeadingColor(targetSegment, node) {
  const el = document.getElementById('segmentHeading');
  if (!el) return;
  if (currentNode && currentNode.id === 'Q0') return;

  let cls;
  if (node && node.type === 'result')        cls = 'flash-purple';
  else if (targetSegment === 'If You Should Act') cls = 'flash-green';
  else                                        cls = 'flash-gold';

  // 1500ms total by default: 180 in + 900 hold + 420 out
  flashWithPlateau(el, cls, { inMs: 300, holdMs: 900, outMs: 300 });
}

function getSectionKey(n){
  if (!n) return null;
  if (n.type === 'about')  return 'about';
  if (n.type === 'result') return 'result';
  const s = (n.segmentLabel || n.segment || '').toLowerCase();
  if (s.includes('if'))   return 'if';
  if (s.includes('when')) return 'when';
  return 'other';
}

function maybeFlashOnEnter(node, fromId){
  if (!node || node.id !== 'Q1') return;

  const fromNode    = flowchart.find(n => n.id === fromId);
  const fromSection = getSectionKey(fromNode);

  // Flash Q1 only if arriving from Q0 OR from a non-IF section
  if (fromId === 'Q0' || (fromSection && fromSection !== 'if')) {
    // This label is what your header uses for the IF segment
    flashHeadingColor('If You Should Act', node);
  }
}

/* Reset panels */
function closeAllPanels() {
  collapseSharedPanel();
  var risk = document.getElementById('riskInline');
  if (risk) {
    risk.style.display = 'none';
    risk.setAttribute('aria-hidden','true');
  }
}

/* Auto-skip logic (based on Q6 verdict) */
function beforeEnterNode(nextId) {
  if (miniActGate && (nextId === 'Q16' || nextId === 'Q17' || nextId === 'Q18')) {
    return 'Q22';
  }
  return nextId;
}

/* Navigation helpers */
function makeButton(label, cls, action) {
  var btn = document.createElement('button');
  btn.type = 'button';
  btn.textContent = label;
  btn.className = cls;
  btn.onclick = action;
  return btn;
}
function goToNode(id) {
  closeAllPanels();
  var adjustedId = beforeEnterNode(id);
  noteOrigin(currentNode);
  var fromId = currentNode ? currentNode.id : '';
  var next = flowchart.find(n => n.id === adjustedId);
  historyStack.push(currentNode ? currentNode.id : '');
  currentNode = next; renderNode(currentNode);
  maybeFlashOnEnter(currentNode, fromId);
}
function goBack() {
  closeAllPanels();
  var fromId = currentNode ? currentNode.id : '';
  var prevId = historyStack.pop();

  // 🔹 If AB2 was a temporary concept visit, skip it
  if (prevId === 'AB2' && window.__ab2TempVisit) {
    window.__ab2TempVisit = false; // clear flag
    prevId = historyStack.pop();   // jump one more back
  }

  var prev = flowchart.find(n => n.id === prevId);
  currentNode = prev || currentNode;
  renderNode(currentNode);
  maybeFlashOnEnter(currentNode, fromId);
}
function restart() {
  closeAllPanels();
  historyStack = [];
  currentSegment = "If You Should Act";
  currentNode = flowchart.find(n => n.id === "Q0");
  hasFlashedIf = false;
  hasFlashedWhen = false;
  lastWasResult = false;
  miniActGate = false;
  window.miniPristine = true;
  if (originalTitleHTML) {
    document.getElementById('segmentTitle').innerHTML = originalTitleHTML;
    document.getElementById('skipBtn').style.display = 'none';
  }
  renderNode(currentNode);
}

/* Skip button */
document.getElementById('skipBtn').addEventListener('click', function() {
  closeAllPanels();
  goToNode('Q31');
});

/* Shared panel */
function collapseSharedPanel() {
  var panel = document.getElementById('sharedPanel');
  if (panel) {
    panel.style.display = 'none';
    panel.setAttribute('aria-hidden','true');
    panel.dataset.mode = '';
    panel.innerHTML = '';
  }
  var leftWrap  = document.getElementById('leftControlsWrapper');
  var rightWrap = document.getElementById('rightControlsWrapper');

  if (leftWrap) {
    var exBtns = leftWrap.querySelectorAll('.examples-btn');
    for (var i=0;i<exBtns.length;i++) {
      exBtns[i].textContent = 'Show Examples';
      exBtns[i].setAttribute('aria-expanded','false');
      exBtns[i].classList.remove('active');
    }
  }
  if (rightWrap) {
    var rBtns = rightWrap.querySelectorAll('.viz-btn, .reasoning-btn');
    for (var j=0;j<rBtns.length;j++) {
      var btn = rBtns[j];
      if (btn.classList.contains('viz-btn')) btn.textContent = 'Show Visualization';
      if (btn.classList.contains('reasoning-btn')) btn.textContent = 'Show Percentage Reasoning';
      btn.setAttribute('aria-expanded','false');
      btn.classList.remove('active');
    }
  }
}

/* ======= Shared panel helpers + visuals ======= */
function openSharedPanel(panel, mode) {
  panel.style.display = 'block';
  panel.setAttribute('aria-hidden','false');
  panel.dataset.mode = mode;
}

function renderExamples(panel, qid) {
  var ex = window.examples[qid];
  if (!ex) {
    panel.innerHTML = '<p>No examples available.</p>';
    return;
  }
  var ul = document.createElement('ul');
  for (var i=0;i<ex.length;i++) {
    var li = document.createElement('li');
    li.textContent = ex[i];
    ul.appendChild(li);
  }
  panel.appendChild(ul);
}

function renderViz(panel, src, alt) {
  var img = document.createElement('img');
  img.src = src;
  img.alt = alt;
  panel.appendChild(img);
}

function createTickRow(where, wrap) {
  var tickRow = document.createElement('div');
  tickRow.className = 'tick-row ' + where;
  for (var i=1;i<=10;i++) {
    var tick = document.createElement('div');
    tick.className = 'tick';
    tick.style.left = (i-1) * (100/9) + '%';
    tickRow.appendChild(tick);
  }
  wrap.appendChild(tickRow);
}

function updateSliderFill(slider, sev) {
  const pct = ((sev - 1) / 9) * 100;
  slider.style.setProperty('--pct', pct + '%');

  // nonlinear progression: low severities push color shift faster
  const t = Math.pow((sev - 1) / 9, 0.2); // exponent <1 makes early shift steeper
  const hue = 240 - t * 240; // blue → red
  const color = `hsl(${hue}, 90%, 50%)`;
  slider.style.setProperty('--fill', color);
}

/* ---------- Controls under the text ---------- */
function setupAuxToggles(node) {
  var leftWrap = document.getElementById('leftControlsWrapper');
  var rightWrap = document.getElementById('rightControlsWrapper');
  var panel = document.getElementById('sharedPanel');

  leftWrap.innerHTML = '';
  rightWrap.innerHTML = '';
  collapseSharedPanel();

  // ✅ Show aux controls for questions, and ALSO for Q33 specifically
  var allowAux = (node.type === 'question') || (node.id === 'Q33');
  if (!allowAux) return;

  // LEFT: Examples (always for allowed nodes)
  var examplesBtn = document.createElement('button');
  examplesBtn.type = 'button';
  examplesBtn.textContent = 'Show Examples';
  examplesBtn.className = 'examples-btn ctrl-btn';
  examplesBtn.setAttribute('aria-expanded', 'false');
  leftWrap.appendChild(examplesBtn);

  examplesBtn.onclick = function() {
    var isOpenExamples = panel.style.display === 'block' && panel.dataset.mode === 'examples';
    if (isOpenExamples) {
      collapseSharedPanel();
    } else {
      panel.innerHTML = '';
      renderExamples(panel, node.id);
      openSharedPanel(panel, 'examples');
      examplesBtn.setAttribute('aria-expanded','true');
      examplesBtn.classList.add('active');
    }
  };

  // RIGHT: Only one graph/logic button per applicable slide
  if (node.id === 'Q22' || node.id === 'Q24') {
    var vizBtn = document.createElement('button');
    vizBtn.type = 'button';
    vizBtn.textContent = 'Show Visualization';
    vizBtn.className = 'viz-btn ctrl-btn';
    vizBtn.setAttribute('aria-expanded', 'false');
    rightWrap.appendChild(vizBtn);

    vizBtn.onclick = function() {
      var isOpenViz = panel.style.display === 'block' && panel.dataset.mode === 'viz';
      var src = node.id === 'Q22' ? './diminishing_returns_curve.png' : './inverted_u_curve.png';
      var alt = node.id === 'Q22'
        ? 'Diminishing Returns Curve: Effort/Resources vs Functional Results'
        : 'Inverted-U Curve: Effort/Resources vs Functional Results';
      if (isOpenViz) {
        collapseSharedPanel();
      } else {
        panel.innerHTML = '';
        renderViz(panel, src, alt);

        var link = document.createElement('a');
        link.href = (node.id === 'Q22') 
          ? '#concept-diminishing-returns' 
          : '#concept-inverted-u';
        link.textContent = 'See full explanation and formulas';
        link.style.display = 'inline-block';
        link.style.marginTop = '8px';
        
        link.addEventListener('click', function (e) {
          e.preventDefault();
          const target = (node.id === 'Q22')
            ? 'concept-diminishing-returns'
            : 'concept-inverted-u';
          history.replaceState(null, '', `#${target}`);
          jumpToConcept(target, /* back */ node.id);
        })
        
        panel.appendChild(link);

        openSharedPanel(panel, 'viz');
        vizBtn.setAttribute('aria-expanded','true');
        vizBtn.classList.add('active');
      }
    };
  } else if (node.id === 'Q46' || node.id === 'Q47') {
    var reasonBtn = document.createElement('button');
    reasonBtn.type = 'button';
    reasonBtn.textContent = 'Show Percentage Reasoning';
    reasonBtn.className = 'reasoning-btn ctrl-btn';
    reasonBtn.setAttribute('aria-expanded','false');
    rightWrap.appendChild(reasonBtn);

    reasonBtn.onclick = function() {
      var isOpenReason = panel.style.display === 'block' && panel.dataset.mode === 'reason';
      if (isOpenReason) {
        collapseSharedPanel();
      } else {
        panel.innerHTML = '';
        var p = document.createElement('p');
        p.textContent = 'Your current threshold is ' + currentThresholdPct + '%.';
        panel.appendChild(p);
        var img = document.createElement('img');
        img.src = './linear_threshold_chart.png';
        img.alt = 'Linear Severity to Action Threshold: Threshold = 100% − (Severity × 10%)';
        panel.appendChild(img);
        
        var link = document.createElement('a');
        link.href = '#concept-severity-threshold';
        link.textContent = 'See full explanation';
        link.style.display = 'inline-block';
        link.style.marginTop = '8px';
        link.addEventListener('click', function(e) {
          e.preventDefault();
          const target = 'concept-severity-threshold';
          history.replaceState(null, '', `#${target}`);
          jumpToConcept(target, /* back */ node.id);
        })
        panel.appendChild(link);

        
        openSharedPanel(panel, 'reason');
        reasonBtn.setAttribute('aria-expanded','true');
        reasonBtn.classList.add('active');
      }
    };
  }
}

/* === Dynamic text transforms for Q46 / Q47 (optional) === */
function formatPct(p){ 
  // Keep integers clean, otherwise show up to 1 decimal
  return (Math.round(p) === p ? String(p) : String(Number(p.toFixed(1))));
}

function transformQ46(html){
  // Replace the hardcoded 50% with the live threshold
  var pct = formatPct(currentThresholdPct);
  return html.replace(/nearing or greater than 50%/g, 'nearing or greater than ' + pct + '%');
}

function transformQ47(html){
  // Replace the hardcoded 50% with the live threshold
  var pct = formatPct(currentThresholdPct);
  return html.replace(/nearing or greater than 50%/g, 'nearing or greater than ' + pct + '%');
}

function showOrHideRiskInline(node) {
  var container = document.getElementById('riskInline');
  container.innerHTML = '';
  if (!node || node.id !== 'Q33') {
    container.style.display = 'none';
    container.setAttribute('aria-hidden','true');
    return;
  }
  container.style.display = 'block';
  container.setAttribute('aria-hidden','false');

  var sevDisplay = document.createElement('div');
  sevDisplay.className = 'sev-display';
  sevDisplay.id = 'sevDisplay';
  sevDisplay.textContent = '1';
  container.appendChild(sevDisplay);

  var row = document.createElement('div'); row.className = 'risk-row';

  var wrap = document.createElement('div');
  wrap.className = 'slider-wrap';

  var slider = document.createElement('input');
  slider.type = 'range'; slider.min = '1'; slider.max = '10'; slider.step = '1';
  slider.className = 'heat-slider';
  slider.setAttribute('list','riskTicks');
  slider.value = '1';

  createTickRow('top', wrap);
  wrap.appendChild(slider);
  createTickRow('bottom', wrap);

  row.appendChild(wrap);
  container.appendChild(row);

  var ticks = document.createElement('datalist');
  ticks.id = 'riskTicks';
  for (var i=1;i<=10;i++){ var opt=document.createElement('option'); opt.value=String(i); ticks.appendChild(opt); }
  container.appendChild(ticks);

  function applyFromSeverity(sev) {
    var thr = 100 - sev * 10;
    currentThresholdPct = thr;
    sevDisplay.textContent = String(sev);
    updateSliderFill(slider, sev);

    if (currentNode && (currentNode.id === 'Q46' || currentNode.id === 'Q47')) {
      var textDiv = document.getElementById('text');
      var html = currentNode.text || '';
      html = currentNode.id === 'Q46' ? transformQ46(html) : transformQ47(html);
      textDiv.innerHTML = '<div class="result-text">' + html + '</div>';
    }
  }

  applyFromSeverity(1);

  slider.oninput = function() {
    var sev = parseInt(slider.value, 10);
    applyFromSeverity(sev);
    if (typeof hapticBump === 'function') hapticBump();
  };
}
  
/* ========= Concept deep-link helpers (clean, consolidated) ========= */

// Map Q-ids to concept anchors (used by call sites if you prefer indirection)
var CONCEPT_ANCHOR_BY_QID = {
  Q22: 'concept-diminishing-returns',
  Q24: 'concept-inverted-u',
  Q46: 'concept-severity-threshold',
  Q47: 'concept-severity-threshold',
  Q6: 'concept-prob-sev-cost',
  Q7: 'concept-prob-sev-cost'
};

function assignConceptAnchors() {
  var textDiv = document.getElementById('text');
  if (!textDiv) return;

  function setIdByHeadingContains(phrase, id) {
    var hs = textDiv.querySelectorAll('h2, h3');
    for (var i=0;i<hs.length;i++){
      var h = hs[i];
      if ((h.textContent||'').toLowerCase().includes(phrase.toLowerCase())) {
        h.id = id; return true;
      }
    }
    return false;
  }

  // only (re)assign if missing
  if (!textDiv.querySelector('#concepts-top')) {
    setIdByHeadingContains('IF You Should Act', 'concepts-top');
    setIdByHeadingContains('Diminishing Returns', 'concept-diminishing-returns');
    setIdByHeadingContains('Inverted-U', 'concept-inverted-u');
    setIdByHeadingContains('Severity and Threshold', 'concept-severity-threshold');
    setIdByHeadingContains('Probability vs. Severity vs. Cost', 'concept-prob-sev-cost');
  }
}

// Remember where the user came from (a Q# slide)
let __lastQuestionId = null;
function noteOrigin(node) {
  if (node && node.id && /^Q\d+$/.test(node.id)) __lastQuestionId = node.id;
}

window.addEventListener('error', e => {
  const box = document.getElementById('errorBox') || document.body.appendChild(Object.assign(document.createElement('pre'), {id:'errorBox'}));
  box.style.cssText = 'white-space:pre-wrap;padding:12px;margin:8px;border:1px solid #a00;background:#2b0000;color:#fff';
  box.textContent = 'JS Error: ' + (e.message || e.error || e);
});
window.addEventListener('unhandledrejection', e => {
  const box = document.getElementById('errorBox') || document.body.appendChild(Object.assign(document.createElement('pre'), {id:'errorBox'}));
  box.style.cssText = 'white-space:pre-wrap;padding:12px;margin:8px;border:1px solid #a00;background:#2b0000;color:#fff';
  box.textContent = 'Promise Rejection: ' + (e.reason && (e.reason.message || e.reason)) ;
});
  
function bootGuide() {
  // make sure DOM is present
  const text = document.getElementById('text');
  if (!text) {
    console.warn('DOM not ready for boot; retrying…');
    return setTimeout(bootGuide, 30);
  }

  // flowchart must exist
  if (!Array.isArray(window.flowchart) || !flowchart.length) {
    console.warn('flowchart not ready; retrying…');
    return setTimeout(bootGuide, 30);
  }

  // cache title safely
  const titleEl = document.getElementById('segmentTitle');
  if (titleEl && !window.originalTitleHTML) {
    window.originalTitleHTML = titleEl.innerHTML || '';
  }

  // set starting node & render
  window.currentNode = flowchart.find(n => n.id === 'Q0') || flowchart[0];
  renderNode(window.currentNode);
}

// Run after DOM, or immediately if it’s already ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', bootGuide);
} else {
  bootGuide();
}
  
function safeTypeset(rootEl) {
  try {
    if (window.MathJax && MathJax.typesetPromise && rootEl) {
      return MathJax.typesetPromise([rootEl]).catch(()=>{});
    }
  } catch (_) {}
  return Promise.resolve();
}
  
/* Render node */
if (!originalTitleHTML) {
  originalTitleHTML = document.getElementById('segmentTitle').innerHTML;
}

function renderNode(node) {
  closeAllPanels();
  var errorBox = document.getElementById('errorBox');
  errorBox.textContent = '';

  if (!node) {
    errorBox.textContent = "Error: Could not render step.";
    document.getElementById('text').textContent = '';
    document.getElementById('buttons').innerHTML = '';
    setHeadingText('');
    document.getElementById('backBtn').style.visibility = historyStack.length > 0 ? 'visible' : 'hidden';
    document.getElementById('restartTop').style.display = 'inline-block';
    return;
  }

  var previousSegment = currentSegment;
  var thisSegment = (node.type === 'about' || node.type === 'aboutMenu')
    ? previousSegment
    : getSegmentForNodeId(node.id);

  var comingFromResult = lastWasResult && node.type !== 'result';
  var shouldFlash =
    node.id !== 'Q0' && (
      node.type === 'result' ||
      comingFromResult ||
      thisSegment !== previousSegment ||
      (thisSegment === "If You Should Act" && !hasFlashedIf) ||
      (thisSegment === "When You Should Act" && !hasFlashedWhen)
    );

  if (shouldFlash && !(node.type === 'about' || node.type === 'aboutMenu')) {
    flashHeadingColor(thisSegment, node);
    if (thisSegment === "If You Should Act") hasFlashedIf = true;
    if (thisSegment === "When You Should Act") hasFlashedWhen = true;
  }

  currentSegment = thisSegment;
  setHeadingText(node);
  lastWasResult = (node.type === 'result');

  var textDiv = document.getElementById('text');

  // Theme button + back visibility
  var themeBtn = document.getElementById('themeToggle');
  if (themeBtn) {
    themeBtn.style.display = (node.id === 'Q0') ? 'inline-block' : 'none';
    if (node.id === 'Q0' && window.__refreshThemeButtonLabel) window.__refreshThemeButtonLabel();
  }
  document.getElementById('backBtn').style.visibility = historyStack.length > 0 ? 'visible' : 'hidden';

  // ✅ Custom slides Q6/Q7 are handled here with early returns
  if (node.id === 'Q6') {
    textDiv.innerHTML = '';
    document.getElementById('buttons').innerHTML = '';
    renderMiniQ6(textDiv, node);
    return;
  }
  if (node.id === 'Q7') {
    textDiv.innerHTML = '';
    document.getElementById('buttons').innerHTML = '';
    renderMiniQ7(textDiv, node);
    return;
  }
  
  // Default content
  let html = node.text || '';
  if (node && (node.id === 'Q46' || node.id === 'Q47')) {
    html = (node.id === 'Q46') ? transformQ46(html) : transformQ47(html);
  }
  
  /* ✅ ADD THIS: inject default slide content for all non-special slides */
  document.getElementById('text').innerHTML = html;

  // ==== Q33: remember .heat-slider ====
  if (node && node.id === 'Q33') {
    const q33Root = document.getElementById('text');
    const slider = q33Root.querySelector('.heat-slider');
  
    // Restore generic Q33 fields (if you want)
    const saved = loadNodeState('Q33');
    if (saved) applyFormValues(q33Root, saved);
  
    // Restore dedicated threshold if present
    const stored = getUserThreshold();
    if (slider && stored != null) {
      slider.value = String(stored);
      slider.dispatchEvent(new Event('input',{bubbles:true}));
      slider.dispatchEvent(new Event('change',{bubbles:true}));
    }
  
    // Persist on edit
    const persistQ33 = () => {
      saveNodeState('Q33', collectFormValues(q33Root));
      if (slider) setUserThreshold(slider.value);
    };
    q33Root.addEventListener('input',  persistQ33);
    q33Root.addEventListener('change', persistQ33);
  
    // Ensure it’s saved at least once on entry
    if (slider) setUserThreshold(slider.value);
  }

  // ==== Q46 / Q47: restore threshold from Q33 ====
  if (node && (node.id === 'Q46' || node.id === 'Q47')) {
    const root = document.getElementById('text');
    const stored = getUserThreshold();
  
    // If you want to show the value somewhere in Q46/Q47
    if (stored != null) {
      const out = root.querySelector('.threshold-display');
      if (out) out.textContent = stored;  // or set value on input if you have one
    }
  }

  // 🔹 Inject content, but wrap AB2 so we have an element to target
  if (node && node.id === 'AB2') {
    textDiv.innerHTML = `<section id="AB2" class="about-wrapper">${html}</section>`;
  
    const ab2El = document.getElementById('AB2');
    assignConceptAnchors();
  
    // Typeset equations safely without breaking rendering
    try {
      if (window.MathJax && typeof MathJax.typesetPromise === 'function') {
        if (typeof MathJax.typesetClear === 'function') MathJax.typesetClear();
        MathJax.typesetPromise([ab2El]).catch(() => {});
      }
    } catch (err) {
      console.warn('MathJax typeset skipped:', err);
    }
  
    // Decide what to scroll to:
    let targetId = null;
    let backQId  = null;
  
    if (window.__pendingConceptScroll && window.__pendingConceptScroll.conceptId) {
      targetId = window.__pendingConceptScroll.conceptId;
      backQId  = window.__pendingConceptScroll.backQId || __lastQuestionId || 'Q0';
      window.__pendingConceptScroll = null;
    } else {
      const hash = (location.hash || '').trim();
      if (hash.length > 1) {
        targetId = hash.slice(1);
        backQId  = __lastQuestionId || 'Q0';
      }
    }
  
    if (targetId) {
      window.__backTargetForAB2 = backQId;
      scrollToConcept(targetId, backQId);
    }
  
    // In-page anchor clicks inside AB2
    ab2El.addEventListener('click', function (e) {
      const a = e.target.closest('a[href^="#"]');
      if (!a) return;
      const id = a.getAttribute('href').slice(1);
      if (!id) return;
      e.preventDefault();
      history.replaceState(null, '', `#${id}`);
      scrollToConcept(id, window.__backTargetForAB2 || 'Q0');
    }, { passive: true });
  
    // Aux toggles etc. still need to run
    setupAuxToggles(node);
    showOrHideRiskInline(node);
  
    // Buttons for 'about' stops here
    return;
  }

  setupAuxToggles(node);
  showOrHideRiskInline(node);

  var btns = document.getElementById('buttons');
  btns.innerHTML = '';
  const restartTop = document.getElementById('restartTop');

  if (node.type === 'result') {
    restartTop.style.display = 'none';
    btns.classList.add('center');
    const restartCentered = makeButton('Restart', 'restart', () => restart());
    restartCentered.style.flex = '0 0 auto';
    btns.appendChild(restartCentered);
  } else {
    restartTop.style.display = (node.id === 'Q0') ? 'none' : 'inline-block';
    btns.classList.remove('center');

    if (node.type === 'about') return;
    if (node.type === 'aboutMenu') {
      btns.appendChild(makeButton('About Me', 'next', () => goToNode('AB1')));
      btns.appendChild(makeButton('Guide Concepts Explained', 'next', () => goToNode('AB2')));
      return;
    }

    if (node.type === 'question') {
      const yesBtn = makeButton('Yes', 'yes', () => goToNode(node.yes));
      const noBtn  = makeButton('No',  'no',  () => goToNode(node.no));
      btns.appendChild(yesBtn);
      btns.appendChild(noBtn);
      if (node.same) btns.appendChild(makeButton('Roughly the Same', 'same', () => goToNode(node.same)));
    } else if (node.type === 'info') {
      if (node.id === 'Q0') {
        btns.appendChild(makeButton('Next', 'next', () => goToNode(node.next)));
        btns.appendChild(makeButton('About', 'next', () => goToNode('AB0')));
      } else {
        btns.appendChild(makeButton('Next', 'next', () => goToNode(node.next)));
      }
    }
  }
}

</script>
</body>
</html>
