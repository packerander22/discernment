<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Discernment: A Decision-Making Guide</title>

<!-- üîπ Preload the first-screen logo to avoid pop-in -->
<link rel="preload" as="image" href="./favicon_256_transparent.png">

<link rel="manifest" href="./site.webmanifest?v=4">
<meta name="theme-color" content="#ffffff">
<!-- üîπ Address bar / browser UI color that follows system theme -->
<meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#0b0b0d" media="(prefers-color-scheme: dark)">

<!-- Icons -->
<link rel="icon" type="image/svg+xml" href="./favicon_transparent.svg">
<link rel="icon" type="image/png" sizes="16x16" href="./favicon_16_transparent.png">
<link rel="icon" type="image/png" sizes="32x32" href="./favicon_32_transparent.png">
<link rel="icon" type="image/png" sizes="48x48" href="./favicon_48_transparent.png">
<link rel="icon" type="image/png" sizes="64x64" href="./favicon_64_transparent.png">
<link rel="icon" type="image/png" sizes="192x192" href="./favicon_192_transparent.png">
<link rel="icon" type="image/png" sizes="256x256" href="./favicon_256_transparent.png">
<link rel="icon" type="image/png" sizes="384x384" href="./favicon_384_transparent.png">
<link rel="icon" type="image/png" sizes="512x512" href="./favicon_512_transparent.png">
<link rel="shortcut icon" href="./favicon_transparent.ico">

<!-- iOS homescreen -->
<link rel="apple-touch-icon" sizes="180x180" href="./favicon_180_transparent.png">

<script>
  
  window.MathJax = {
    tex: {inlineMath: [['\\(','\\)']]},
    options: {skipHtmlTags: ['script','noscript','style','textarea','pre','code']}
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

<style>
  :root {
    --btn-pad-y:10px; --btn-pad-x:12px;
    --flash-dur: 1500ms;           

    
    --track-height: 8px;
    --thumb-size: 28px;
    --thumb-shadow: 0 1px 3px rgba(0,0,0,.25);
    --track-bg: #e0e0e0;
    --fill: #2d6cdf;
    --pct: 0%;
    --tick-color: rgba(0,0,0,.35);
    --tick-thickness: 2px;
    --tick-length: 6px;
  }

  body { font-family: Arial, sans-serif; background:#f7f7f7; margin:0; padding:0; }
  .container { max-width: 650px; margin:auto; padding:20px; }
  .top-bar { display:flex; justify-content:space-between; margin-bottom:10px; }
  .card {
    background:#fff; padding:20px; border-radius:8px;
    box-shadow:0 2px 6px rgba(0,0,0,0.1); min-height:280px;
    display:flex; flex-direction:column; justify-content:space-between;
  }

  
  .segment-heading {
    display:flex; align-items:center; justify-content:space-between;
    font-size:1.8em; font-weight:bold; margin-bottom:15px; padding:8px;
    border-bottom:2px solid #ddd; gap:12px; transition: color var(--flash-dur) cubic-bezier(.4,0,.6,1);
  }
  .segment-title { display:inline-flex; align-items:center; gap:8px; }
  .segment-title img.logo {
    height:1.2em; width:auto; vertical-align:middle; margin-right:6px;
    aspect-ratio: 1 / 1;
  }
  .flash-green  { color: var(--flash-green); }
  .flash-gold   { color: var(--flash-gold); }
  .flash-purple { color: var(--flash-purple); }

  
  .about-wrapper h1,
  .about-wrapper h2,
  .about-wrapper h3 {
    transition: color var(--flash-dur) cubic-bezier(.4,0,.6,1);
  }

  
  button { flex:1; padding:var(--btn-pad-y) var(--btn-pad-x); font-size:1em; border:none; border-radius:5px; cursor:pointer; }
  button.yes { background:#4CAF50; color:#fff; }
  button.no { background:#F44336; color:#fff; }
  button.same { background:#1E88E5; color:#fff; }
  button.next { background:#2196F3; color:#fff; }
  button.back { background:#555; color:#fff; flex:0 0 auto; }
  button.restart { background:#9C27B0; color:#fff; flex:0 0 auto; }
  button.examples-btn, button.viz-btn, button.reasoning-btn { background:#9E9E9E; color:#fff; }
  .ctrl-btn { flex:1; }
  button.active { outline:2px solid #000; }
  
  button.next:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .segment-heading .skip-btn {
    display:inline-flex; align-items:center; justify-content:center;
    flex:0 0 auto; padding:var(--btn-pad-y) var(--btn-pad-x);
    font-size:1rem; line-height:1; border:none; border-radius:5px; cursor:pointer;
    background:#e9e9e9; color:#333;
  }
  .segment-heading .skip-btn:hover { background:#dedede; }

  .text { font-size:1.3em; margin-bottom:12px; white-space:pre-wrap; }

  .controls-row { display:flex; gap:10px; margin:6px 0 18px 0; }
  .left-controls, .right-controls { flex:1; display:flex; gap:10px; }

  .panel {
    display:none; border:1px solid #eee; border-radius:6px; padding:10px; background:#fafafa;
    margin-bottom:18px;
  }
  .panel p { margin:6px 0; }
  .panel img { width:100%; height:auto; display:block; }

  .buttons { display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-start; }
  .buttons.center { justify-content:center; }

  
  .risk-inline { display:none; border:1px solid #eee; border-radius:6px; padding:12px; background:#fafafa; margin:8px 0 18px 0; }
  .sev-display { text-align:center; font-size:1.8em; font-weight:bold; margin-bottom:8px; }
  .risk-row { display:flex; align-items:center; gap:10px; margin:0; }
  .risk-row input[type="range"] { width:100%; }
  .risk-ticks { display:block; width:100%; }

  .error { color:#B00020; font-size:0.95em; }

  
  .slider-wrap {
    position: relative;
    width: 100%;
    height: calc(var(--thumb-size) + var(--tick-length) * 2 + 8px);
    display: flex;
    align-items: center;
    justify-content: center;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    touch-action: pan-x;
  }
  
  
  .heat-slider{
    --fill: #3b82f6;            
    --track-bg: #e5e7eb;        
    --track-height: 8px;
    --thumb-size: 22px;
    --thumb-shadow: 0 1px 2px rgba(0,0,0,.2);
    --tick-length: 8px;
    --tick-thickness: 2px;
    --tick-color: #cbd5e1;
  }
  
  .heat-slider {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: var(--thumb-size);
    background: transparent;
    position: relative;
    z-index: 1;
  }
  .heat-slider::-webkit-slider-runnable-track {
    height: var(--track-height);
    border-radius: calc(var(--track-height) / 2);
    background:
      linear-gradient(to right,
        var(--fill) 0%,
        var(--fill) var(--pct),
        var(--track-bg) var(--pct),
        var(--track-bg) 100%);
  }
  .heat-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: var(--thumb-size);
    height: var(--thumb-size);
    border-radius: 50%;
    background: #fff;
    border: 2px solid #999;
    box-shadow: var(--thumb-shadow);
    margin-top: calc((var(--thumb-size) - var(--track-height)) / -2);
    cursor: pointer;
  }

  .tick-row {
    position: absolute;
    left: calc(var(--thumb-size) / 2);
    right: calc(var(--thumb-size) / 2);
    height: var(--tick-length);
    pointer-events: none;
    z-index: 0;
  }
  .tick-row.top { top: 50%; transform: translateY(calc(-50% - var(--track-height)/2 - 2px)); }
  .tick-row.bottom { top: 50%; transform: translateY(calc(-50% + var(--track-height)/2 + 2px)); }
  .tick { position: absolute; width: var(--tick-thickness); height: 100%; background: var(--tick-color); transform: translateX(-50%); }

  .heat-slider::-moz-range-track { height: var(--track-height); border-radius: calc(var(--track-height) / 2); background: var(--track-bg); }
  .heat-slider::-moz-range-progress { height: var(--track-height); border-radius: calc(var(--track-height) / 2); background: var(--fill); }
  .heat-slider::-moz-range-thumb { width: var(--thumb-size); height: var(--thumb-size); border-radius: 50%; background: #fff; border: 2px solid #999; box-shadow: var(--thumb-shadow); cursor: pointer; }
  .heat-slider::-ms-track { height: var(--track-height); border-color: transparent; color: transparent; background: transparent; }
  .heat-slider::-ms-fill-lower { background: var(--fill); border-radius: calc(var(--track-height)/2); }
  .heat-slider::-ms-fill-upper { background: var(--track-bg); border-radius: calc(var(--track-height)/2); }
  .heat-slider::-ms-thumb { width: var(--thumb-size); height: var(--thumb-size); border-radius: 50%; background: #fff; border:2px solid #999; box-shadow: var(--thumb-shadow); }

  
  .math {
    font-family: "Times New Roman", "STIX Two Math", "Cambria Math", serif;
    font-style: italic;
    font-size: 1.05em;
    letter-spacing: 0.5px;
    white-space: nowrap;   
    color: var(--text);    
  }
  
  .math sub,
  .math sup {
    font-size: 0.75em;
    font-style: normal;    
    vertical-align: baseline;
    position: relative;
  }
  
  .math sub { bottom: -0.2em; }
  .math sup { top: -0.4em; }
  
  
  @media (prefers-color-scheme: dark) {
    .math {
      color: var(--label-text);  
    }
  }
  
  
  :root[data-theme="dark"] .math {
    color: var(--label-text);
  }
  :root[data-theme="light"] .math {
    color: var(--text);
  }

  
  [id] { scroll-margin-top: 16px; } 

  
  .about-wrapper .concept-back {
    display: inline-block;
    margin: 8px 0 12px 0;
    padding: 8px 12px;
    font: inherit;
    border: none;
    border-radius: 6px;
    color: #fff;
    cursor: pointer;
  }
  .about-wrapper .concept-back:hover { filter: brightness(1.06); }
  .about-wrapper .concept-back:active { filter: brightness(0.96); }
  
  .about-wrapper .concept-back:focus {
    outline: 2px solid rgba(31, 76, 255, .4);
    outline-offset: 2px;
  }
  
  
  .is-disabled { opacity: .55; pointer-events: none; }

  
  :root { color-scheme: light dark; }

  
  :root {
    --bg: #f7f7f7;
    --card: #ffffff;
    --text: #111111;
    --subtle-text: #333333;
    --border: #dddddd;
    --shadow: 0 2px 6px rgba(0,0,0,0.10);

    --btn-yes: #4CAF50;
    --btn-no: #F44336;
    --btn-same: #1E88E5;
    --btn-next: #2196F3;
    --btn-back: #555555;
    --btn-restart: #9C27B0;
    --btn-muted: #9E9E9E;
    --btn-text: #ffffff;

    --thumb-border: #999999;
    --tick-color: rgba(0,0,0,.35);
    --track-bg: #e0e0e0;

    --if-accent: #2e7d32;        
    --when-accent: goldenrod;
    --result-accent: #9C27B0;

    
    --axis-color: #555;
    --axis-color-dim: #777;
    --grid-color: rgba(0,0,0,.12);
    --curve-color: #1f4cff;
    --handle-fill: #ff3b3b;
    --handle-stroke: #ffffff;
    --shade-in: color-mix(in oklab, var(--if-accent), #ffffff 84%);
    --shade-out: rgba(0,0,0,.06);
    --label-bg: #ffffff;
    --label-text: #111111;
  }

  
  @media (prefers-color-scheme: dark) {
    :root {
      --bg: #0f1115;
      --card: #171a21;
      --text: #e9edf1;
      --subtle-text: #c7cbd2;
      --border: #2a2f3a;
      --shadow: 0 2px 6px rgba(0,0,0,0.35);

      --btn-yes: #4CAF50;
      --btn-no: #EF5350;
      --btn-same: #42A5F5;
      --btn-next: #42A5F5;
      --btn-back: #8e8e93;
      --btn-restart: #BA68C8;
      --btn-muted: #6c6f76;
      --btn-text: #ffffff;

      --thumb-border: #b5bcc8;
      --tick-color: rgba(255,255,255,.38);
      --track-bg: #2a2f3a;

      --if-accent: #5bd36a;   
      --when-accent: #f1c24c;
      --result-accent: #c77dff;

      
      --axis-color: #e9edf1;         
      --axis-color-dim: #c7cbd2;
      --grid-color: rgba(255,255,255,.18);
      --curve-color: #8fb3ff;
      --handle-fill: #ff6b6b;
      --handle-stroke: #171a21;
      --shade-in: color-mix(in oklab, var(--if-accent), #000 70%); 
      --shade-out: rgba(255,255,255,.05);
      --label-bg: #0f1115;
      --label-text: #e9edf1;
    }
  }

  
  :root[data-theme="light"] {
    color-scheme: light;
    
    --bg: #f7f7f7; --card:#ffffff; --text:#111111; --subtle-text:#333333; --border:#dddddd; --shadow:0 2px 6px rgba(0,0,0,0.10);
    --btn-yes:#4CAF50; --btn-no:#F44336; --btn-same:#1E88E5; --btn-next:#2196F3; --btn-back:#555; --btn-restart:#9C27B0; --btn-muted:#9E9E9E; --btn-text:#fff;
    --thumb-border:#999; --tick-color:rgba(0,0,0,.35); --track-bg:#e0e0e0;
    --if-accent:#2e7d32; --when-accent:goldenrod; --result-accent:#9C27B0;
    --axis-color:#555; --axis-color-dim:#777; --grid-color:rgba(0,0,0,.12);
    --curve-color:#1f4cff; --handle-fill:#ff3b3b; --handle-stroke:#fff;
    --shade-in: color-mix(in oklab, var(--if-accent), #ffffff 84%);
    --shade-out: rgba(0,0,0,.06);
    --label-bg:#fff; --label-text:#111;
  }
  :root[data-theme="dark"]  {
    color-scheme: dark;
    --bg:#0f1115; --card:#171a21; --text:#e9edf1; --subtle-text:#c7cbd2;
    --border:#2a2f3a; --shadow:0 2px 6px rgba(0,0,0,0.35);
    --btn-yes:#4CAF50; --btn-no:#EF5350; --btn-same:#42A5F5; --btn-next:#42A5F5;
    --btn-back:#8e8e93; --btn-restart:#BA68C8; --btn-muted:#6c6f76; --btn-text:#fff;
    --thumb-border:#b5bcc8; --tick-color:rgba(255,255,255,.38); --track-bg:#2a2f3a;
    --if-accent:#5bd36a; --when-accent:#f1c24c; --result-accent:#c77dff;

    --axis-color:#e9edf1; --axis-color-dim:#c7cbd2; --grid-color:rgba(255,255,255,.18);
    --curve-color:#8fb3ff; --handle-fill:#ff6b6b; --handle-stroke:#171a21;
    --shade-in: color-mix(in oklab, var(--if-accent), #000 70%);
    --shade-out: rgba(255,255,255,.05);
    --label-bg:#0f1115; --label-text:#e9edf1;
  }

  
  body { background: var(--bg); color: var(--text); }
  .card { background: var(--card); color: var(--text); box-shadow: var(--shadow); border: 1px solid var(--border); }
  .segment-heading { border-bottom: 2px solid var(--border); }
  .flash-gold  { color: var(--when-accent) !important; }
  .flash-green { color: var(--if-accent) !important; }
  .flash-purple{ color: var(--result-accent) !important; }

  .panel { background: color-mix(in oklab, var(--card), var(--bg) 8%); border:1px solid var(--border); }
  .risk-inline { background: color-mix(in oklab, var(--card), var(--bg) 8%); border:1px solid var(--border); }
  .tick { background: var(--tick-color); }
  .heat-slider::-webkit-slider-thumb { border: 2px solid var(--thumb-border); }
  .heat-slider::-moz-range-thumb { border: 2px solid var(--thumb-border); }
  .heat-slider::-ms-thumb { border: 2px solid var(--thumb-border); }

  .segment-heading .skip-btn {
    background: color-mix(in oklab, var(--card), var(--text) 12%);
    color: var(--subtle-text);
  }
  .segment-heading .skip-btn:hover {
    background: color-mix(in oklab, var(--card), var(--text) 20%);
  }

  
  button { color: var(--btn-text); }
  button.yes      { background: var(--btn-yes); }
  button.no       { background: var(--btn-no); }
  button.same     { background: var(--btn-same); }
  button.next     { background: var(--btn-next); }
  button.back     { background: var(--btn-back); }
  button.restart  { background: var(--btn-restart); }
  button.examples-btn, button.viz-btn, button.reasoning-btn { background: var(--btn-muted); }

  
  .graph-axis text { font-size: 14px; font-weight: 600; fill: var(--axis-color); }
  .graph-axis .dim  { fill: var(--axis-color-dim); }
  .graph-grid line  { stroke: var(--grid-color); stroke-width: 1; }
  .graph-curve      { fill:none; stroke: var(--curve-color); stroke-width: 2.5; }
  .graph-handle     { fill: var(--handle-fill); stroke: var(--handle-stroke); stroke-width: 2; cursor: pointer; touch-action:none; }
  .graph-shade-in   { fill: var(--if-accent); fill-opacity: .18; }  
  .graph-shade-out  { fill: var(--shade-out); }

  .ptlabel    { font-size: 16px; font-weight: 700; fill: var(--label-text); pointer-events:none; }
  .ptlabel-bg { fill: var(--label-bg); fill-opacity:.98; stroke: var(--border); rx:10; ry:10; }
  
  
  .rule    { font-weight:700; margin-top:14px; }
  .verdict { margin-top:12px; font-weight:700; }  
  .verdict.ok { color: var(--if-accent); }
  .verdict.no { color: var(--subtle-text); }

  
  .mini-lead { margin-bottom: 10px; }
  .mini-wrap { display:block; border:1px solid var(--border); border-radius:8px; background: color-mix(in oklab, var(--card), var(--bg) 6%); padding:12px; margin:10px 0 16px; overflow: visible; }
  .mini-wrap > a{font-size:.95rem;text-decoration:underline;color:var(--curve-color);margin-top:8px;display:inline-block}
  .mini-fields { display: grid; grid-template-columns: 1fr; gap: 12px; }
  @media (min-width: 560px){ .mini-fields { grid-template-columns: 1fr 1fr; } }
  .mini-field { display:flex; flex-direction:column; gap:6px; }
  .mini-field input[type="number"], .mini-field select{
    padding:10px 12px; border:1px solid var(--border); border-radius:10px; background:var(--card); color:var(--text); width: 100%; box-sizing: border-box;
  }
  
  .mini-muted { opacity:.65; }
  .verdict.ok { color: var(--if-accent); }
  .verdict.no { color: var(--subtle-text); }
  
  
  .mini-svg{width:100%;height:auto;display:block;touch-action:none;overflow:visible}
  .mini-axis line{stroke: var(--grid-color);stroke-width: 1;opacity: .35}
  .mini-axis text{font-size:14px; fill: var(--text); opacity:0.85; font-weight:600}
  .mini-curve{fill:none;stroke:#1f4cff;stroke-width:2.5}
  @media (prefers-color-scheme: dark) {
    .mini-curve{stroke:#7ea3ff}
  }
  .mini-shade-in{fill:color-mix(in oklab, var(--if-accent), transparent 80%)}
  .mini-shade-out{fill:transparent}
  .mini-handle{fill:#ff3b3b;stroke:#fff;stroke-width:2;cursor:pointer;touch-action:none}
  .mini-ptlabel{font-size:16px;font-weight:800;pointer-events:none; fill: var(--text); }
  .mini-ptlabel-bg{fill:var(--card);fill-opacity:.98;stroke:var(--border)}
  .mini-axes-label{font-weight:800; font-size:16px; fill: var(--text); opacity:.9}
  

.mini-field input[disabled],
.mini-field select[disabled]{
  opacity: 1;
  background: var(--card);
  color: var(--text);
  border-color: var(--border);
  cursor: not-allowed;
}
</style>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VJSYRKHSRM"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-VJSYRKHSRM');
</script>

<style id="mini-fix-css">
  
  .mini-wrap { width:100%; max-width:100%; overflow-x:hidden; overflow-y:visible; }
  
  .mini-wrap .mini-fields,
  .mini-wrap .fields { display:grid; grid-template-columns: 1fr !important; gap:14px; }
  .mini-wrap .mini-field input,
  .mini-wrap .mini-field select,
  .mini-wrap .mini-field textarea { width:100% !important; max-width:100% !important; box-sizing:border-box; }
  
  .mini-wrap svg { width:100%; max-width:100%; height:auto; }
  
  .mini-field label { font-size: 0.95rem; line-height: 1.35; }
  .mini-field label input[type="checkbox"]{ vertical-align: middle; margin-right: .5rem; }
</style>

<style id="mini-fix-css-ovr">
  #q6-entry, #q7-entry { max-width:100%; overflow-x:hidden; }
  .tile, .content, .mini-wrap, #q6-entry, #q7-entry { box-sizing:border-box; }
</style>

<style id="mini-sep-base">
  .mini-sep{
    border-top: 2px solid var(--border);
    opacity: .9;
    margin: 8px 0 0; 
  }
</style>

<!-- Mobile focus ring (prevents clipping & iOS zoom) -->
<style id="q6-mobile-focus-visible">
  @media (max-width: 560px){
    .mini-wrap, .mini-field { overflow: visible !important; }

    .mini-field input,
    .mini-field select,
    .mini-field textarea{
      font-size: 16px !important;     
      border-radius: 10px;
      outline: 0 !important;
      box-shadow: 0 0 0 1px var(--border) inset !important;
    }
    .mini-field input:focus,
    .mini-field select:focus,
    .mini-field textarea:focus,
    .mini-field input:focus-visible,
    .mini-field select:focus-visible,
    .mini-field textarea:focus-visible{
      box-shadow:
        0 0 0 3px rgba(31,76,255,.35) inset,
        0 0 0 1px rgba(31,76,255,.70) inset !important;
    }
  }
</style>

<style>
  
  .mini-wrap, #q6-entry, #q7-entry { width: 100%; }
  #q6-entry, #q7-entry {
    display: grid;
    grid-template-columns: 1fr;
    gap: 14px;
    max-width: none;  
  }
  #q6-entry .mini-heading, #q7-entry .mini-heading {
    font-weight: 700;
    font-size: 1.5rem;
  }
  #q6-entry label, #q7-entry label {
    font-size: 0.95rem;
    font-weight: 400;
  }
  #q6-entry .mini-field input, #q6-entry .mini-field select,
  #q7-entry .mini-field input, #q7-entry .mini-field select {
    width: 100%;
    max-width: none;
  }
  #q7-entry input, #q7-entry select, #q7-entry button,
  #q7-entry .hint { opacity: .6; pointer-events: none; }
  #q6-entry .muted { opacity: .6; }
  .mini-spacer { height: 6px; }
</style>
  
</head>
<body>
<div class="container">
  <div class="top-bar">
    <button class="back" id="backBtn" onclick="goBack()" type="button">Back</button>
    <!-- üîπ Theme toggle -->
    <button class="back" id="themeToggle" type="button" style="display:none;">Theme</button>
    <button class="restart" id="restartTop" onclick="restart()" type="button">Restart</button>
  </div>

  <div class="card">
    <div id="segmentHeading" class="segment-heading">
      <span id="segmentTitle" class="segment-title">
        <img
          src="./favicon_256_transparent.png"
          alt="Discernment Logo"
          class="logo"
          width="256"
          height="256"
          loading="eager"
          fetchpriority="high"
          decoding="sync"
        >
        Discernment: A Decision-Making Guide
      </span>
      <button id="skipBtn" class="skip-btn" style="display:none;" title="Skip to When You Should Act" type="button">Skip ‚è≠</button>
    </div>

    <div>
      <div id="text" class="text"></div>

      <div class="controls-row">
        <div id="leftControlsWrapper" class="left-controls"></div>
        <div id="rightControlsWrapper" class="right-controls"></div>
      </div>

      <!-- Shared panel for examples, viz, reasoning -->
      <div id="sharedPanel" class="panel" aria-hidden="true" role="region" aria-live="polite"></div>
      <!-- Inline risk UI -->
      <div id="riskInline" class="risk-inline" aria-hidden="true"></div>
      <div id="errorBox" class="error" role="alert" aria-live="assertive"></div>
    </div>

    <div id="buttons" class="buttons"></div>
  </div>
</div>

<script>

(function initTheme(){
  const root = document.documentElement;
  const themeBtn = document.getElementById('themeToggle');
  const mqDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)');

  let metaTheme = document.querySelector('meta[name="theme-color"]:not([media])');
  if (!metaTheme) {
    metaTheme = document.createElement('meta');
    metaTheme.name = 'theme-color';
    document.head.appendChild(metaTheme);
  }

  function getSetting() {
    const saved = localStorage.getItem('theme');
    return (saved === 'light' || saved === 'dark' || saved === 'system') ? saved : 'system';
  }
  function getEffectiveTheme(setting) {
    if (setting === 'dark') return 'dark';
    if (setting === 'light') return 'light';
    return (mqDark && mqDark.matches) ? 'dark' : 'light';
  }
  function setThemeColor(effective) {
    metaTheme.setAttribute('content', effective === 'dark' ? '#0b0b0d' : '#ffffff');
  }
  function setButtonLabel() {
    if (!themeBtn) return;
    const setting = getSetting();
    const effective = getEffectiveTheme(setting);
    themeBtn.textContent = 'Theme: ' + (setting.charAt(0).toUpperCase() + setting.slice(1));
    themeBtn.title = 'Effective: ' + (effective === 'dark' ? 'Dark' : 'Light');
  }
  function applySetting(setting) {
    if (setting === 'system') {
      root.removeAttribute('data-theme');
      localStorage.setItem('theme', 'system');
    } else {
      root.dataset.theme = setting;
      localStorage.setItem('theme', setting);
    }
    const effective = getEffectiveTheme(setting);
    setThemeColor(effective);
    setButtonLabel();
  }

  applySetting(getSetting());

  if (themeBtn) {
    themeBtn.onclick = function(){
      const setting = getSetting();
      const next = (setting === 'system') ? 'dark' :
                   (setting === 'dark')   ? 'light' : 'system';
      applySetting(next);
    };
  }

  if (mqDark) {
    mqDark.addEventListener('change', () => {
      if (getSetting() === 'system') {
        setButtonLabel();
        setThemeColor(getEffectiveTheme('system'));
      }
    });
  }
  window.__refreshThemeButtonLabel = setButtonLabel;
})();

var flowchart = [
  { "id": "Q0",  "type": "info", "text": "Welcome! This guide helps you determine both <b>IF</b> and <b>WHEN</b> you should act on an issue. This will help to avoid wasting resources and time, and getting stuck in <i>analysis paralysis</i>.\nYou‚Äôll answer simple Yes/No questions (or enter numbers). Answer everything to the best of your knowledge; if you don't know something, do your best to find out if it's worth it.\nAlways consult this guide if the benefit/severity of a given scenario outweighs the actual effort of doing so before acting. For more trivial matters, recall this guide as best you can from memory, and use your best judgment.", "next": "Q1" },
  
  { "id": "Q1",  "type": "question", "text": "Are there any other more important things to do or think about right now?", "yes": "R1",  "no": "Q2" },
  { "id": "Q2",  "type": "question", "text": "Is there a <i>current</i> <b>real problem</b>, rather than just a ‚Äúproblem‚Äù that doesn‚Äôt affect performance or outcomes?", "yes": "Q10",  "no": "Q2b" },
  { "id": "Q2b",  "type": "question", "text": "Is there a desired <i>QoL (quality of life) improvement</i>, rather than just a preference that doesn‚Äôt affect performance or outcomes?", "yes": "Q5",  "no": "Q3" },
  { "id": "Q3",  "type": "question", "text": "Is there cause for a <i>future</i> potential <b>real problem</b>, rather than just a ‚Äúproblem‚Äù that doesn‚Äôt affect performance or outcomes?", "yes": "Q5b",  "no": "Q4" },
  { "id": "Q4",  "type": "question", "text": "Is there cause for a <i>potential</i> cause for a future <i>potential</i> <b>real problem</b>, rather than just a ‚Äúproblem‚Äù that doesn‚Äôt affect performance or outcomes?", "yes": "Q5b",  "no": "R2" },

  { "id": "Q5",  "type": "question", "text": "Is this desired QoL improvement <i>inevitable</i> if it's addressed?", "yes": "Q10",  "no": "Q5c" },
  { "id": "Q5b",  "type": "question", "text": "Is this future potential problem <i>inevitable</i> if left unaddressed?", "yes": "Q10",  "no": "Q5c" },
  { "id": "Q5c",  "type": "question", "text": "Are there any potential negative consequences that could arise if <i>not</i> addressed?", "yes": "Q6",  "no": "Q6" },



  
  { "id": "Q6", "type": "mini", "text": "Use the interactive tool below to weigh the estimated <b>Severity</b>, <b>Cost</b>, and <b>Probability</b> of this future potential problem (for just this instance). Enter them into the boxes, and choose the probability measurement unit that applies.", "yes": "Q10", "no": "Q7" },

  
  { "id": "Q7", "type": "miniViz", "text": "Is there a time further down the road that the circumstances in the <i>previous question</i> could change and flip the verdict?\nNote: This slide does not change your original input unless you go back and edit the last slide.", "yes": "R3", "no": "Q21" },
  { "id": "Q10", "type": "question", "text": "Is there a solution (or at least partial solution) to the problem/potential problem even if it‚Äôs currently unavailable (or a means of bringing about the QoL improvement)?", "yes": "Q11",  "no": "R4" },
  { "id": "Q11", "type": "question", "text": "Can this solution or QoL improvement be <i>guaranteed</i> to be fully brought about as a result of <i>your</i> influence?", "yes": "Q14", "no": "Q12" },
  { "id": "Q12", "type": "question", "text": "Do everything in your power first to achieve the desired result, but know that past that it‚Äôs out of your hands, and <i>worrying and obsessing won‚Äôt change anything and is unhealthy</i>. Is there anything further you can do?", "yes": "Q14", "no": "Q13" },
  { "id": "Q13", "type": "question", "text": "Is there an <i>alternative solution</i> that would solve the problem (or improve QoL) in a way that‚Äôs within your control or perhaps even in a <i>better overall way</i>?", "yes": "R5",  "no": "R2" },

  { "id": "Q14", "type": "question", "text": "Does this solution or QoL improvement involve gaining information that would be <i>valuable in the future</i>?", "yes": "Q15", "no": "Q16" },
  { "id": "Q15", "type": "question", "text": "Would the <i>information alone</i> gained from doing this outweigh the downsides it would likely cause to make this happen?", "yes": "Q31", "no": "Q16" },
  
  { "id": "Q16", "type": "question", "text": "Would the expected benefits of addressing this issue outweigh the expected <i>upfront</i> costs/efforts of addressing it (for just this instance)?", "yes": "Q17", "no": "Q20" },
  { "id": "Q17", "type": "question", "text": "Would the expected benefits of addressing this issue outweigh any negative consequences that would likely arise <i>as a result</i> of addressing it (for just this instance)?", "yes": "Q18", "no": "Q20" },
  { "id": "Q18", "type": "question", "text": "Would the overall benefits of addressing this issue outweigh the <i>combined total</i> of both the upfront costs and any resulting downsides (for just this instance)?", "yes": "Q22", "no": "Q20", "same": "Q19" },

  { "id": "Q19", "type": "question", "text": "All things considered, would you <i>rather</i> address it than not?", "yes": "Q22", "no": "Q20" },
  { "id": "Q20", "type": "question", "text": "Is there a time further down the road that the answer to the <i>previous question</i> could be yes?", "yes": "R3", "no": "Q21" },
  { "id": "Q21", "type": "question", "text": "Is there an <i>alternative solution</i> that would solve the problem (or improve QoL) in a way that‚Äôs worth it or perhaps even in a <i>better overall way</i>?", "yes": "R5",  "no": "R2" },
  { "id": "Q22", "type": "question", "text": "Does addressing this issue involve a <i>diminishing returns</i> curve for effort applied?", "yes": "Q23", "no": "Q24" },
  { "id": "Q23", "type": "info",     "text": "Find the <i>point of diminishing returns</i> and stop there. If you tend to get absorbed in an activity, find an efficient alternative approach that solves the problem or improves QoL <b>without the addictive pull</b> and possibly even in a <i>better overall way</i>. Treat this approach as a \"better\", more effective overall solution. If it's unavailable, you may consider the original approach if needed (run the scenario through the guide).", "next": "Q24" },
  { "id": "Q24", "type": "question", "text": "Does addressing this issue directly involve an <i>inverted-U curve</i> for specific effort applied with an unknown <i>objective sweet spot</i> where clear information is available to you?", "yes": "Q25", "no": "Q26" },
  { "id": "Q25", "type": "info",     "text": "Wait until there aren‚Äôt any other more important things to do, then if it‚Äôs worth it to you, find that <i>sweet spot</i>. If not, put in as much effort as you deem worth it.", "next": "Q31" },

  { "id": "Q26", "type": "question", "text": "In practice and given time, would a <i>functional difference</i>‚Äîlike in a blind test compared side by side‚Äîlikely be noticed if the issue was solved/addressed (assuming any potential future problems would occur)?", "yes": "Q27", "no": "R2" },
  { "id": "Q27", "type": "question", "text": "Would solving/addressing this help get rid of/prevent the problem (or improve QoL) in the <i>long term</i>?", "yes": "Q31", "no": "Q28" },
  { "id": "Q28", "type": "question", "text": "Would solving/addressing this help get rid of/prevent the problem (or improve QoL) in the <i>short term</i>?", "yes": "Q29", "no": "R2" },
  { "id": "Q29", "type": "question", "text": "Would it logically worth solving/addressing this <i>EVERY time this situation arises</i>?", "yes": "Q31", "no": "Q29b" },
  { "id": "Q29b", "type": "question", "text": "Would it be worth solving/addressing this in <i>less frequent intervals</i>?\n(If so, do it that way).", "yes": "Q31", "no": "Q29c" },
  { "id": "Q29c", "type": "question", "text": "Is it logically worth solving/addressing this <b>just this time</b> knowing it‚Äôs a <i>temporary</i> solution?", "yes": "Q31", "no": "Q30" },
  { "id": "Q30", "type": "question", "text": "Is there an <i>alternative solution</i> that would solve the problem (or improve QoL), in the long term or perhaps even in a <i>better overall way</i>?", "yes": "R5",  "no": "R2" },
  
  { "id": "Q31", "type": "question", "text": "Does this address a potential <i>future</i> problem?", "yes": "Q32", "no": "Q35" },
  { "id": "Q32", "type": "question", "text": "Does addressing this issue involve <i>preventative maintenance</i>?", "yes": "Q37", "no": "Q35" },

  
  { "id": "Q33", "type": "info",     "text": "Set the estimated catastrophic severity if you waited too long to act. (1-10)", "next": "Q34" },
  { "id": "Q34", "type": "question", "text": "Would there be <i>guaranteed clear telltale signs</i> of future functional failure before it actually happened, with a big enough window of time to address it properly in advance?", "yes": "Q46", "no": "Q47" },

  
  { "id": "Q35", "type": "question", "text": "Is this the <i>most effective solution</i> you know of (that meets the previous criteria), assuming you could do it whenever you wanted?", "yes": "Q39", "no": "Q36" },
  { "id": "Q36", "type": "question", "text": "Have you considered <i>all better solutions</i> you know of?", "yes": "Q39", "no": "R5" },

  { "id": "Q37", "type": "question", "text": "Is this the <i>most effective solution</i> you know of (that meets the previous criteria)?", "yes": "Q33", "no": "Q38" },
  { "id": "Q38", "type": "question", "text": "Have you considered <i>all better solutions</i> you know of?", "yes": "Q33", "no": "R5" },
  { "id": "Q39", "type": "question", "text": "Is this solution <i>currently</i> available?", "yes": "Q40", "no": "Q41" },
  { "id": "Q40", "type": "question", "text": "Is there a <i>better time</i> down the road to solve/address this to <i>maximize value</i>?", "yes": "R8", "no": "R7" },

  { "id": "Q41", "type": "question", "text": "Assuming you waited until it was available, would the expected <i>overall benefits</i> of using this solution now outweigh the expected <i>overall downsides</i> of having to wait?", "yes": "Q44", "no": "Q43", "same": "Q42" },
  { "id": "Q42", "type": "question", "text": "All things considered, would you <i>rather</i> use this solution?", "yes": "Q44", "no": "Q43" },

  { "id": "Q43", "type": "question", "text": "Is there a <i>next best</i> solution you know of?", "yes": "R5",  "no": "R4" },
  { "id": "Q44", "type": "question", "text": "Is there a <i>better time</i> further down the road than when this solution is available to solve/address this to <i>maximize value</i>?", "yes": "R8",  "no": "R6" },

  
  { "id": "Q46", "type": "question", "text": "Normally you should solve/address it as soon as both of the following are true: <ul><li><i>Those telltale signs</i> indicate that failure is approaching.</li><li>The <i>estimated chance of failure</i> is nearing or greater than 50%.</li></ul>\nHowever, is there a <i>better time</i> before or after that time to solve/address this to <i>maximize value</i>?", "yes": "R8", "no": "R9" },
  { "id": "Q47", "type": "question", "text": "Normally you should solve/address it as soon as the <i>estimated chance of failure</i> is nearing or greater than 50%.\nHowever, is there a <i>better time</i> before or after that time to solve/address this to <i>maximize value</i>?", "yes": "R8", "no": "R9" },
  
  { "id": "R1",  "type": "result",   "text": "Worry about this <i>once those things are addressed</i> and the time is right." },
  { "id": "R2",  "type": "result",   "text": "<i>Don‚Äôt worry about it:)</i>" },
  { "id": "R3",  "type": "result",   "text": "If that time ever does come, re-evaluate the issue. Until then, (once there aren't any other more important things to do), consider any other solutions that could work and be worth it, or perhaps even be <i>better overall</i>." },
  { "id": "R4",  "type": "result",   "text": "Wait until there aren‚Äôt any other more important things to do, then if it‚Äôs worth it to you, <i>find a solution or solutions</i>. If not, put in as much effort as you deem worth it." },
  { "id": "R5",  "type": "result",   "text": "Consider any other solutions, from best to worst, if you haven‚Äôt already (run them through the guide)." },
  { "id": "R6",  "type": "result",   "text": "Wait until this solution is available, then solve it once there aren‚Äôt any other more important things to do. Until then, (once there aren't any other more important things to do, and if you'd like), consider any other solutions that could also work and be worth it." },
  { "id": "R7",  "type": "result",   "text": "Address it <i>sooner than later</i>, once there aren‚Äôt any other more important things to do." },
  { "id": "R8",  "type": "result",   "text": "Wait until that better time, then solve/address it once there aren't any other more important things to do. Until then, (once there aren't any other more important things to do, and if you'd like), consider any other solutions that could either also work and be worth it, or‚Äîin the case of preventative maintenance‚Äîmitigate consequences if failure did occur." },
  { "id": "R9",  "type": "result",   "text": "Solve/address it as soon as the criteria from the <i>previous slide</i> (before the question) are met, once there aren‚Äôt any other more important things to do. Until then, (once there aren't any other more important things to do, and if you'd like), consider any solutions that would mitigate consequences if failure did occur." },

  
  { "id": "AB0", "type": "aboutMenu", "heading": "About", "text": "Choose a section to learn more about the guide and its background." },
  { "id": "AB1", "type": "about", "heading": "About Me", "text": "Hi! My name is Packer, I‚Äôm the creator of this guide. I've had OCD for as long as I can remember, and one of the most difficult things for me is knowing whether or not I should worry about or address something, which led me to create this guide over the course of a year and a half‚Äîmolded from many, <i>many</i> mistakes in my actions. I've learned it's not about being content with imperfection, or striving to make everything perfect, but rather about <i>discerning</i> what to do (or not do), and when to do it. This guide aims to help others make decision‚Äîregardless of if they suffer from OCD, anxiety, or not‚Äîas the logic it uses can be applied to all areas of life.\n\nTo contact or support me, I'm reachable at:\npackerander22@gmail.com" },
  { "id":"AB2","type":"about","heading":"Guide Concepts Explained","text":"<p>This guide is built to prevent wasted effort, ‚Äúanalysis paralysis,‚Äù and unhealthy worry, by walking through the two essential questions of decision-making: <b>Should I act?</b> (IF) and <b>When should I act?</b> (WHEN). Along the way, it uses concepts from psychology, economics, and systems thinking. Below is a deep dive into each principle, ordered as they appear in the guide. Where equations appear, they‚Äôre written so a curious, non-technical reader can follow them step-by-step.</p><h2 id='concepts-top'>IF You Should Act</h2><h3 id='concept-real-vs-cosmetic'>1. Real Problems vs. Cosmetic Problems</h3><p>Not every ‚Äúproblem‚Äù is a <i>real</i> problem.</p><ul><li><b>Real problems</b> affect functionality, outcomes, or safety.</li><li><b>Cosmetic or preference problems</b> only affect comfort, appearance, or personal taste.</li></ul><p><b>How it works:</b> By sorting issues into these two categories, you focus only on what actually changes results. Cosmetic issues can be ignored without consequence.</p><h3 id='concept-potential-vs-inevitable'>2. Potential vs. Inevitable Problems</h3><p>A potential problem may or may not happen. An inevitable problem <i>will</i> happen if ignored.</p><ul><li>Example: a frayed charging cable is <i>inevitably</i> going to fail.</li><li>Example: a squeaky door hinge <i>might</i> get worse, but may never actually break.</li></ul><p><b>How it works:</b> If a problem is inevitable, fixing it early prevents larger costs later. Potential problems require more analysis, especially when severity is high.</p><h3 id='concept-costs-benefits'>3. Costs vs. Benefits</h3><p>Every action carries a trade-off:</p><ul><li><b>Upfront costs/efforts:</b> time, money, or energy you spend right now.</li><li><b>Resulting downsides:</b> risks or hassles created by the fix itself.</li><li><b>Combined total:</b> both categories together, compared against what happens if you do nothing.</li></ul><p><b>Simple Rule:</b> Act if doing nothing causes more downside than acting: <i>D<sub>nothing</sub> > (C<sub>upfront</sub> + D<sub>action</sub>)</i>.</p><p><b>Worked Example:</b> If ignoring a car repair will eventually cost $500, while fixing now costs $100 and creates $50 in hassles, then 500 > (100+50) ‚Üí 500 > 150 ‚Üí Act now.</p><h3 id='concept-prob-sev-cost'>4. Probability vs. Severity vs. Cost</h3><p>Use this when the issue is a <i>non-inevitable potential future problem</i>. Even if failure is unlikely, <b>severity</b> matters; and even if it would be severe, the <b>cost of prevention</b> matters.</p><ul><li><b>Low probability + low severity:</b> usually safe to ignore.</li><li><b>Low probability + high severity:</b> often worth preventing (e.g., helmet).</li><li><b>High probability + low severity:</b> acceptable to ignore if prevention costs more than the nuisance.</li><li><b>High probability + high severity:</b> always act.</li></ul><p><b>4.1 The straight-ahead test (expected value):</b> treat probability (P), severity (S, 1‚Äì10), and cost (C, 1‚Äì10). If the expected downside beats the cost, act.</p><div class='mathblock'><math display='block'><mrow><mi>P</mi><mo>√ó</mo><mi>S</mi><mo>></mo><mi>C</mi></mrow></math></div><p><i>Meaning:</i> multiply chance by how bad it would be; if that ‚Äúexpected hit‚Äù is bigger than the cost of preventing it, do it.</p><p><b>4.2 A calibrated, more conservative cutoff (one-in-X scale):</b> For very rare but severe outcomes, people still tend to act. We encode that with a tuned cutoff curve on a log scale of ‚Äú1 in X‚Äù. Let X be the probability denominator (e.g., X=1,000 means 1-in-1,000 chance). Given your <b>S/C</b> ratio (severity divided by cost), the <b>largest</b> X you should accept is:</p><div class='mathblock'><math display='block'><mrow><msub><mi>X</mi><mtext>cutoff</mtext></msub><mo>=</mo><msup><mn>10</mn><mrow><mn>6</mn><mo>‚ãÖ</mo><msup><mrow><mo>(</mo><mfrac><mrow><mfrac><mi>S</mi><mi>C</mi></mfrac><mo>‚àí</mo><mn>1</mn></mrow><mn>9</mn></mfrac><mo>)</mo></mrow><mi>Œ±</mi></msup></mrow></msup></mrow></math></div><p>Here <i>Œ±</i> is a constant chosen so the curve hits intuitive anchor points:</p><div class='mathblock'><math display='block'><mrow><mi>Œ±</mi><mo>=</mo><mfrac><mrow><mi>ln</mi><mo>(</mo><mn>0.5</mn><mo>)</mo></mrow><mrow><mi>ln</mi><mo>(</mo><mfrac><mrow><msqrt><mn>10</mn></msqrt><mo>‚àí</mo><mn>1</mn></mrow><mn>9</mn></mfrac><mo>)</mo></mrow></mfrac><mo>‚âà</mo><mn>0.48606</mn></mrow></math></div><p><i>Sanity checks (what the curve guarantees):</i></p><ul><li><math display='inline'><mrow><mfrac><mi>S</mi><mi>C</mi></mfrac><mo>=</mo><mn>1</mn></mrow></math> ‚áí <math display='inline'><mrow><msub><mi>X</mi><mtext>cutoff</mtext></msub><mo>=</mo><mn>1</mn></mrow></math> (only act if certain).</li><li><math display='inline'><mrow><mfrac><mi>S</mi><mi>C</mi></mfrac><mo>=</mo><mn>10</mn></mrow></math> ‚áí <math display='inline'><mrow><msub><mi>X</mi><mtext>cutoff</mtext></msub><mo>=</mo><msup><mn>10</mn><mn>6</mn></msup></mrow></math> (act even at one-in-a-million).</li><li><math display='inline'><mrow><mfrac><mi>S</mi><mi>C</mi></mfrac><mo>=</mo><msqrt><mn>10</mn></msqrt></mrow></math> ‚áí <math display='inline'><mrow><msub><mi>X</mi><mtext>cutoff</mtext></msub><mo>‚âà</mo><msup><mn>10</mn><mn>3</mn></msup></mrow></math> (act around one-in-a-thousand).</li></ul><p><b>How to use the chart:</b> On the X-axis you‚Äôll see <b>S/C</b> from 1 to 10. On the Y-axis you‚Äôll see the probability written as <b>1 in X</b> on a log scale from 1 to 1,000,000. The blue line is the cutoff <i>X<sub>cutoff</sub></i>. The green region shows where action is justified: for a given <b>S/C</b>, points <i>below</i> the blue line (smaller X ‚áí higher risk) mean ‚Äúact‚Äù, points above mean ‚Äúdon‚Äôt act‚Äù.</p><figure style='margin:8px 0;'><img src='./prob_sev_cost_chart.png' alt='Probability‚ÄìSeverity‚ÄìCost decision boundary: X-axis S/C (1‚Äì10), Y-axis 1 in X (1‚Äì1,000,000), blue cutoff curve, green ‚Äúact‚Äù region below the curve.' style='max-width:100%;height:auto;'/><figcaption style='font-size:.95em;opacity:.85'>Blue curve = calibrated cutoff; green area = ‚Äúact‚Äù.</figcaption></figure><p><b>Worked single-instance example:</b> Suppose there‚Äôs a 1-in-10,000 risk (<i>X</i>=10,000) of a severity 8 outcome (<i>S</i>=8), and prevention costs <i>C</i>=5. Your ratio is <i>S/C</i>=1.6. From the curve, <i>X<sub>cutoff</sub></i> at 1.6 is roughly a few thousand; since 10,000 is <i>above</i> that cutoff (safer than the limit), you would not act. If the cost drops or severity rises, the blue cutoff falls and you cross into the green region.</p><p><b>4.3 Repeated or multiple instances (trips, sessions, days):</b> When the same risk shows up many times, combine the instances instead of judging one in isolation.</p><p><u>Exact combined chance:</u></p><div class='mathblock'><math display='block'><mrow><msub><mi>p</mi><mtext>total</mtext></msub><mo>=</mo><mn>1</mn><mo>‚àí</mo><munder><mo>‚àè</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow></munder><msup><mrow><mo>(</mo><mn>1</mn><mo>‚àí</mo><msub><mi>p</mi><mi>i</mi></msub><mo>)</mo></mrow><msub><mi>n</mi><mi>i</mi></msub></msup></mrow></math></div><p>For small probabilities this is well-approximated by a simple sum:</p><div class='mathblock'><math display='block'><mrow><msub><mi>p</mi><mtext>total</mtext></msub><mo>‚âà</mo><munder><mo>‚àë</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow></munder><mrow><msub><mi>n</mi><mi>i</mi></msub><mo>‚ãÖ</mo><msub><mi>p</mi><mi>i</mi></msub></mrow></mrow></math></div><p><u>Expected-value test across groups:</u></p><div class='mathblock'><math display='block'><mrow><msub><mi>E</mi><mtext>total</mtext></msub><mo>=</mo><munder><mo>‚àë</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow></munder><mrow><msub><mi>n</mi><mi>i</mi></msub><mo>‚ãÖ</mo><msub><mi>p</mi><mi>i</mi></msub><mo>‚ãÖ</mo><msub><mi>S</mi><mi>i</mi></msub></mrow><mo>></mo><mi>C</mi></mrow></math></div><p><i>Interpretation:</i> sum each group‚Äôs ‚Äúchance √ó severity‚Äù, then compare that total to the prevention cost. If it‚Äôs bigger than <i>C</i>, act.</p><p><u>Identical instances shortcut:</u> If all <i>N</i> instances have the same severity <i>S</i> and probability denominator <i>X</i> (so per-instance <i>p</i>=1/<i>X</i>), you can compare an ‚Äúeffective‚Äù denominator to the same blue cutoff by dividing by <i>N</i>:</p><div class='mathblock'><math display='block'><mrow><msub><mi>X</mi><mtext>eff</mtext></msub><mo>=</mo><mfrac><mi>X</mi><mi>N</mi></mfrac><mo>,</mo><mspace width='0.5em'/><msub><mi>X</mi><mtext>eff</mtext></msub><mo>‚â§</mo><msub><mi>X</mi><mtext>cutoff</mtext></msub><mo>(</mo><mfrac><mi>S</mi><mi>C</mi></mfrac><mo>)</mo></mrow></math></div><p><i>Why this works:</i> over <i>N</i> tries, the combined chance is about <i>N/X</i>; smaller denominators mean riskier. Dividing <i>X</i> by <i>N</i> puts the repeated scenario on the same chart.</p><p><b>Worked multi-group example:</b> You‚Äôll play 100 matches. 95 are low-risk at 1-in-1,000,000; 5 are higher-risk at 1-in-100,000. Assume the severe outcome is <i>S</i>=8 and prevention cost is <i>C</i>=5. Expected total impact: <math display='inline'><mrow><mn>95</mn><mo>‚ãÖ</mo><mfrac><mn>1</mn><mn>1,000,000</mn></mfrac><mo>‚ãÖ</mo><mn>8</mn><mo>+</mo><mn>5</mn><mo>‚ãÖ</mo><mfrac><mn>1</mn><mn>100,000</mn></mfrac><mo>‚ãÖ</mo><mn>8</mn><mo>=</mo><mn>0.00476</mn></mrow></math>. Since 0.00476 < 5, prevention is not justified here. If cost dropped to 0.1, or severity rose, the inequality could flip.</p><p><b>4.4 Practical notes:</b> (1) If probabilities aren‚Äôt tiny, use the exact combined formula. (2) If prevention reduces both probability <i>and</i> severity, compute expected downside <i>with</i> and <i>without</i> prevention and compare the improvement to cost. (3) Our scales cap S and C at 10 to keep judgments stable and comparable.</p><h3 id='concept-alternatives'>5. Alternative Solutions</h3><p>The first idea isn‚Äôt always best. Consider simpler fixes, substitutes, or better long-term approaches.</p><p><b>How it works:</b> Surveying alternatives reduces downside and can add unexpected upsides.</p><h3 id='concept-info-value'>6. Information Value</h3><p>Sometimes action is worth it for the <i>learning</i> alone.</p><p><b>How it works:</b> Small experiments reduce uncertainty and improve future choices.</p><h3 id='concept-diminishing-returns'>7. Diminishing Returns</h3><p>Beyond a point, extra effort yields smaller improvements.</p><p><b>Rule of thumb:</b> Stop when marginal benefit < marginal cost.</p><figure style='margin:8px 0;'><img src='./diminishing_returns_curve.png' alt='Diminishing Returns Curve' style='max-width:100%;height:auto;'/></figure><h3 id='concept-inverted-u'>8. Inverted-U Curve (Sweet Spot)</h3><p>Too little or too much effort hurts results; there‚Äôs an objective optimum.</p><p><b>Why invest:</b> You‚Äôre not chasing perfection; you‚Äôre closing in on a measurable optimum, so extra effort to find it is justified.</p><figure style='margin:8px 0;'><img src='./inverted_u_curve.png' alt='Inverted-U Curve' style='max-width:100%;height:auto;'/></figure><h3 id='concept-functional-diff'>9. Functional Difference (Blind Test)</h3><p>Only differences you can actually detect (and that matter for purpose) count.</p><p><b>How it works:</b> If a change isn‚Äôt noticeable in use, it shouldn‚Äôt drive the decision.</p><h3 id='concept-long-vs-short'>10. Long-Term vs. Short-Term Benefits</h3><p>Short-term relief vs. root-cause fixes.</p><p><b>How it works:</b> Temporary fixes are fine for temporary issues; root-cause fixes justify more cost because they stop repeats.</p><h3 id='concept-always-vs-sometimes'>11. Always vs. Sometimes Worth It</h3><p>Some actions are habit-worthy (always worth it); others depend on context.</p><p><b>How it works:</b> Make the universal ones automatic; evaluate the conditional ones each time.</p><h3 id='concept-preventative'>12. Preventative Maintenance</h3><p>Prevent small issues from becoming large failures.</p><p><b>How it works:</b> Small predictable costs now avert large unpredictable costs later.</p><h2 id='when-top'>WHEN You Should Act</h2><h3 id='concept-severity-threshold'>13. Severity and Thresholds</h3><p>Severity is worst-case impact; threshold is your acceptable limit.</p><p><b>Simple Rule:</b> act when severity meets or exceeds your threshold:</p><div class='mathblock'><math display='block'><mrow><mfrac><mi>S</mi><mi>T</mi></mfrac><mo>‚â•</mo><mn>1</mn></mrow></math></div><p><b>Worked Example:</b> If severity = 7.5 and your threshold = 5.0, then 7.5 √∑ 5.0 = 1.5 ‚â• 1 ‚Üí Act now.</p><figure style='margin:8px 0;'><img src='./linear_threshold_chart.png' alt='Linear Severity to Action Threshold' style='max-width:100%;height:auto;'/></figure><h3 id='concept-telltale-signs'>14. Telltale Signs</h3><p>Warnings before failure (e.g., brake squeal, storage warnings) give safe buffer time.</p><p><b>How it works:</b> Use the buffer to plan; ignoring signs risks urgent, expensive fixes.</p><h3 id='concept-timing'>15. Timing and Availability</h3><p>When you act changes value.</p><p><b>How it works:</b> Wait for better conditions or act now to prevent escalation‚Äîwhichever maximizes benefit vs. cost.</p><h3 id='concept-better-later'>16. Better Alternatives Down the Road</h3><p>Sometimes waiting yields a clearly superior option.</p><p><b>How it works:</b> Avoid near-term obsolescence by delaying when a better option is imminent.</p><h2 id='concepts-summary'>Putting It All Together</h2><h3 id='concept-decision-logic'>17. The Decision Logic</h3><p>The guide‚Äôs structure reflects real-world logic:</p><ol><li>Is this a real or inevitable problem?</li><li>Do benefits outweigh costs?</li><li>How do probability, severity, and cost balance out (including repeated instances)?</li><li>Are alternatives better?</li><li>Is the solution functional and noticeable?</li><li>Where‚Äôs the sweet spot for effort?</li><li>Is it a long-term or short-term fix?</li><li>Is it universally worth it, or conditional?</li><li>Should you prevent it early?</li><li>How severe is it compared to your threshold?</li><li>Are there warning signs?</li><li>Is the timing right, or should you wait for a better alternative?</li></ol><p><b>Bottom line:</b> Layering these concepts prevents wasted energy, avoids unhealthy overthinking, and leads to decisions that are rational, balanced, and sustainable.</p>"}
];

window.examples = {
  "Q1":  ["Finish homework due tonight before reorganizing the closet.", "Call the dentist first if you‚Äôre in pain instead of tweaking your workout plan."],
  "Q2":  ["Laptop battery dies quickly during class; you need reliable runtime.", "Your shoe tread is worn and you slip when running on wet pavement."],
  "Q3":  ["Small coolant drip under the car might lead to overheating later.", "Recurring mild chest tightness during runs that‚Äôs trending worse."],
  "Q4":  ["A faint clicking in a hard drive on boot once this month.", "Occasional wobble in a chair leg that‚Äôs starting to loosen."],
  "Q5":  ["Unsealed wood deck will inevitably weather and crack without treatment.", "Frayed charging cable will eventually fail if kept in use."],
  "Q6":  ["Skipping a tetanus booster could mean a serious infection later vs. quick clinic visit now.", "Ignoring a leaky faucet risks mold and higher bills vs. a simple repair."],
  "Q7":  ["Upgrading firmware may mean brief downtime, but stops data corruption.", "Aligning car wheels takes time, but avoids uneven tire wear after."],
  "Q8":  ["Replacing a dangerously cracked phone screen beats cost + setup + short learning curve.", "Booking a medical evaluation now outweighs copay + scheduling hassle."],
  "Q9":  ["Unpatched server is more likely than not to get compromised over months.", "Bald tire is more likely than not to blow out on a highway trip."],
  "Q10": ["There‚Äôs a software update that fixes the crash you‚Äôre seeing.", "A waterproof spray exists to protect your suede shoes."],
  "Q11": ["You can directly set the thermostat schedule yourself.", "You can swap the noisy fan on your PC today."],
  "Q12": ["You can follow up with support once more before waiting.", "You can gather better measurements before concluding it‚Äôs out of your hands."],
  "Q13": ["Use a lint roller daily instead of buying a new couch cover.", "Switch to a simpler training plan that still builds endurance."],
  "Q14": ["Running a small pilot teaches you if the workflow scales.", "Testing two camera angles tells you what boosts watch time."],
  "Q15": ["Doing a small A/B test is worth it just for the learning.", "Exploring a new note system is useful knowledge even if you keep the old one."],
  "Q16": ["Replacing air filter improves HVAC and is cheap/quick.", "Organizing your tool drawer speeds every repair you do."],
  "Q17": ["Changing to ergonomic keyboard helps wrists despite brief adjustment.", "Moving files to a sane folder system beats the re-indexing hassle."],
  "Q18": ["Buying earplugs for sleep beats cost + carrying them + brief adaptation.", "Installing a password manager beats subscription + setup time."],
  "Q19": ["You‚Äôd rather meal-prep Sundays than eat randomly all week.", "You‚Äôd rather patch the jacket now than buy a new one later."],
  "Q20": ["Wait to buy winter tires until temperatures reliably drop.", "Postpone the camera upgrade until your next paid shoot."],
  "Q21": ["Borrow a neighbor‚Äôs specialty tool instead of buying one.", "Use public transit route that‚Äôs nearly as fast and much cheaper."],
  "Q22": ["Editing a video: each extra pass improves less and less.", "Polishing a resume: beyond a few rounds, gains are tiny."],
  "Q24": ["Strength training: too light or too heavy both underperform; there‚Äôs a sweet spot.", "Caffeine: too little or too much is worse than a moderate dose."],
  "Q26": ["Switching to noise-isolating tips yields clearly clearer audio in a blind test.", "Adding under-desk lighting makes reading small labels noticeably easier."],
  "Q27": ["Sealing the driveway prevents cracks for years.", "Setting up automatic cloud backups prevents permanent data loss."],
  "Q28": ["Ice ankle now to reduce swelling even if full recovery takes longer.", "Use a temporary phone battery case for this weekend event."],
  "Q29": ["Wiping counters after each meal is always worth it.", "Running antivirus when a new USB is used is always worth it."],
  "Q30": ["Use pre-cut veggies service instead of spending hours chopping.", "Switch to a simpler CMS that meets needs with fewer headaches."],
  "Q31": ["Replace the washing machine hose before it bursts.", "Get a dental night guard to prevent grinding damage."],
  "Q32": ["Oil changes at the recommended interval.", "Descaling the espresso machine on schedule."],
  "Q33": ["If a brake failure would be catastrophic, set a higher severity; if a sticky cabinet hinge would be minor, set a low severity.", "For data loss on your main work laptop, pick higher severity; for a dead light bulb in a spare room, pick lower severity."],
  "Q34": ["Brake pad sensor squeal gives plenty of warning before rotor damage.", "Battery health app alerts you before the phone shuts off randomly."],
  "Q35": ["This sanding method gives the best finish among what you know.", "This study technique retains more than your alternatives."],
  "Q36": ["You compared spaced-repetition vs. rereading.", "You evaluated vinegar soak vs. descaling solution."],
  "Q37": ["Of all fixes, replacing the gasket stops the leak best.", "Of all methods, this interval plan builds speed most reliably."],
  "Q38": ["You checked if a pro service does it better for less net cost.", "You considered switching brands with better reliability."],
  "Q39": ["The repair kit is in stock today.", "Your mentor is free for a coaching session now."],
  "Q40": ["Booking during off-season lowers cost and stress.", "Doing it after your finals yields better focus."],
  "Q41": ["Waiting 2 weeks for the sale saves enough to justify the delay.", "Holding off until the skilled friend can help beats rushing today."],
  "Q42": ["You‚Äôd rather take the evening class even if self-study is possible now.", "You‚Äôd rather buy once-cry-once than patch a stopgap twice."],
  "Q43": ["Use the library‚Äôs 3D printer while you wait for parts.", "Try a nearby clinic that can see you tomorrow morning."],
  "Q44": ["Do yard work in spring for best results instead of winter now.", "Schedule the upgrade after the current project ships."],
  "Q45": ["Push the long trip until after the car service appointment.", "Delay filming until the new lights arrive next week."],
  "Q46": ["Replace the bike chain when stretch indicator hits the mark and creaks start.", "Service the A/C when airflow drops and pressure readings trend bad."],
  "Q47": ["Replace smoke alarm batteries when failure probability approaches your set threshold.", "Swap the UPS battery when charge-holding dips near your limit."]
};

window.examplesThreshold = {
  "Q46": {
    "0": [
      "Replace safety-critical parts at the first reliable warning‚Äîdon‚Äôt wait for higher odds.",
      "Schedule service immediately if early signs appear and you treat any chance of failure as unacceptable."
    ],
    "90": [
      "Hold until clear warning signs stack up to near-certain failure, then act promptly.",
      "Plan replacement when indicators are overwhelmingly pointing to imminent failure."
    ]
  },
  "Q47": {
    "0": [
      "Change smoke-alarm batteries now if you‚Äôd lose sleep over even a tiny failure risk.",
      "Replace a worn climbing sling immediately if any fraying makes you uneasy."
    ],
    "90": [
      "Wait until the battery barely holds charge, then replace before it dies unpredictably.",
      "Run shoes until cushioning is clearly shot, then swap just before the next big run."
    ]
  }
};

var miniMaster = {
  S: 5,
  C: 1,
  mode: 'percent',
  val: 1,
  X_user: null
};

(function () {
  const nav = (performance.getEntriesByType && performance.getEntriesByType('navigation')[0]);
  const isReload = nav ? (nav.type === 'reload') 
                       : (performance && performance.navigation && performance.navigation.type === 1);
  if (isReload) {
    sessionStorage.removeItem('userThreshold');
    
    delete window.currentThresholdPct;
  }
})();
  

if (typeof window.miniPristine === 'undefined') window.miniPristine = true;
  

var MINI_EPS = 1e-9, MINI_MAX = 10;
var MINI_ALPHA = Math.log(0.5) / Math.log((Math.sqrt(10) - 1) / 9);

function miniClamp(v, lo, hi){ return Math.min(hi, Math.max(lo, v)); }
function miniCeilPlaces(x,p){ var f=Math.pow(10,p); return Math.ceil(x*f)/f; }

function miniNormalizeToX(mode, val){
  if (mode === 'oneInX')   { if (!(val>1)) return null; return val; }
  if (mode === 'percent')  { if (!(val>0 && val<100)) return null; return 100/val; }
  if (mode === 'micromort'){ if (!(val>0 && val<1e6)) return null; return 1e6/val; }
  return null;
}
function weight10(x){
  var xf = parseFloat(x);
  if (!isFinite(xf) || xf <= 0) return 0;
  return Math.pow(10, 6*((xf-1)/9)); // 1‚Üí1, 10‚Üí1,000,000
}

function currentCost(){
  if (window.miniMaster && typeof miniMaster.C === 'number') return miniMaster.C || 1;
  var cEl = document.querySelector('#miniC') || document.querySelector('#q6-cost') || document.querySelector('input[name="cost"]');
  var C = cEl ? parseFloat(cEl.value || '0') : 0;
  return (isFinite(C) && C > 0) ? C : 1;
}

// r = S/C
function miniXcutoff_from_ratio(r){
  var C  = currentCost();
  var rr = parseFloat(r); if (!isFinite(rr)) rr = 1;
  var S  = rr * C;
  var X  = weight10(S) / weight10(C); // Prob C cutoff in 1-in-X
  return (isFinite(X) && X > 0) ? X : 1e6;
}

function miniComputeSCutoffForX(X){
  var C = currentCost();
  var S = C + 1.5 * Math.log10(Math.max(1e-9, X)); // clamp to [1,10]
  if (!isFinite(S)) S = 10;
  if (S < 1) S = 1; if (S > 10) S = 10;
  return S;
}

function miniProbSymbol(mode){ return mode==='percent' ? '%' : (mode==='micromort' ? '¬µm' : 'X'); }
function miniXtoUnit(X,mode){ return mode==='percent' ? (100/X) : (mode==='micromort' ? (1e6/X) : X); }
function unitToX(Y, mode){
  
  if (mode === 'percent')   return 100 / Y;          
  if (mode === 'micromort') return 1e6 / Y;          
  return Y;                                           
}

function flashWithPlateau(el, cls, opts) {
  if (!el) return;

  
  const root = getComputedStyle(document.documentElement);
  const durStr = (root.getPropertyValue('--flash-dur').trim() || '1500ms');
  const totalMs = durStr.endsWith('ms') ? parseFloat(durStr) : parseFloat(durStr) * 1000;

  const inMs   = opts?.inMs  ?? 180;   
  const outMs  = opts?.outMs ?? 420;   
  const holdMs = opts?.holdMs ?? Math.max(0, totalMs - inMs - outMs); 

  
  el.classList.remove('flash-purple','flash-green','flash-gold');

  
  el.style.setProperty('--flash-dur', inMs + 'ms');
  requestAnimationFrame(() => {
    el.classList.add(cls);

    
    setTimeout(() => {
      el.style.setProperty('--flash-dur', '0ms'); 

      
      setTimeout(() => {
        el.style.setProperty('--flash-dur', outMs + 'ms');
        requestAnimationFrame(() => {
          el.classList.remove(cls);

          
          setTimeout(() => {
            el.style.removeProperty('--flash-dur');
          }, outMs + 50);
        });
      }, holdMs);

    }, inMs + 20); 
  });
}
  
function flashAb2Heading(id) {
  const h = document.getElementById(id);
  if (!h) return;

  
  flashWithPlateau(h, 'flash-purple', { inMs: 300, holdMs: 900, outMs: 300 });
}

function formatCShort(c){
  
  if (!isFinite(c)) return String(c);
  if (c >= 1) return Number(c).toFixed(3).replace(/\.?0+$/,'');
  
  return Number(c.toPrecision(4)) + '';
}

function saveNodeState(key, obj){
  try { sessionStorage.setItem('node:'+key, JSON.stringify(obj)); } catch(_) {}
}
function loadNodeState(key){
  try { const raw = sessionStorage.getItem('node:'+key); return raw ? JSON.parse(raw) : null; }
  catch(_) { return null; }
}
function collectFormValues(root){
  const out = {};
  if (!root) return out;
  root.querySelectorAll('input[name], select[name], textarea[name]').forEach(el => {
    if (el.type === 'checkbox') out[el.name] = !!el.checked;
    else if (el.type === 'radio') { if (el.checked) out[el.name] = el.value; }
    else out[el.name] = el.value;
  });
  return out;
}
function applyFormValues(root, vals){
  if (!root || !vals) return;
  Object.keys(vals).forEach(name => {
    root.querySelectorAll(`[name="${CSS.escape(name)}"]`).forEach(el => {
      const v = vals[name];
      if (el.type === 'checkbox') el.checked = !!v;
      else if (el.type === 'radio') el.checked = (el.value === v);
      else el.value = v;
      el.dispatchEvent(new Event('input',  { bubbles:true }));
      el.dispatchEvent(new Event('change', { bubbles:true }));
    });
  });
}
  

window.hapticBump = window.hapticBump || function () {
  try { if (navigator.vibrate) navigator.vibrate(12); } catch (_) {}
};

function trimDeci(val, places = 3) {
  const n = Number(val);
  if (!isFinite(n)) return String(val);
  
  const s = n.toFixed(places);
  return s.indexOf('.') === -1 ? s : s.replace(/\.?0+$/, '');
}

function curveYPxAtRatio(r, mode, pad, plotH, yToPx) {
  const Xc = miniXcutoff_from_ratio(r);
  const yr = (function yRange(m){
    if (m==='percent')   return { yMin: 0.0001, yMax: 100 };
    if (m==='micromort') return { yMin: 1,      yMax: 1e6  };
    return { yMin: 1,     yMax: 1e6  }; 
  })(mode);
  const Yc = miniXtoUnit(Xc, mode);
  return yToPx(Yc, yr.yMin, yr.yMax);
}

function scrollToConcept(targetId, backQId) {
  if (window.__isScrollingConcept) return;
  window.__isScrollingConcept = true;

  const START = performance.now();
  const MAX_MS = 3000;
  const INTERVAL = 120;

  function scrollAndInject() {
    const el = document.getElementById(targetId);
    if (!el) return false;
    el.scrollIntoView({ behavior: 'smooth', block: 'start' });
    ensureConceptBackButton(targetId, backQId);
    flashAb2Heading(targetId); 
    return true;
  }

  if (scrollAndInject()) { window.__isScrollingConcept = false; return; }
  (function tick(){
    if (scrollAndInject()) { window.__isScrollingConcept = false; return; }
    if (performance.now() - START >= MAX_MS) { window.__isScrollingConcept = false; return; }
    setTimeout(tick, INTERVAL);
  })();
}

function ensureConceptBackButton(targetId, backQId) {
  const heading = document.getElementById(targetId);
  if (!heading) return;
  if (heading.dataset.backInjected === '1') return;

  const btn = document.createElement('button');
  btn.type = 'button';
  
  
  btn.className = 'concept-back restart';
  btn.textContent = '‚Üê Back';

  btn.addEventListener('click', (ev) => {
    ev.preventDefault();
    if (typeof goBack === 'function') goBack();
  });

  heading.insertAdjacentElement('afterend', btn);
  heading.dataset.backInjected = '1';
}

function jumpToConcept(conceptId, backQId){
  
  window.__pendingConceptScroll = { conceptId, backQId: backQId || currentNode?.id || 'Q0' };
  
  window.__ab2TempVisit = true;
  
  goToNode('AB2');
}

function renderMiniQ6(intoEl, node){
  if (typeof window.miniPristine === 'undefined') window.miniPristine = true;
  let cont;
  intoEl.innerHTML = '';

  const top = document.createElement('div');
  top.className = 'mini-top';
  top.innerHTML = node.text || '';
  intoEl.appendChild(top);

  const wrap   = document.createElement('div'); wrap.className = 'mini-wrap';
  const fields = document.createElement('div'); fields.className = 'mini-fields';

  const sBox = document.createElement('div'); sBox.className='mini-field';
  sBox.innerHTML = '<label>Severity (S) ‚Äî up to 10</label><input id="miniS" type="number" step="0.01" max="10" placeholder="e.g. 5">';
  const cBox = document.createElement('div'); cBox.className='mini-field';
  cBox.innerHTML = '<label>Cost (C) ‚Äî up to 10</label><input id="miniC" type="number" step="0.01" max="10" placeholder="e.g. 1">';
  fields.appendChild(sBox); fields.appendChild(cBox);

  const pRow = document.createElement('div'); pRow.className='mini-fields';
  const mBox = document.createElement('div'); mBox.className='mini-field';
  mBox.innerHTML =
    '<label>Probability Unit</label>\
     <select id="miniMode" name="q6Units">\
       <option value="percent">Percentage (%)</option>\
       <option value="oneInX">1 in X</option>\
       <option value="micromort">Micromorts</option>\
     </select>';

  const vBox = document.createElement('div'); vBox.className='mini-field';
  // MIN CHANGED: min="1" (was 2)
  vBox.innerHTML =
    '<label id="miniProbLabel">Enter X (for ‚Äú1 in X‚Äù)</label>\
     <input id="miniVal" type="number" min="1" step="1" placeholder="e.g. 1,000">';

  pRow.appendChild(mBox); pRow.appendChild(vBox);
  wrap.appendChild(fields);
  wrap.appendChild(pRow);

  // SVG
  const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.classList.add('mini-svg');
  svg.setAttribute('viewBox','0 0 940 620');
  svg.style.overflow = 'visible';
  svg.style.marginTop = '12px';
  wrap.appendChild(svg);

  // Valuation (actual formula value) ‚Äî under the graph, before the verdict
  const valuationEl = document.createElement('div');
  valuationEl.className = 'rule';
  valuationEl.id = 'miniValuation';
  valuationEl.textContent = 'Valuation Grade: ‚Äî';
  wrap.appendChild(valuationEl);

  // Verdict
  const verdict = document.createElement('div'); verdict.className='verdict'; verdict.id='miniVerdict';
  verdict.textContent = 'Enter values to see if preventative action should be considered.';
  wrap.appendChild(verdict);

  const link = document.createElement('a');
  link.href = '#concept-prob-sev-cost';
  link.textContent = 'See full explanation of Probability √ó Severity √ó Cost';
  link.style.display = 'inline-block';
  link.style.marginTop = '8px';
  link.addEventListener('click', function(e){
    e.preventDefault();
    const target = 'concept-prob-sev-cost';
    history.replaceState(null, '', `#${target}`);
    if (typeof jumpToConcept === 'function') jumpToConcept(target, node.id);
  });
  wrap.appendChild(link);

  intoEl.appendChild(wrap);

  (function ensureDividers(root){
    if (!root) return;
    const names = ['Severity','Cost','Probability'];
    const labels = root.querySelectorAll('.mini-heading, .mini-field > label, label');
    names.forEach(name=>{
      const heading = Array.from(labels).find(l => (l.textContent||'').trim().toLowerCase() === name.toLowerCase());
      if (!heading || !heading.parentElement) return;
      const parent = heading.parentElement;
      const toRemove = [];
      let prev = heading.previousElementSibling;
      while (prev && prev.classList && prev.classList.contains('mini-sep')){
        toRemove.push(prev);
        prev = prev.previousElementSibling;
      }
      if (toRemove.length > 1) toRemove.slice(1).forEach(el=>el.remove());
      if (toRemove.length === 0){
        const sep = document.createElement('div');
        sep.className = 'mini-sep';
        parent.insertBefore(sep, heading);
      }
    });
  })(wrap);

  const elS  = wrap.querySelector('#miniS');
  const elC  = wrap.querySelector('#miniC');
  const elM  = wrap.querySelector('#miniMode');
  const elV  = wrap.querySelector('#miniVal');
  let   labV = wrap.querySelector('#miniProbLabel');

  const q6Root  = intoEl;
  const savedQ6 = loadNodeState('Q6');
  if (savedQ6) applyFormValues(q6Root, savedQ6);

  // math / scales
  function trimDeci(x,n=3){ if (!isFinite(x)) return String(x); const s=Number(x).toFixed(n).replace(/\.?0+$/,''); return s; }
  function yRange(mode){
    if (mode==='percent')   return { yMin: 0.0001, yMax: 100,   ticks:[100,10,1,0.1,0.01,0.001,0.0001], label:"Cutoff Probability (%) (log scale)" };
    if (mode==='micromort') return { yMin: 1,      yMax: 1e6,   ticks:[1e6,1e5,1e4,1e3,100,10,1],        label:"Cutoff Probability (¬µm) (log scale)" };
    return { yMin: 1, yMax: 1e6, ticks:[1,10,100,1e3,1e4,1e5,1e6], label:"Cutoff Probability as '1 in X' (log scale)" };
  }
  function clampYToRange(Y, mode){
    const r = yRange(mode);
    return Math.min(r.yMax, Math.max(r.yMin, Y));
  }
  function labelUnit(mode, X){
    if (mode === 'percent'){
      const pctRaw = 100 / X;
      const pctShown = Math.min(100, pctRaw);
      const prefix   = (pctRaw > 100) ? '‚â•' : '';
      return `%=${prefix}${trimDeci(pctShown,6)}`;
    }
    if (mode === 'micromort'){
      const umRaw = 1e6 / X;
      const umShown = Math.min(1e6, umRaw);
      const prefix  = (umRaw > 1e6) ? '‚â•' : '';
      return `¬µm=${prefix}${trimDeci(umShown,2)}`;
    }
    const Xshown = Math.min(1e6, Math.round(X));
    const prefix = (X > 1e6) ? '‚â•' : '';
    return `X=${prefix}${Xshown.toLocaleString()}`;
  }

  // axes: X = Cost (C)
  const pad = { left:120, right:30, top:34, bottom:96 };
  const W=940, H=620, plotW=W-pad.left-pad.right, plotH=H-pad.top-pad.bottom;
  const cMinView = 0; let cMaxView = 10;

  function niceStep(span, targetTicks = 7){
    if (span <= 0) return 1;
    const raw = span / Math.max(1, targetTicks);
    const p = Math.pow(10, Math.floor(Math.log10(raw)));
    const m = raw / p;
    const n = (m <= 2) ? 2 : (m <= 5) ? 5 : 10;
    return n * p;
  }
  function niceTicks(min, max, targetTicks = 7){
    const step = niceStep(max - min, targetTicks);
    const start = Math.ceil(min / step) * step;
    const ticks = [];
    for (let v = start; v <= max + 1e-9; v += step) ticks.push(Number(v.toFixed(10)));
    if (min === 0 && ticks[0] > 0) ticks.unshift(0);
    return ticks;
  }
  function CtoPx(C){ return pad.left + (C - cMinView) / (cMaxView - cMinView) * plotW; }
  function pxToC(px){ return cMinView + (px - pad.left) / plotW * (cMaxView - cMinView); }
  function yToPx(y,yMin,yMax){
    const yy = Math.min(yMax, Math.max(yMin, y));
    return pad.top + plotH * (1 - (Math.log10(yy)-Math.log10(yMin))/(Math.log10(yMax)-Math.log10(yMin)));
  }

  elM.value = miniMaster.mode;
  function updateProbLabelForMode(mode){
    if (!labV || !elV) return;
    if (mode === 'percent'){
      labV.textContent = 'Enter percentage (%)';
      elV.placeholder = 'e.g. 1';
      elV.removeAttribute('min'); // numeric validator handles bounds; snapInputs clamps
      elV.step = '0.000001';
    } else if (mode === 'oneInX'){
      labV.textContent = 'Enter X (for ‚Äú1 in X‚Äù)';
      elV.placeholder = 'e.g. 1,000';
      elV.min = '1';           // <<< set min 1 for 1-in-X
      elV.step = '1';
    } else {
      labV.textContent = 'Enter micromorts (¬µm)';
      elV.placeholder = 'e.g. 1';
      elV.removeAttribute('min');
      elV.step = '1';
    }
  }
  updateProbLabelForMode(elM ? elM.value : 'oneInX');

  function lockSeverity(val = 10){ elS.value = String(val); elS.disabled = true; elS.classList.add('is-disabled'); }
  function unlockSeverity(){ elS.disabled = false; elS.classList.remove('is-disabled'); }
  function applyUnitsRule(){
    const mode = elM.value;
    if (mode === 'micromort' || mode === 'micromorts') lockSeverity(10); else unlockSeverity();
  }
  applyUnitsRule();
  if (!elM.__boundUpdateProbLabel){
    elM.addEventListener('change', (e)=>{
      updateProbLabelForMode(e.target.value);
      applyUnitsRule();
      window.miniPristine = false;
      draw();
    });
    elM.__boundUpdateProbLabel = true;
  }

  // svg elems
  const axesG  = document.createElementNS('http://www.w3.org/2000/svg','g'); axesG.setAttribute('class','mini-axis'); svg.appendChild(axesG);
  const shadeIn= document.createElementNS('http://www.w3.org/2000/svg','path'); shadeIn.setAttribute('class','mini-shade-in'); svg.appendChild(shadeIn);
  const curve  = document.createElementNS('http://www.w3.org/2000/svg','path'); curve.setAttribute('class','mini-curve'); svg.appendChild(curve);
  const handle = document.createElementNS('http://www.w3.org/2000/svg','circle'); handle.setAttribute('class','mini-handle'); handle.setAttribute('r','12'); svg.appendChild(handle);

  const labelG = document.createElementNS('http://www.w3.org/2000/svg','g'); labelG.style.pointerEvents='none'; svg.appendChild(labelG);
  const labelBg= document.createElementNS('http://www.w3.org/2000/svg','rect'); labelBg.setAttribute('class','mini-ptlabel-bg'); labelBg.setAttribute('rx','10'); labelBg.setAttribute('ry','10'); labelG.appendChild(labelBg);
  const labelTx= document.createElementNS('http://www.w3.org/2000/svg','text'); labelTx.setAttribute('class','mini-ptlabel'); labelG.appendChild(labelTx);

  const xLab = document.createElementNS('http://www.w3.org/2000/svg','text'); xLab.setAttribute('class','mini-axes-label'); xLab.setAttribute('text-anchor','middle'); svg.appendChild(xLab);
  const yLab = document.createElementNS('http://www.w3.org/2000/svg','text'); yLab.setAttribute('class','mini-axes-label'); yLab.setAttribute('text-anchor','middle'); svg.appendChild(yLab);

  // veil overlay for empty state
  const veilG   = document.createElementNS('http://www.w3.org/2000/svg','g'); veilG.setAttribute('class','mini-veil'); svg.appendChild(veilG);
  const veilR   = document.createElementNS('http://www.w3.org/2000/svg','rect');
  veilR.setAttribute('x', pad.left); veilR.setAttribute('y', pad.top);
  veilR.setAttribute('width', plotW); veilR.setAttribute('height', plotH);
  veilR.setAttribute('fill', '#888'); veilR.setAttribute('opacity','0.15');
  veilR.style.pointerEvents = 'none';
  const veilT   = document.createElementNS('http://www.w3.org/2000/svg','text');
  veilT.setAttribute('x', pad.left + plotW/2); veilT.setAttribute('y', pad.top + plotH/2);
  veilT.setAttribute('text-anchor','middle'); veilT.setAttribute('dominant-baseline','middle');
  veilT.setAttribute('fill', '#aaa'); veilT.setAttribute('font-size','18');
  veilT.textContent = 'Enter values above to see the cutoff curve';
  veilG.appendChild(veilR); veilG.appendChild(veilT);

  const SNAP_PX = 22;
  let isSnapped = false;
  let SDragLock = null;

  function drawAxes(mode){
    axesG.innerHTML='';
    niceTicks(cMinView, cMaxView, 7).forEach(t => {
      const x = CtoPx(t);
      const v = document.createElementNS('http://www.w3.org/2000/svg','line');
      v.setAttribute('x1', x); v.setAttribute('x2', x);
      v.setAttribute('y1', pad.top); v.setAttribute('y2', pad.top + plotH);
      axesG.appendChild(v);

      const lab = document.createElementNS('http://www.w3.org/2000/svg','text');
      lab.setAttribute('x', x); lab.setAttribute('y', pad.top + plotH + 16);
      lab.setAttribute('dominant-baseline', 'hanging'); lab.setAttribute('text-anchor', 'middle');
      lab.textContent = (Math.abs(t - Math.round(t)) < 1e-8) ? Math.round(t) : t.toFixed(1).replace(/\.0$/,'');
      axesG.appendChild(lab);
    });

    const range = yRange(mode);
    range.ticks.forEach(yv=>{
      const y = yToPx(yv, range.yMin, range.yMax);
      const h=document.createElementNS('http://www.w3.org/2000/svg','line');
      h.setAttribute('x1',pad.left); h.setAttribute('x2',pad.left+plotW); h.setAttribute('y1',y); h.setAttribute('y2',y);
      axesG.appendChild(h);
      const yt=document.createElementNS('http://www.w3.org/2000/svg','text');
      yt.setAttribute('x', pad.left - 10); yt.setAttribute('y', y);
      yt.setAttribute('text-anchor','end'); yt.setAttribute('dominant-baseline','middle');
      yt.textContent = (mode==='percent' ? (yv>=1?String(yv):yv.toExponential(1)) : yv.toLocaleString());
      axesG.appendChild(yt);
    });

    xLab.setAttribute('x', pad.left+plotW/2); xLab.setAttribute('y', H-10);
    xLab.textContent = 'Cost (C)';

    const Y_LABEL_OFFSET = 90, desiredLeftPadding=8;
    yLab.textContent = yRange(mode).label;
    yLab.setAttribute('text-anchor','middle'); yLab.setAttribute('dominant-baseline','middle');
    const cy = pad.top + plotH/2, cx0 = pad.left - Y_LABEL_OFFSET;
    yLab.setAttribute('transform', `translate(${cx0} ${cy}) rotate(-90)`);
    const bb = yLab.getBBox(); const currentLeft = cx0 - (bb.height/2);
    const dx = Math.max(0, desiredLeftPadding - currentLeft);
    yLab.setAttribute('transform', `translate(${cx0 + dx} ${cy}) rotate(-90)`);
  }

  function buildCurve(mode){
    const range = yRange(mode), N=800;
    const cMinPlot = Math.max(MINI_EPS, cMinView + 1e-6);
    let d='';
    for (let i=0;i<=N;i++){
      const C = cMinPlot + (cMaxView - cMinPlot)*(i/N);
      const r = (miniMaster.S || MINI_EPS) / C;
      const X = miniXcutoff_from_ratio(r);
      const Y = clampYToRange(miniXtoUnit(X, mode), mode);
      const x = CtoPx(C), y = yToPx(Y, range.yMin, range.yMax);
      d += (i? 'L ':'M ') + x + ',' + y + ' ';
    }
    curve.setAttribute('d', d);

    const leftX=CtoPx(cMinView), rightX=CtoPx(cMaxView);
    if (mode === 'oneInX'){
      const bottom = yToPx(range.yMin, range.yMin, range.yMax);
      shadeIn.setAttribute('d', d + ' L ' + rightX + ',' + bottom + ' L ' + leftX + ',' + bottom + ' Z');
    } else {
      const top = yToPx(range.yMax, range.yMin, range.yMax);
      shadeIn.setAttribute('d', d + ' L ' + rightX + ',' + top + ' L ' + leftX + ',' + top + ' Z');
    }
  }

  function curveYPxAtCost(C, mode){
    const range = yRange(mode);
    const r  = (miniMaster.S || MINI_EPS) / Math.max(MINI_EPS, C);
    const Xc = miniXcutoff_from_ratio(r);
    const Yc = clampYToRange(miniXtoUnit(Xc, mode), mode);
    return yToPx(Yc, range.yMin, range.yMax);
  }

  function snapInputs(){
    let S = parseFloat(elS.value);
    let C = parseFloat(elC.value);
    const mode = elM.value;
    let vv = parseFloat(elV.value);

    if (!isFinite(S)) S = miniMaster.S;
    if (!isFinite(C)) C = miniMaster.C;
    if (S<=0) S = MINI_EPS; if (C<=0) C = MINI_EPS;
    S = Math.min(S, MINI_MAX); C = Math.min(C, MINI_MAX);

    if (!isFinite(vv)) vv = miniMaster.val;

    // CHANGED: allow X >= 1 (was 2)
    if (mode==='oneInX' && vv < 1) vv = 1;
    if (mode==='percent'){ if (vv<=0) vv=0.000001; if (vv>=100) vv=99.999999; }
    if (mode==='micromort'){ if (vv<=0) vv=0.0001; if (vv>=1e6) vv=999999.99; }

    elS.value = String(S);
    elC.value = String(C);
    elV.value = String(vv);

    miniMaster.S=S; miniMaster.C=C; miniMaster.mode=mode; miniMaster.val=vv;
    miniMaster.X_user = miniNormalizeToX(mode, vv);
  }

  function draw(){
    const mode = elM.value;
    drawAxes(mode);

    const hasAll = [elS, elC, elV].every(el => el && String(el.value || '').trim() !== '');
    if (!hasAll) {
      if (typeof valuationEl !== 'undefined' && valuationEl) valuationEl.textContent = 'Valuation Grade: ‚Äî';
      axesG.setAttribute('opacity','0.55');
      curve.setAttribute('d','');
      shadeIn.setAttribute('d','');
      veilG.removeAttribute('visibility');
      handle.setAttribute('visibility','hidden');
      labelG.setAttribute('visibility','hidden');
      verdict.textContent = 'Enter values to see if preventative action should be considered.';
      verdict.classList.remove('ok','no');
      if (cont) cont.disabled = true;
      return;
    }
    axesG.setAttribute('opacity','1');
    veilG.setAttribute('visibility','hidden');

    window.miniPristine = false;
    snapInputs(); // sync first

    buildCurve(mode);

    handle.removeAttribute('visibility');
    labelG.removeAttribute('visibility');

    const r  = miniMaster.S / miniMaster.C;
    const Xc = miniXcutoff_from_ratio(r);
    const range = yRange(mode);
    const Xuser = (miniMaster.X_user != null) ? miniMaster.X_user : Xc;

// Valuation Grade: p √ó Xc, where p = 1 / Xuser
if (valuationEl &&
    typeof Xc === 'number' && isFinite(Xc) && Xc > 0 &&
    typeof Xuser === 'number' && isFinite(Xuser) && Xuser > 0) {

  const p = 1 / Xuser;
  const valuation = p * Xc;

  // valuation rounding logic: 3dp for <10, 2dp for <100,
  // 1dp for <1000, 0dp for >=1000
  const absVal = Math.abs(valuation);
  let decimals;
  if (absVal < 10) {
    decimals = 3;
  } else if (absVal < 100) {
    decimals = 2;
  } else if (absVal < 1000) {
    decimals = 1;
  } else {
    decimals = 0;
  }

  const shown = valuation.toLocaleString(undefined, {
    minimumFractionDigits: decimals,
    maximumFractionDigits: decimals
  });

  valuationEl.textContent = 'Valuation Grade: ' + shown;

} else if (valuationEl) {
  valuationEl.textContent = 'Valuation Grade: ‚Äî';
}
}
    const Ydot  = clampYToRange(miniXtoUnit(Xuser, mode), mode);
    const cx = CtoPx(Math.max(cMinView, Math.min(cMaxView, miniMaster.C)));
    const cy = yToPx(Ydot, range.yMin, range.yMax);
    handle.setAttribute('cx', cx); handle.setAttribute('cy', cy);

    const label = `S=${trimDeci(miniMaster.S)}, C=${trimDeci(miniMaster.C)} ¬∑ ${labelUnit(mode, Xuser)}`;
    labelTx.textContent = label;
    labelTx.setAttribute('text-anchor','middle');
    let ly = cy - 34; const minTop = pad.top + 20; if (ly < minTop) ly = minTop;
    labelTx.setAttribute('x', cx); labelTx.setAttribute('y', ly);
    const bb = labelTx.getBBox(); const padBox=10;
    labelBg.setAttribute('x', bb.x-padBox); labelBg.setAttribute('y', bb.y-padBox);
    labelBg.setAttribute('width', bb.width+2*padBox); labelBg.setAttribute('height', bb.height+2*padBox);

    const act = (miniMaster.X_user != null) ? (miniMaster.X_user <= Xc + 1e-15) : false;
    verdict.textContent = act ? 'Verdict: Preventative action should be considered.' : 'Verdict: Preventative action should NOT be considered.';
    verdict.classList.toggle('ok', act);
    verdict.classList.toggle('no', !act);

    renderMiniQ6._act = act;
    if (cont) cont.disabled = false;
  }

  function svgPoint(evt){
    const pt = svg.createSVGPoint();
    pt.x = (evt.touches && evt.touches[0] ? evt.touches[0].clientX : evt.clientX);
    pt.y = (evt.touches && evt.touches[0] ? evt.touches[0].clientY : evt.clientY);
    return pt.matrixTransform(svg.getScreenCTM().inverse());
  }

  let dragging=false;

  function onPointerDown(e){
    e.preventDefault();
    window.miniPristine = false;
    dragging = true;
    SDragLock = Math.max(MINI_EPS, Math.min(MINI_MAX, parseFloat(elS.value) || miniMaster.S || 5));
    try { handle.setPointerCapture(e.pointerId); } catch(_) {}
    onPointerMove(e);
  }

  function onPointerMove(e){
    if(!dragging) return; e.preventDefault();
    const sp = svgPoint(e);

    
let Cn = pxToC(Math.max(pad.left, Math.min(pad.left+plotW, sp.x)));
Cn = Math.max(MINI_EPS, Math.min(MINI_MAX, Cn));

// lock S from drag start
elS.value = String(SDragLock);
miniMaster.S = SDragLock;

// If dual-cost fields exist: keep Resulting static, adjust Upfront so Upfront+Resulting=Cn
const upEl = document.getElementById('q6C_up');
const rsEl = document.getElementById('q6C_res');
if (upEl && rsEl){
  const rawR = (rsEl.value || '').trim();
  let resVal = parseFloat(rawR);
  if (!isFinite(resVal) || resVal < 0) resVal = 0;
  if (resVal > 10) resVal = 10;

  let upVal = Cn - resVal;
  if (upVal < 0) upVal = 0;
  if (upVal > 10) upVal = 10;

  const shownUp = (upVal % 1 === 0) ? String(upVal) : String(Number(upVal.toFixed(2)));
  upEl.value = shownUp;

  // recompute hidden total from these two
  if (typeof window.q6DualCostCompute === 'function'){
    window.q6DualCostCompute(false, null);
  }
} else {
  // fallback: single cost field only
  if (elC){
    const shown = (Cn % 1 === 0) ? String(Cn) : String(Number(Cn.toFixed(2)));
    elC.value = shown;
  }
  miniMaster.C = Cn;
}

    const yCursor = Math.max(pad.top, Math.min(pad.top+plotH, sp.y));
    const yCurve  = curveYPxAtCost(Cn, elM.value);
    const willSnap = Math.abs(yCursor - yCurve) <= SNAP_PX;
    if (willSnap && !isSnapped && typeof window.hapticBump === 'function') window.hapticBump();
    isSnapped = willSnap;

    const mode = elM.value;
    const range = yRange(mode);
    let yPix = willSnap ? yCurve : yCursor;

    const frac  = 1 - (yPix - pad.top) / plotH;
    const logY  = Math.log10(range.yMin) + frac * (Math.log10(range.yMax) - Math.log10(range.yMin));
    const Y     = Math.pow(10, logY);
    const X_user = unitToX(Y, mode);

    miniMaster.mode   = mode;
    miniMaster.X_user = X_user;

    // CHANGED: floor to 1 (not 2) for 1-in-X
    let valOut = (mode==='oneInX') ? X_user
              : (mode==='percent') ? (100/X_user)
              : (1e6/X_user);
    if (mode==='oneInX')       { if (valOut < 1)   valOut = 1; }
    else if (mode==='percent') { if (valOut<=0)    valOut = 0.000001; if (valOut>=100) valOut = 99.999999; }
    else                       { if (valOut<=0)    valOut = 0.0001;   if (valOut>=1e6) valOut = 999999.99; }

    elV.value = String(valOut);
    miniMaster.val = valOut;

    draw();
  }

  function onPointerUp(e){
    dragging=false;
    SDragLock = null;
    try{handle.releasePointerCapture(e.pointerId);}catch(_){}
  }

  handle.addEventListener('pointerdown', onPointerDown, {passive:false});
  svg.addEventListener('pointermove', onPointerMove, {passive:false});
  svg.addEventListener('pointerup', onPointerUp, {passive:false});
  svg.addEventListener('touchstart', onPointerDown, {passive:false});
  svg.addEventListener('touchmove', onPointerMove, {passive:false});
  svg.addEventListener('touchend', onPointerUp, {passive:false});

  function wireNumericInput(inp, { min=-Infinity, max=Infinity, decimals=null } = {}){
    if (!inp) return;
    inp.addEventListener('input', () => {
      const s = inp.value;
      const cleaned = s
        .replace(/[^0-9.\-]/g, '')
        .replace(/(.*\..*)\./, '$1')
        .replace(/(.*-).*-/ , '$1');
      if (cleaned !== s) inp.value = cleaned;
    });
    function normalize(){
      const raw = (inp.value || '').trim();
      if (raw === '' || raw === '-' || raw === '.' || raw === '-.') { inp.value = ''; return; }
      let n = Number(raw);
      if (!Number.isFinite(n)) { inp.value = ''; return; }
      n = Math.min(max, Math.max(min, n));
      inp.value = (decimals == null) ? String(n) : String(Number(n.toFixed(decimals)));
      window.miniPristine = false;
      draw();
    }
    inp.addEventListener('blur', normalize);
    inp.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); inp.blur(); } });
  }
  wireNumericInput(elS, { min:0, max:10,   decimals:2 });
  wireNumericInput(elC, { min:0, max:10,   decimals:2 });
  wireNumericInput(elV, { min:0, max:1e12, decimals:6 });

  // Don't call draw() on input for elV; let blur normalize to avoid mid-typing clamps
  elS.addEventListener('input', ()=>{ window.miniPristine=false; draw(); });
  elC.addEventListener('input', ()=>{ window.miniPristine=false; draw(); });
  elV.addEventListener('input', ()=>{ window.miniPristine=false; /* no draw here to avoid clobbering while typing */ });

  const persistQ6 = () => saveNodeState('Q6', collectFormValues(q6Root));
  q6Root.addEventListener('input',  persistQ6);
  q6Root.addEventListener('change', persistQ6);

  requestAnimationFrame(() => { draw(); });
  draw();

  const btns = document.getElementById('buttons');
  btns.innerHTML = '';
  cont = document.createElement('button'); cont.className='next'; cont.type='button'; cont.textContent='Continue'; cont.disabled=true;
  cont.onclick = function(){
    miniActGate = !!renderMiniQ6._act;
    goToNode(miniActGate ? 'Q10' : 'Q7');
  };
  btns.appendChild(cont);
}


function renderMiniQ7(root, opts){
  const el = (typeof root === 'string') ? document.querySelector(root) : root;
  if (!el) return;
  const o = Object.assign({
    question: 'Would you proceed?',
    linkHref: '#',
    linkText: 'Learn the cutoff rule'
  }, opts||{});

  // --- borrow Q6 classes so spacing + buttons match exactly ---
  const q6 = document.querySelector('[data-node-id="Q6"], #q6-entry') || document;
  const yesBtnQ6 = q6 && Array.from(q6.querySelectorAll('button')).find(b => /yes/i.test(b.textContent||''));
  const noBtnQ6  = q6 && Array.from(q6.querySelectorAll('button')).find(b => /no/i.test(b.textContent||''));
  const btnRowQ6 = (yesBtnQ6 && yesBtnQ6.parentElement) || null;

  const sectionProto = q6.querySelector('.section, .q6-section, .form-section') || null;
  const rowProto     = q6.querySelector('.row, .q6-row, .grid, .flex-row') || null;
  const cardProto    = q6.querySelector('.card, .panel, .q6-card') || null;
  const titleProto   = q6.querySelector('.title, .heading, .q6-title') || null;
  const ruleProto    = q6.querySelector('.rule, .q6-rule, .monospace') || null;
  const verdictProto = q6.querySelector('[data-q6-verdict], .mini-verdict, .verdict') || null;

  // helper to clone class names from a proto element
  const cls = n => n ? n.className : '';
  function make(tag, like){ const d=document.createElement(tag); if(like) d.className = cls(like); return d; }

  // --- local math (Prob C), isolated from Q6 ---
  function w10(x){ const xf=+x; if(!(xf>0)) return 0; return Math.pow(10, 6*((xf-1)/9)); }
  function Xcut(S,C){ const X = w10(S)/w10(C); return (isFinite(X)&&X>0)?X:1e6; }

  // --- build UI (no inline CSS, rely on Q6 classes we copied) ---
  el.innerHTML = '';
  const card   = make('div', cardProto);
  const title  = make('div', titleProto); title.textContent = o.question;

  // controls (match Q6 spacing via section/row prototypes)
  const secCtl = make('div', sectionProto);
  const rowCtl = make('div', rowProto);
  const sWrap  = make('div', sectionProto);
  const cWrap  = make('div', sectionProto);

  const sLabel = document.createElement('label'); sLabel.textContent = 'Severity (S)';
  const sRange = document.createElement('input'); sRange.type='range'; sRange.min=1; sRange.max=10; sRange.step=0.1; sRange.value=7;
  const sNum   = document.createElement('input'); sNum.type='number'; sNum.min=1; sNum.max=10; sNum.step=0.1; sNum.value=7;

  const cLabel = document.createElement('label'); cLabel.textContent = 'Cost (C)';
  const cRange = document.createElement('input'); cRange.type='range'; cRange.min=1; cRange.max=10; cRange.step=0.1; cRange.value=7;
  const cNum   = document.createElement('input'); cNum.type='number'; cNum.min=1; cNum.max=10; cNum.step=0.1; cNum.value=7;

  sWrap.appendChild(sLabel); sWrap.appendChild(sRange); sWrap.appendChild(sNum);
  cWrap.appendChild(cLabel); cWrap.appendChild(cRange); cWrap.appendChild(cNum);
  rowCtl.appendChild(sWrap); rowCtl.appendChild(cWrap);
  secCtl.appendChild(rowCtl);

  // graph canvas (purely illustrative; no Q6 coupling)
  const graphSec = make('div', sectionProto);
  const canvas = document.createElement('canvas'); canvas.width=600; canvas.height=260; graphSec.appendChild(canvas);

  // rule + verdict styled like Q6 if present
  const rule = make('div', ruleProto);
  rule.textContent = 'Cutoff (1 in X) = 10^{(2/3)¬∑(S ‚àí C)} = weight(S) / weight(C),  weight(x) = 10^{6(x‚àí1)/9}';
  const verdict = make('div', verdictProto || sectionProto); verdict.setAttribute('data-q6-verdict','');

  // link
  const link = document.createElement('a'); link.href=o.linkHref; link.textContent=o.linkText; link.target='_blank'; link.rel='noopener';

  // yes/no row using Q6‚Äôs button classes
  const btnRow = document.createElement('div'); if (btnRowQ6) btnRow.className = btnRowQ6.className;
  const yesBtn = document.createElement('button'); if (yesBtnQ6) yesBtn.className = yesBtnQ6.className; yesBtn.textContent = yesBtnQ6?.textContent || 'Yes';
  const noBtn  = document.createElement('button');  if (noBtnQ6)  noBtn.className  = noBtnQ6.className;  noBtn.textContent  = noBtnQ6?.textContent  || 'No';
  btnRow.appendChild(yesBtn); btnRow.appendChild(noBtn);

  // assemble
  card.appendChild(title);
  card.appendChild(graphSec);
  card.appendChild(secCtl);
  card.appendChild(rule);
  card.appendChild(verdict);
  card.appendChild(link);
  card.appendChild(btnRow);
  el.appendChild(card);

  // --- behavior (local only) ---
  const state = { S:+sNum.value, C:+cNum.value };
  function fmt1inX(x){
    if (!isFinite(x) || x<=0) return '‚Äî';
    if (x < 1000) return `1 in ${x.toFixed(0)}`;
    if (x < 10000) return `1 in ${(x/1e3).toFixed(2)}k`;
    if (x < 1e6) return `1 in ${(x/1e3).toFixed(0)}k`;
    return `1 in ${(x/1e6).toFixed(2)}M`;
  }
  function draw(){
    const ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height;
    ctx.clearRect(0,0,W,H);
    const rMin=0.5, rMax=10, yMin=0, yMax=6;
    const padL=40, padR=12, padT=12, padB=28;
    const plotW=W-padL-padR, plotH=H-padT-padB;
    const xpix = rr => padL + ((rr-rMin)/(rMax-rMin))*plotW;
    const ypix = ly => padT + (1 - ((ly-yMin)/(yMax-yMin)))*plotH;

    // grid
    ctx.strokeStyle='#eee'; ctx.lineWidth=1; ctx.fillStyle='#777'; ctx.font='11px system-ui, sans-serif';
    for (let gy=0; gy<=6; gy++){ const y=ypix(gy); ctx.beginPath(); ctx.moveTo(padL,y); ctx.lineTo(W-padR,y); ctx.stroke(); ctx.fillText(`10^${gy}`, 4, y+4); }
    [0.5,1,2,3,5,7,10].forEach(t=>{ const x=xpix(t); ctx.beginPath(); ctx.moveTo(x,padT); ctx.lineTo(x,H-padB); ctx.stroke(); ctx.textAlign='center'; ctx.fillText(String(t), x, H-8); });
    ctx.textAlign='left';

    // cutoff curve: log10(X) = (2/3)*C*(r-1)
    ctx.strokeStyle='#1f6feb'; ctx.lineWidth=2; ctx.beginPath();
    for (let i=0;i<=400;i++){ const rr=rMin+(i/400)*(rMax-rMin); const ly=(2/3)*state.C*(rr-1); const x=xpix(rr), y=ypix(ly); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
    ctx.stroke();

    // marker at current r = S/C
    const rr = state.S/Math.max(1e-6, state.C);
    const ly = (2/3)*state.C*(rr-1);
    ctx.fillStyle='#d73a49'; ctx.beginPath(); ctx.arc(xpix(rr), ypix(ly), 4, 0, Math.PI*2); ctx.fill();
  }
  function update(){
    const X = Xcut(state.S, state.C);
    const p = 1/X, pct = p*100;
    verdict.textContent = `Cutoff at r = S/C = ${(state.S/state.C).toFixed(2)}: ${fmt1inX(X)}  (${p.toExponential(2)} decimal, ${pct.toFixed(6)}%)`;
    draw();
  }
  function clamp(v){ return Math.min(10, Math.max(1, +v)); }
  sRange.addEventListener('input',  ()=>{ state.S=clamp(sRange.value); sNum.value=state.S; update(); });
  sNum  .addEventListener('change', ()=>{ state.S=clamp(sNum.value);   sRange.value=state.S; update(); });
  cRange.addEventListener('input',  ()=>{ state.C=clamp(cRange.value); cNum.value=state.C; update(); });
  cNum  .addEventListener('change', ()=>{ state.C=clamp(cNum.value);   cRange.value=state.C; update(); });

  yesBtn.addEventListener('click', ()=> el.dispatchEvent(new CustomEvent('q7:answer', {detail:{answer:'yes', S:state.S, C:state.C}, bubbles:true})));
  noBtn .addEventListener('click', ()=> el.dispatchEvent(new CustomEvent('q7:answer', {detail:{answer:'no',  S:state.S, C:state.C}, bubbles:true})));

  update();
}

var currentThresholdPct = 90;
var miniActGate = false; 
var hasFlashedIf = false;
var hasFlashedWhen = false;
var lastWasResult = false;
var originalTitleHTML = null;

var historyStack = [];
var currentNode = flowchart.find(function(n){ return n.id === "Q0"; });
var currentSegment = "If You Should Act";

function getSegmentForNodeId(id) {
  if (!id || id.charAt(0) !== 'Q') return currentSegment;
  var m = /^Q(\d+)$/.exec(id);
  if (!m) return currentSegment;
  var num = parseInt(m[1], 10);
  return num >= 31 ? "When You Should Act" : "If You Should Act";
}

function setHeadingText(node) {
  var title = document.getElementById('segmentTitle');
  var skipBtn = document.getElementById('skipBtn');

  if (!node) { title.textContent = ''; skipBtn.style.display='none'; return; }

  if ((node.type === 'about' || node.type === 'aboutMenu') && node.heading) {
    title.textContent = node.heading;
    skipBtn.style.display = 'none';
    return;
  }

  if (node.id === 'Q0') {
    if (originalTitleHTML) title.innerHTML = originalTitleHTML;
    skipBtn.style.display = 'none';
    return;
  }

  if (node.type === 'result') {
    title.textContent = "üëçüëé Verdict";
    skipBtn.style.display = 'none';
    return;
  }

  var segText = (currentSegment === "If You Should Act")
    ? "‚öñÔ∏è If You Should Act"
    : "‚è≥ When You Should Act";

  title.textContent = segText;
  skipBtn.style.display = (currentSegment === "If You Should Act" && node.type !== 'result')
    ? 'inline-block'
    : 'none';
}

function flashHeadingColor(targetSegment, node) {
  const el = document.getElementById('segmentHeading');
  if (!el) return;
  if (currentNode && currentNode.id === 'Q0') return;

  let cls;
  if (node && node.type === 'result')        cls = 'flash-purple';
  else if (targetSegment === 'If You Should Act') cls = 'flash-green';
  else                                        cls = 'flash-gold';

  
  flashWithPlateau(el, cls, { inMs: 300, holdMs: 900, outMs: 300 });
}

function getSectionKey(n){
  if (!n) return null;
  if (n.type === 'about')  return 'about';
  if (n.type === 'result') return 'result';
  const s = (n.segmentLabel || n.segment || '').toLowerCase();
  if (s.includes('if'))   return 'if';
  if (s.includes('when')) return 'when';
  return 'other';
}

function maybeFlashOnEnter(node, fromId){
  if (!node || node.id !== 'Q1') return;

  const fromNode    = flowchart.find(n => n.id === fromId);
  const fromSection = getSectionKey(fromNode);

  
  if (fromId === 'Q0' || (fromSection && fromSection !== 'if')) {
    
    flashHeadingColor('If You Should Act', node);
  }
}

function closeAllPanels() {
  collapseSharedPanel();
  var risk = document.getElementById('riskInline');
  if (risk) {
    risk.style.display = 'none';
    risk.setAttribute('aria-hidden','true');
  }
}

function beforeEnterNode(nextId) {
  if (miniActGate && (nextId === 'Q16' || nextId === 'Q17' || nextId === 'Q18')) {
    return 'Q22';
  }
  return nextId;
}

function makeButton(label, cls, action) {
  var btn = document.createElement('button');
  btn.type = 'button';
  btn.textContent = label;
  btn.className = cls;
  btn.onclick = action;
  return btn;
}
function goToNode(id) {
  
  if (currentNode && (currentNode.id === 'Q33' || currentNode.id === 'Q6')) {
    const root = document.getElementById('text');
    if (root) {
      const slider = root.querySelector('.heat-slider');
      if (slider) setUserThreshold(slider.value);
      if (typeof saveNodeState === 'function' && typeof collectFormValues === 'function') {
        saveNodeState(currentNode.id, collectFormValues(root));
      }
    }
  }

  closeAllPanels();
  var adjustedId = beforeEnterNode(id);
  noteOrigin(currentNode);
  var fromId = currentNode ? currentNode.id : '';
  var next = flowchart.find(n => n.id === adjustedId);
  historyStack.push(currentNode ? currentNode.id : '');
  currentNode = next; renderNode(currentNode);
  maybeFlashOnEnter(currentNode, fromId);
}
function goBack() {
  
  if (currentNode && (currentNode.id === 'Q33' || currentNode.id === 'Q6')) {
    const root = document.getElementById('text');
    if (root) {
      const slider = root.querySelector('.heat-slider');
      if (slider) setUserThreshold(slider.value);
      if (typeof saveNodeState === 'function' && typeof collectFormValues === 'function') {
        saveNodeState(currentNode.id, collectFormValues(root));
      }
    }
  }
  closeAllPanels();
  var fromId = currentNode ? currentNode.id : '';
  var prevId = historyStack.pop();

  
  if (prevId === 'AB2' && window.__ab2TempVisit) {
    window.__ab2TempVisit = false; 
    prevId = historyStack.pop();   
  }

  var prev = flowchart.find(n => n.id === prevId);
  currentNode = prev || currentNode;
  renderNode(currentNode);
  maybeFlashOnEnter(currentNode, fromId);
}
function restart() {
  closeAllPanels();
  resetQ6State();
  historyStack = [];
  currentSegment = "If You Should Act";
  currentNode = flowchart.find(n => n.id === "Q0");
  hasFlashedIf = false;
  hasFlashedWhen = false;
  lastWasResult = false;
  miniActGate = false;
  window.miniPristine = true;
  window.__pendingConceptScroll = null;
  window.__backTargetForAB2 = null;
  window.__ab2TempVisit = false;
  sessionStorage.removeItem('userThreshold');
  delete window.currentThresholdPct;
  if (originalTitleHTML) {
    document.getElementById('segmentTitle').innerHTML = originalTitleHTML;
    document.getElementById('skipBtn').style.display = 'none';
  }
  renderNode(currentNode);
}

document.getElementById('skipBtn').addEventListener('click', function() {
  closeAllPanels();
  goToNode('Q31');
});

function collapseSharedPanel() {
  var panel = document.getElementById('sharedPanel');
  if (panel) {
    panel.style.display = 'none';
    panel.setAttribute('aria-hidden','true');
    panel.dataset.mode = '';
    panel.innerHTML = '';
  }
  var leftWrap  = document.getElementById('leftControlsWrapper');
  var rightWrap = document.getElementById('rightControlsWrapper');

  if (leftWrap) {
    var exBtns = leftWrap.querySelectorAll('.examples-btn');
    for (var i=0;i<exBtns.length;i++) {
      exBtns[i].textContent = 'Show Examples';
      exBtns[i].setAttribute('aria-expanded','false');
      exBtns[i].classList.remove('active');
    }
  }
  if (rightWrap) {
    var rBtns = rightWrap.querySelectorAll('.viz-btn, .reasoning-btn');
    for (var j=0;j<rBtns.length;j++) {
      var btn = rBtns[j];
      if (btn.classList.contains('viz-btn')) btn.textContent = 'Show Visualization';
      if (btn.classList.contains('reasoning-btn')) btn.textContent = 'Show Percentage Reasoning';
      btn.setAttribute('aria-expanded','false');
      btn.classList.remove('active');
    }
  }
}

function openSharedPanel(panel, mode) {
  panel.style.display = 'block';
  panel.setAttribute('aria-hidden','false');
  panel.dataset.mode = mode;
}

function renderExamples(panel, qid) {
  var ex = window.examples[qid];
  if (!ex) {
    panel.innerHTML = '<p>No examples available.</p>';
    return;
  }
  var ul = document.createElement('ul');
  for (var i=0;i<ex.length;i++) {
    var li = document.createElement('li');
    li.textContent = ex[i];
    ul.appendChild(li);
  }
  panel.appendChild(ul);
}

function renderViz(panel, src, alt) {
  var img = document.createElement('img');
  img.src = src;
  img.alt = alt;
  panel.appendChild(img);
}

function createTickRow(where, wrap) {
  var tickRow = document.createElement('div');
  tickRow.className = 'tick-row ' + where;
  for (var i=1;i<=10;i++) {
    var tick = document.createElement('div');
    tick.className = 'tick';
    tick.style.left = (i-1) * (100/9) + '%';
    tickRow.appendChild(tick);
  }
  wrap.appendChild(tickRow);
}

function updateSliderFill(slider, sev) {
  const pct = ((sev - 1) / 9) * 100;
  slider.style.setProperty('--pct', pct + '%');

  
  const t = Math.pow((sev - 1) / 9, 0.2); 
  const hue = 240 - t * 240; 
  const color = `hsl(${hue}, 90%, 50%)`;
  slider.style.setProperty('--fill', color);
}

function setupAuxToggles(node) {
  var leftWrap = document.getElementById('leftControlsWrapper');
  var rightWrap = document.getElementById('rightControlsWrapper');
  var panel = document.getElementById('sharedPanel');

  leftWrap.innerHTML = '';
  rightWrap.innerHTML = '';
  collapseSharedPanel();

  
  var allowAux = (node.type === 'question') || (node.id === 'Q33');
  if (!allowAux) return;

  
  var examplesBtn = document.createElement('button');
  examplesBtn.type = 'button';
  examplesBtn.textContent = 'Show Examples';
  examplesBtn.className = 'examples-btn ctrl-btn';
  examplesBtn.setAttribute('aria-expanded', 'false');
  leftWrap.appendChild(examplesBtn);

  examplesBtn.onclick = function() {
    var isOpenExamples = panel.style.display === 'block' && panel.dataset.mode === 'examples';
    if (isOpenExamples) {
      collapseSharedPanel();
    } else {
      panel.innerHTML = '';
      renderExamples(panel, node.id);
      openSharedPanel(panel, 'examples');
      examplesBtn.setAttribute('aria-expanded','true');
      examplesBtn.classList.add('active');
    }
  };

  
  if (node.id === 'Q22' || node.id === 'Q24') {
    var vizBtn = document.createElement('button');
    vizBtn.type = 'button';
    vizBtn.textContent = 'Show Visualization';
    vizBtn.className = 'viz-btn ctrl-btn';
    vizBtn.setAttribute('aria-expanded', 'false');
    rightWrap.appendChild(vizBtn);

    vizBtn.onclick = function() {
      var isOpenViz = panel.style.display === 'block' && panel.dataset.mode === 'viz';
      var src = node.id === 'Q22' ? './diminishing_returns_curve.png' : './inverted_u_curve.png';
      var alt = node.id === 'Q22'
        ? 'Diminishing Returns Curve: Effort/Resources vs Functional Results'
        : 'Inverted-U Curve: Effort/Resources vs Functional Results';
      if (isOpenViz) {
        collapseSharedPanel();
      } else {
        panel.innerHTML = '';
        renderViz(panel, src, alt);

        var link = document.createElement('a');
        link.href = (node.id === 'Q22') 
          ? '#concept-diminishing-returns' 
          : '#concept-inverted-u';
        link.textContent = 'See full explanation and formulas';
        link.style.display = 'inline-block';
        link.style.marginTop = '8px';
        
        link.addEventListener('click', function (e) {
          e.preventDefault();
          const target = (node.id === 'Q22')
            ? 'concept-diminishing-returns'
            : 'concept-inverted-u';
          history.replaceState(null, '', `#${target}`);
          jumpToConcept(target,  node.id);
        })
        
        panel.appendChild(link);

        openSharedPanel(panel, 'viz');
        vizBtn.setAttribute('aria-expanded','true');
        vizBtn.classList.add('active');
      }
    };
  } else if (node.id === 'Q46' || node.id === 'Q47') {
    var reasonBtn = document.createElement('button');
    reasonBtn.type = 'button';
    reasonBtn.textContent = 'Show Percentage Reasoning';
    reasonBtn.className = 'reasoning-btn ctrl-btn';
    reasonBtn.setAttribute('aria-expanded','false');
    rightWrap.appendChild(reasonBtn);

    reasonBtn.onclick = function() {
      var isOpenReason = panel.style.display === 'block' && panel.dataset.mode === 'reason';
      if (isOpenReason) {
        collapseSharedPanel();
      } else {
        panel.innerHTML = '';
        var p = document.createElement('p');
        p.textContent = 'Your current threshold is ' + currentThresholdPct + '%.';
        panel.appendChild(p);
        var img = document.createElement('img');
        img.src = './linear_threshold_chart.png';
        img.alt = 'Linear Severity to Action Threshold: Threshold = 100% ‚àí (Severity √ó 10%)';
        panel.appendChild(img);
        
        var link = document.createElement('a');
        link.href = '#concept-severity-threshold';
        link.textContent = 'See full explanation';
        link.style.display = 'inline-block';
        link.style.marginTop = '8px';
        link.addEventListener('click', function(e) {
          e.preventDefault();
          const target = 'concept-severity-threshold';
          history.replaceState(null, '', `#${target}`);
          jumpToConcept(target,  node.id);
        })
        panel.appendChild(link);

        
        openSharedPanel(panel, 'reason');
        reasonBtn.setAttribute('aria-expanded','true');
        reasonBtn.classList.add('active');
      }
    };
  }
}

function formatPct(p){ 
  
  return (Math.round(p) === p ? String(p) : String(Number(p.toFixed(1))));
}

function transformQ46(html){
  
  var pct = formatPct(currentThresholdPct);
  return html.replace(/nearing or greater than 50%/g, 'nearing or greater than ' + pct + '%');
}

function transformQ47(html){
  
  var pct = formatPct(currentThresholdPct);
  return html.replace(/nearing or greater than 50%/g, 'nearing or greater than ' + pct + '%');
}

function showOrHideRiskInline(node) {
  var container = document.getElementById('riskInline');
  container.innerHTML = '';
  if (!node || node.id !== 'Q33') {
    container.style.display = 'none';
    container.setAttribute('aria-hidden','true');
    return;
  }
  container.style.display = 'block';
  container.setAttribute('aria-hidden','false');

  var sevDisplay = document.createElement('div');
  sevDisplay.className = 'sev-display';
  sevDisplay.id = 'sevDisplay';
  sevDisplay.textContent = '1';
  container.appendChild(sevDisplay);

  var row = document.createElement('div'); row.className = 'risk-row';

  var wrap = document.createElement('div');
  wrap.className = 'slider-wrap';

  var slider = document.createElement('input');
  slider.type = 'range'; slider.min = '1'; slider.max = '10'; slider.step = '1';
  slider.className = 'heat-slider';
  slider.setAttribute('list','riskTicks');
  var stored = getUserThreshold();
  slider.value = (stored != null ? String(stored) : '1');
  
  createTickRow('top', wrap);
  wrap.appendChild(slider);
  createTickRow('bottom', wrap);

  row.appendChild(wrap);
  container.appendChild(row);

  var ticks = document.createElement('datalist');
  ticks.id = 'riskTicks';
  for (var i=1;i<=10;i++){ var opt=document.createElement('option'); opt.value=String(i); ticks.appendChild(opt); }
  container.appendChild(ticks);

  function applyFromSeverity(sev) {
    var s = Math.max(1, Math.min(10, Number(sev) || 1)); 
    var thr = 100 - s * 10;
    window.currentThresholdPct = thr; 
    sevDisplay.textContent = String(s);
    updateSliderFill(slider, s);
    
    if (currentNode && (currentNode.id === 'Q46' || currentNode.id === 'Q47')) {
      var textDiv = document.getElementById('text');
      var html = currentNode.text || '';
      html = currentNode.id === 'Q46' ? transformQ46(html) : transformQ47(html);
      textDiv.innerHTML = '<div class="result-text">' + html + '</div>';
    }
  }

  applyFromSeverity(parseInt(slider.value, 10));

  slider.oninput = function() {
    var sev = parseInt(slider.value, 10);
    applyFromSeverity(sev);
    setUserThreshold(slider.value);   
    if (typeof hapticBump === 'function') hapticBump();
  };
}
  

var CONCEPT_ANCHOR_BY_QID = {
  Q22: 'concept-diminishing-returns',
  Q24: 'concept-inverted-u',
  Q46: 'concept-severity-threshold',
  Q47: 'concept-severity-threshold',
  Q6: 'concept-prob-sev-cost',
  Q7: 'concept-prob-sev-cost'
};

function assignConceptAnchors() {
  var textDiv = document.getElementById('text');
  if (!textDiv) return;

  function setIdByHeadingContains(phrase, id) {
    var hs = textDiv.querySelectorAll('h2, h3');
    for (var i=0;i<hs.length;i++){
      var h = hs[i];
      if ((h.textContent||'').toLowerCase().includes(phrase.toLowerCase())) {
        h.id = id; return true;
      }
    }
    return false;
  }

  
  if (!textDiv.querySelector('#concepts-top')) {
    setIdByHeadingContains('IF You Should Act', 'concepts-top');
    setIdByHeadingContains('Diminishing Returns', 'concept-diminishing-returns');
    setIdByHeadingContains('Inverted-U', 'concept-inverted-u');
    setIdByHeadingContains('Severity and Threshold', 'concept-severity-threshold');
    setIdByHeadingContains('Probability vs. Severity vs. Cost', 'concept-prob-sev-cost');
  }
}

let __lastQuestionId = null;
function noteOrigin(node) {
  if (node && node.id && /^Q\d+$/.test(node.id)) __lastQuestionId = node.id;
}

window.addEventListener('error', e => {
  const box = document.getElementById('errorBox') || document.body.appendChild(Object.assign(document.createElement('pre'), {id:'errorBox'}));
  box.style.cssText = 'white-space:pre-wrap;padding:12px;margin:8px;border:1px solid #a00;background:#2b0000;color:#fff';
  box.textContent = 'JS Error: ' + (e.message || e.error || e);
});
window.addEventListener('unhandledrejection', e => {
  const box = document.getElementById('errorBox') || document.body.appendChild(Object.assign(document.createElement('pre'), {id:'errorBox'}));
  box.style.cssText = 'white-space:pre-wrap;padding:12px;margin:8px;border:1px solid #a00;background:#2b0000;color:#fff';
  box.textContent = 'Promise Rejection: ' + (e.reason && (e.reason.message || e.reason)) ;
});
  
function bootGuide() {
  
  const text = document.getElementById('text');
  if (!text) {
    console.warn('DOM not ready for boot; retrying‚Ä¶');
    return setTimeout(bootGuide, 30);
  }

  
  if (!Array.isArray(window.flowchart) || !flowchart.length) {
    console.warn('flowchart not ready; retrying‚Ä¶');
    return setTimeout(bootGuide, 30);
  }

  
  const titleEl = document.getElementById('segmentTitle');
  if (titleEl && !window.originalTitleHTML) {
    window.originalTitleHTML = titleEl.innerHTML || '';
  }

  
  window.currentNode = flowchart.find(n => n.id === 'Q0') || flowchart[0];
  renderNode(window.currentNode);
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', bootGuide);
} else {
  bootGuide();
}
  
function safeTypeset(rootEl) {
  try {
    if (window.MathJax && MathJax.typesetPromise && rootEl) {
      return MathJax.typesetPromise([rootEl]).catch(()=>{});
    }
  } catch (_) {}
  return Promise.resolve();
}

function setUserThreshold(v){
  const n = Number(v);
  if (!Number.isFinite(n)) return;
  sessionStorage.setItem('userThreshold', String(n));
}
function getUserThreshold(){
  const s = sessionStorage.getItem('userThreshold');
  if (s == null) return null;
  const n = Number(s);
  return Number.isFinite(n) ? n : null;
}

function syncHeatSliderFill(sl){
  if (!sl) return;
  const min = sl.min !== '' ? Number(sl.min) : 0;
  const max = sl.max !== '' ? Number(sl.max) : 100;
  const sev = Number(sl.value) || min;
  const pct = Math.max(0, Math.min(100, ((sev - min) / (max - min)) * 100));
  
  sl.style.setProperty('--pct', pct + '%');
  
  if (typeof updateSliderFill === 'function') {
    updateSliderFill(sl, sev);
  }
}

  
  function waitForAB2Layout(root, {timeout=800} = {}) {
    const waits = [];
  
    
    try {
      if (window.MathJax && MathJax.typesetPromise) {
        waits.push(MathJax.typesetPromise([root]).catch(()=>{}));
      }
    } catch (_) {}
  
    
    const imgs = Array.from(root.querySelectorAll('img'));
    if (imgs.length) {
      waits.push(Promise.all(imgs.map(img =>
        img.complete ? Promise.resolve()
                     : new Promise(res => {
                         img.addEventListener('load',  res, {once:true});
                         img.addEventListener('error', res, {once:true});
                       })
      )));
    }
  
    
    function nextFrames(n=2){ return new Promise(r=>{
      let i=0; const step=()=>{ if(++i>n) r(); else requestAnimationFrame(step); };
      requestAnimationFrame(step);
    });}
    waits.push(nextFrames(2));
  
    
    return Promise.race([
      Promise.all(waits),
      new Promise(res => setTimeout(res, timeout))
    ]);
  }
  
  
  async function robustScrollToConcept(root, conceptId, backQId) {
    
    scrollToConcept(conceptId, backQId);
  
    
    await waitForAB2Layout(root);
    scrollToConcept(conceptId, backQId);
  
    
    requestAnimationFrame(() => scrollToConcept(conceptId, backQId));
  }

function resetQ6State() {
  
  try {
    sessionStorage.removeItem('userThreshold');   
    sessionStorage.removeItem('miniMaster');      
  } catch (_) {}

  
  window.miniPristine = true;

  
  window.miniMaster = {
    S: null,
    C: null,
    mode: 'oneInX',
    val: null,
    X_user: null
  };

  
  const s = document.querySelector('#q6_S');
  const c = document.querySelector('#q6_C');
  const v = document.querySelector('#q6_val');
  const modeSel = document.querySelector('#q6_mode');
  if (s) s.value = '';
  if (c) c.value = '';
  if (v) v.value = '';
  if (modeSel) modeSel.value = 'oneInX';
}
  

if (!originalTitleHTML) {
  originalTitleHTML = document.getElementById('segmentTitle').innerHTML;
}

function renderNode(node) {
  closeAllPanels();
  var errorBox = document.getElementById('errorBox');
  errorBox.textContent = '';

  if (!node) {
    errorBox.textContent = "Error: Could not render step.";
    document.getElementById('text').textContent = '';
    document.getElementById('buttons').innerHTML = '';
    setHeadingText('');
    document.getElementById('backBtn').style.visibility = historyStack.length > 0 ? 'visible' : 'hidden';
    document.getElementById('restartTop').style.display = 'inline-block';
    return;
  }

  var previousSegment = currentSegment;
  var thisSegment = (node.type === 'about' || node.type === 'aboutMenu')
    ? previousSegment
    : getSegmentForNodeId(node.id);

  var comingFromResult = lastWasResult && node.type !== 'result';
  var shouldFlash =
    node.id !== 'Q0' && (
      node.type === 'result' ||
      comingFromResult ||
      thisSegment !== previousSegment ||
      (thisSegment === "If You Should Act" && !hasFlashedIf) ||
      (thisSegment === "When You Should Act" && !hasFlashedWhen)
    );

  if (shouldFlash && !(node.type === 'about' || node.type === 'aboutMenu')) {
    flashHeadingColor(thisSegment, node);
    if (thisSegment === "If You Should Act") hasFlashedIf = true;
    if (thisSegment === "When You Should Act") hasFlashedWhen = true;
  }

  currentSegment = thisSegment;
  setHeadingText(node);
  lastWasResult = (node.type === 'result');

  var textDiv = document.getElementById('text');

  
  var themeBtn = document.getElementById('themeToggle');
  if (themeBtn) {
    themeBtn.style.display = (node.id === 'Q0') ? 'inline-block' : 'none';
    if (node.id === 'Q0' && window.__refreshThemeButtonLabel) window.__refreshThemeButtonLabel();
  }
  document.getElementById('backBtn').style.visibility = historyStack.length > 0 ? 'visible' : 'hidden';

  
  if (node.id === 'Q6') {
    textDiv.innerHTML = '';
    document.getElementById('buttons').innerHTML = '';
    renderMiniQ6(textDiv, node);
    return;
  }
  if (node.id === 'Q7') {
    textDiv.innerHTML = '';
    document.getElementById('buttons').innerHTML = '';
    renderMiniQ7(textDiv, node);
    return;
  }
  
  
  let html = node.text || '';
  if (node && (node.id === 'Q46' || node.id === 'Q47')) {
    html = (node.id === 'Q46') ? transformQ46(html) : transformQ47(html);
  }
  
  
  document.getElementById('text').innerHTML = html;

  
  if (node && node.id === 'Q33') {
    const q33Root = document.getElementById('text');
    const slider  = q33Root.querySelector('.heat-slider');
  
    
    const saved = (typeof loadNodeState === 'function') ? loadNodeState('Q33') : null;
    if (saved && typeof applyFormValues === 'function') applyFormValues(q33Root, saved);
  
    
    requestAnimationFrame(() => requestAnimationFrame(() => {
      const stored = getUserThreshold();
      if (slider && stored != null) {
        slider.value = String(stored);
        syncHeatSliderFill(slider);        
      }
    }));
  
    
    const persistQ33 = () => {
      if (typeof saveNodeState === 'function' && typeof collectFormValues === 'function') {
        saveNodeState('Q33', collectFormValues(q33Root));
      }
      if (slider) setUserThreshold(slider.value);
    };
    q33Root.addEventListener('input',  persistQ33);
    q33Root.addEventListener('change', persistQ33);
  
    
    if (slider) setUserThreshold(slider.value);
  }

  
  if (node && (node.id === 'Q46' || node.id === 'Q47')) {
    const root = document.getElementById('text');
    const stored = getUserThreshold();
  
    
    if (stored != null) {
      const out = root.querySelector('.threshold-display');
      if (out) out.textContent = stored;  
    }
  }

  
  if (node && node.id === 'AB2') {
    const textDiv = document.getElementById('text');
    textDiv.innerHTML = `<section id="AB2" class="about-wrapper">${html}</section>`;
  
    const ab2El = document.getElementById('AB2');
    assignConceptAnchors();
  
    
    try {
      if (window.MathJax && typeof MathJax.typesetPromise === 'function') {
        if (typeof MathJax.typesetClear === 'function') MathJax.typesetClear();
        MathJax.typesetPromise([ab2El]).catch(() => {});
      }
    } catch (err) {  }
  
    
    const intent = window.__pendingConceptScroll;   
    if (intent && intent.conceptId) {
      const backQId = intent.backQId || 'Q0';
      
      window.__pendingConceptScroll = null;
      window.__backTargetForAB2 = backQId;
  
      
      try { flashAb2Heading('ab2Heading'); } catch(_) {}
  
      
      robustScrollToConcept(ab2El, intent.conceptId, backQId);
  
      
      ab2El.addEventListener('click', function (e) {
        const a = e.target.closest('a[href^="#"]');
        if (!a) return;
        const id = a.getAttribute('href').slice(1);
        if (!id) return;
        e.preventDefault();
        history.replaceState(null, '', `#${id}`);
        scrollToConcept(id, window.__backTargetForAB2 || 'Q0');
      }, { passive: true });
  
  
    } else {
      
      window.__backTargetForAB2 = null;
      
      
    }
  
    
    setupAuxToggles(node);
    showOrHideRiskInline(node);
    return;
  }

  setupAuxToggles(node);
  showOrHideRiskInline(node);

  var btns = document.getElementById('buttons');
  btns.innerHTML = '';
  const restartTop = document.getElementById('restartTop');

  if (node.type === 'result') {
    restartTop.style.display = 'none';
    btns.classList.add('center');
    const restartCentered = makeButton('Restart', 'restart', () => restart());
    restartCentered.style.flex = '0 0 auto';
    btns.appendChild(restartCentered);
  } else {
    restartTop.style.display = (node.id === 'Q0') ? 'none' : 'inline-block';
    btns.classList.remove('center');

    if (node.type === 'about') return;
    if (node.type === 'aboutMenu') {
      btns.appendChild(makeButton('About Me', 'next', () => goToNode('AB1')));
      btns.appendChild(makeButton('Guide Concepts Explained', 'next', () => goToNode('AB2')));
      return;
    }

    if (node.type === 'question') {
      const yesBtn = makeButton('Yes', 'yes', () => goToNode(node.yes));
      const noBtn  = makeButton('No',  'no',  () => goToNode(node.no));
      btns.appendChild(yesBtn);
      btns.appendChild(noBtn);
      if (node.same) btns.appendChild(makeButton('Roughly the Same', 'same', () => goToNode(node.same)));
    } else if (node.type === 'info') {
      if (node.id === 'Q0') {
        btns.appendChild(makeButton('Next', 'next', () => goToNode(node.next)));
        btns.appendChild(makeButton('About', 'next', () => goToNode('AB0')));
      } else {
        btns.appendChild(makeButton('Next', 'next', () => goToNode(node.next)));
      }
    }
  }
}

</script>

  
<script>
(function(){
function absorbOriginalRow(root, sel) {
    const inp = root.querySelector(sel);
    if (!inp) return null;
    const row = inp.closest('.mini-field') || inp.parentElement;
    if (row && row.parentElement) row.parentElement.removeChild(row);
    return inp;
  }

function rootFor(id){ return document.getElementById(id) || document.querySelector('[data-id="'+id+'"]'); }

function buildOneColumn(root, opts) {
    const id = opts.id;
    let stack = root.querySelector('#' + id + '-entry');
    if (!stack) {
      stack = document.createElement('div');
      stack.id = id + '-entry';
      const anchor = root.querySelector('.mini-field');
      if (anchor && anchor.parentElement) anchor.parentElement.insertBefore(stack, anchor);
      else root.prepend(stack);
    } else {
      stack.innerHTML = '';
    }

    
    const nRow = document.createElement('div');
    nRow.className = 'mini-field';
    nRow.style.textAlign = 'left';
    nRow.innerHTML = '<label>Total instances (N)</label><input id="' + id + 'N" type="number" min="1" step="1" value="1">';
    stack.appendChild(nRow);

    function makeSection(sectionTitle, selectors, baseId, placeholder, extraLabel, extraKind) {
      const h = document.createElement('div');
      h.className = 'mini-heading';
      h.textContent = sectionTitle;
      stack.appendChild(h);

      const toggle = document.createElement('div');
      toggle.className = 'hint';
      toggle.innerHTML = '<input id="' + baseId + 'Tg" type="checkbox"> <span class="toggle-label">Varies Across Instances</span>';
      stack.appendChild(toggle);

      stack.appendChild(Object.assign(document.createElement('div'), { className: 'mini-spacer' }));

      const field = document.createElement('div');
      field.className = 'mini-field';
      field.innerHTML = '<label>' + extraLabel + '</label>';
      
      const inputEl = absorbOriginalRow(root, selectors[0]) ||
                      absorbOriginalRow(root, selectors[1]) ||
                      absorbOriginalRow(root, selectors[2]) ||
                      document.createElement('input');
      if (!inputEl.type) inputEl.type = 'number';
      inputEl.id = baseId;
      inputEl.placeholder = placeholder;
      field.appendChild(inputEl);
      stack.appendChild(field);

      const extra = document.createElement('div');
      extra.className = 'mini-field';
      extra.id = baseId + 'ExtraWrap';
      extra.innerHTML =
        '<div class="hint">Total extra ' + extraKind + ' across outliers (sum)</div>' +
        '<input id="' + baseId + 'ExtraVal" type="number" step="any" placeholder="e.g. ' + (extraKind === 'severity' ? '3' : '2') + '">';
      stack.appendChild(extra);

      return { toggle, inputEl, extra };
    }

    
const __sepSev=document.createElement('div');__sepSev.className='mini-sep';stack.appendChild(__sepSev);
    const sev = makeSection('Severity',
      ['input[name="severity"]', '#miniS', 'input[data-q="S"]'],
      id + 'S', 'e.g. 5', 'Enter Severity (S) ‚Äî up to 10', 'severity');
const __sepCost=document.createElement('div');__sepCost.className='mini-sep';stack.appendChild(__sepCost);
    const cost = makeSection('Cost',
      ['input[name="cost"]', '#miniC', 'input[data-q="C"]'],
      id + 'C', 'e.g. 1', 'Enter Cost (C) ‚Äî up to 10', 'cost');
// ---- Q6 dual-cost (Upfront + Resulting) injection ----
try{
  (function(){
    // cost.inputEl is the original single-cost input created above. Hide it and replace with two inputs.
    const costInput = (function(){
      // Find the input we just created via makeSection: it's the last input in the Cost section.
      // It has id like 'q6C'
      var el = root.querySelector('#q6C') || root.querySelector('#q6_C') || null;
      return el;
  up.inp.value = '';
rs.inp.value = '';
costInput.value = '';
costInput.dispatchEvent(new Event('input', {bubbles:true}));
costInput.dispatchEvent(new Event('change', {bubbles:true}));
  })();
    if (!costInput) return;

    const costField = costInput.closest('.mini-field') || costInput.parentElement;
    if (!costField) return;

    // Build two new fields just before the original, then hide the original single-cost field.
    function mkField(id, label, ph){
      const wrap = document.createElement('div');
      wrap.className = 'mini-field';
      const lab = document.createElement('label'); lab.textContent = label;
      const inp = document.createElement('input');
      inp.type = 'number'; inp.id = id; inp.inputMode='decimal';
      inp.min='0'; inp.max='10'; inp.step='0.01'; inp.placeholder = ph || '';
      wrap.appendChild(lab); wrap.appendChild(inp);
      return {wrap, inp};
    }

    const up = mkField('q6C_up', 'Upfront Cost (0‚Äì10)', 'e.g. 2.5');
    const rs = mkField('q6C_res', 'Resulting Cost (0‚Äì10)', 'e.g. 1.0');

    costField.parentElement.insertBefore(up.wrap, costField);
    costField.parentElement.insertBefore(rs.wrap, costField);
    costField.style.display = 'none';

    // Weighting helpers (use app's if present)
    function weight10(x){
      if (typeof window.weight10 === 'function') return window.weight10(x);
      const xf = +x; if (!(xf > 0)) return 0;
      return Math.pow(10, 6 * ((xf - 1) / 9));
    }
    function invWeight10(w){
      if (!(w > 0)) return 0;
      return 1 + 1.5 * Math.log10(w);
    }
    function cleanStr(s){
      return String(s || '').replace(/[^0-9.\-]/g,'').replace(/(.*\..*)\./,'$1').replace(/(.*-).*-/,'$1');
    }
    function parse(el){
      const raw = (el.value||'').trim();
      if (raw === '' || raw === '.' || raw === '-' || raw === '-.') return {n:null};
      let n = Number(raw);
      if (!Number.isFinite(n)) return {n:null};
      if (n < 0) n = 0;
      if (n > 10) n = 10;
      return {n:n};
    }
    function clamp01to10(x){ if (!(x>=0)) return 0; if (x>10) return 10; return x; }

    function setMin(el){ el.value = '1e-9'; el.dataset.minCorrected = '1'; }

    let lastEdited = null;

    function compute(finalize, trigger){
  try{
    localStorage.setItem('q6C_up', up.inp.value ?? '');
    localStorage.setItem('q6C_res', rs.inp.value ?? '');
  }catch(_){}

  const Au = parse(up.inp), Br = parse(rs.inp);

  const upVal = (Au.n != null) ? Au.n : 0;
  const resVal = (Br.n != null) ? Br.n : 0;

  // Total cost is simple sum of upfront + resulting
  let C = upVal + resVal;

  if (!Number.isFinite(C) || C <= 0){
    // Clear underlying cost if nothing meaningful yet
    costInput.value = '';
    costInput.dispatchEvent(new Event('input',  {bubbles:true}));
    costInput.dispatchEvent(new Event('change', {bubbles:true}));
    return;
  }

  // Clamp to Q6 scale and write into hidden single-cost field
  C = clamp01to10(C);
  const shown = (C % 1 === 0) ? String(C) : String(Number(C.toFixed(2)));
  costInput.value = shown;
  costInput.dispatchEvent(new Event('input',  {bubbles:true}));
  costInput.dispatchEvent(new Event('change', {bubbles:true}));
}

// Expose for Q6 mini-graph so it can resync costs on drag
window.q6DualCostCompute = compute;


    // listeners
    [up.inp, rs.inp].forEach(inp => {
      inp.addEventListener('input', ()=>{ const s=cleanStr(inp.value); if (s!==inp.value) inp.value=s; lastEdited = inp; compute(false, inp); });
      inp.addEventListener('change', ()=> compute(true, inp));
      inp.addEventListener('blur', ()=> compute(true, inp));
    });

    
// restore (start fresh with placeholders; clear any old saved values)
try{
  localStorage.removeItem('q6C_up');
  localStorage.removeItem('q6C_res');
}catch(_){}
// don't prefill; leave boxes empty until edited

    // also clear on restart button
document.addEventListener('click', function(e){
  const t = e.target; if (!t) return;
  const id = t.id || ''; const cls = t.className || '';
  const dataAct = (t.dataset && (t.dataset.action || '')) || '';
  if (/restart/i.test(id) || /restart/i.test(cls) || /restart/i.test(dataAct)){
    if (up && up.inp) up.inp.value = '';
    if (rs && rs.inp) rs.inp.value = '';
    if (costInput) {
      costInput.value = '';
      costInput.dispatchEvent(new Event('input', {bubbles:true}));
      costInput.dispatchEvent(new Event('change', {bubbles:true}));
    }
  }
}, true);up.inp.value = '';
rs.inp.value = '';
costInput.value = '';
costInput.dispatchEvent(new Event('input', {bubbles:true}));
costInput.dispatchEvent(new Event('change', {bubbles:true}));
  })();
}catch(e){ console.error('Q6 dual-cost injection failed', e); }
// ---- end injection ----

const __sepProb=document.createElement('div');__sepProb.className='mini-sep';stack.appendChild(__sepProb);

    
    const hP = document.createElement('div');
    hP.className = 'mini-heading';
    hP.textContent = 'Probability';
    stack.appendChild(hP);

    const probToggle = document.createElement('div');
    probToggle.className = 'hint';
    probToggle.innerHTML = '<input id="' + id + 'TgProb" type="checkbox"> <span class="toggle-label">Varies Across Instances</span>';
    stack.appendChild(probToggle);

    stack.appendChild(Object.assign(document.createElement('div'), { className: 'mini-spacer' }));

    const modeRow = document.createElement('div');
    modeRow.className = 'mini-field';
    modeRow.id = id + 'ModeRow';
    modeRow.innerHTML = '<label>Probability Unit</label>';
    const modeSel = absorbOriginalRow(root, 'select[name="q6Units"]') ||
                    absorbOriginalRow(root, '#miniMode') ||
                    absorbOriginalRow(root, 'select[data-q="mode"]') ||
                    document.createElement('select');
    modeRow.appendChild(modeSel);
    stack.appendChild(modeRow);

    const pValRow = document.createElement('div');
    pValRow.className = 'mini-field';
    pValRow.innerHTML = '<label id="' + id + 'ProbLabel">Enter X (for "1 in X")</label>';
    const pVal = absorbOriginalRow(root, '#miniVal') ||
                 absorbOriginalRow(root, 'input[name="probVal"]') ||
                 absorbOriginalRow(root, 'input[data-q="pVal"]') ||
                 document.createElement('input');
    if (!pVal.type) pVal.type = 'number';
    pValRow.appendChild(pVal);
    stack.appendChild(pValRow);

    const groupsWrap = document.createElement('div');
    groupsWrap.id = id + 'GroupsWrap';
    groupsWrap.className = 'mini-field';
    groupsWrap.innerHTML =
      '<div id="' + id + 'Groups"></div>' +
      '<div class="mini-field" style="margin:0;padding:0">' +
      '<button id="' + id + 'AddGroup" class="back" type="button" style="width:100%">Add Probability Group</button>' +
      '</div>' +
      '<div id="' + id + 'CountMsg" class="error" style="text-align:left"></div>';
    stack.appendChild(groupsWrap);

    
    killStrays(root, stack);

    return {
      stack,
      N: stack.querySelector('#' + id + 'N'),
      tgSev: sev.toggle.querySelector('input'),
      tgCost: cost.toggle.querySelector('input'),
      tgProb: probToggle.querySelector('input'),
      sExtraWrap: sev.extra,
      cExtraWrap: cost.extra,
      sExtraVal: sev.extra.querySelector('input'),
      cExtraVal: cost.extra.querySelector('input'),
      groupsWrap, groups: groupsWrap.querySelector('#' + id + 'Groups'),
      addGroup: groupsWrap.querySelector('#' + id + 'AddGroup'),
      countMsg: groupsWrap.querySelector('#' + id + 'CountMsg'),
      pMode: modeSel, pVal: pVal,
      modeRow: modeRow
    };
  }

function dedupeVaries(scope){
    ['#miniSVaries','#miniCVaries','#miniProbVaries'].forEach(function(sel){
      var all = qa(sel, scope);
      for (var i=1;i<all.length;i++){ var w = up(all[i], '.mini-field'); if (w) w.remove(); }
    });
  }

function keepBaseProbabilityVisible(scope){
    var unit = q('#miniMode', scope), val  = q('#miniVal', scope);
    var uw = unit && up(unit, '.mini-field'); var vw = val && up(val, '.mini-field');
    if (uw) uw.style.display = ''; if (vw) vw.style.display = '';
  }

function wireProbabilityVaries(scope){
    keepBaseProbabilityVisible(scope);
    var cb    = q('#miniProbVaries', scope);
    var mBox2 = q('#miniMode2', scope) && up(q('#miniMode2', scope), '.mini-field');
    var vBox2 = q('#miniVal2',  scope) && up(q('#miniVal2',  scope), '.mini-field');
    var gWrap = q('#miniProbGroups', scope) && up(q('#miniProbGroups', scope), '.mini-field');
    function show(on){
      if (mBox2) mBox2.style.display = on ? '' : 'none';
      if (vBox2) vBox2.style.display = on ? '' : 'none';
      if (gWrap) gWrap.style.display  = on ? '' : 'none';
    }
    if (cb){ cb.addEventListener('change', function(){ keepBaseProbabilityVisible(scope); show(cb.checked); }); show(!!cb.checked); }
    else { show(false); }
  }

function blankUntilEdited(scope){
    var root = scope || document;
    var nums = qa('.mini-field input[type="number"]', root);
    nums.forEach(function(inp){ inp.addEventListener('input', function(){ this.dataset.touched='1'; }); });

    var s = q('#miniS', root);
    var n = findInstancesInput(root);

    function clearUntouched(){
      qa('.mini-field input[type="number"]', root).forEach(function(inp){
        if (inp === s) return;
        if (n && inp === n) return;
        if (!inp.dataset.touched) inp.value = '';
      });
    }

    if (s){
      ['input','change'].forEach(function(evt){
        s.addEventListener(evt, function(){ setTimeout(clearUntouched, 0); });
      });
    }

    if (n){
      n.addEventListener('input', function(){
        var digits = String(this.value||'').replace(/[^0-9]/g, '');
        this.value = digits;
      });
      n.addEventListener('blur', function(){
        if (this.value === '') return;
        var v = parseInt(this.value,10); if (!isFinite(v) || v < 1) v = 1;
        this.value = String(v);
      });
    }

    var groups = q('#miniProbGroups', root);
    if (groups){
      groups.addEventListener('input', function(e){
        var target = e.target;
        if (!target || target.type !== 'number') return;
        var maxN = n && n.value ? parseInt(n.value,10) : null;
        if (!maxN) return;
        var inputs = qa('input[type="number"]', groups);
        var sum = 0;
        for (var i=0;i<inputs.length;i++){
          var v = parseInt(inputs[i].value||'0',10) || 0;
          if (inputs[i] === target){
            if (sum + v > maxN){ inputs[i].value = String(Math.max(0, maxN - sum)); }
            v = parseInt(inputs[i].value||'0',10) || 0;
          }
          sum += v;
        }
      });
    }
  }

function ensureFullWidth(scope){
    try{
      var root = scope || document;
      qa('.mini-field input, .mini-field select, .mini-field textarea', root).forEach(function(el){
        if (el && el.style){ el.style.width='100%'; el.style.maxWidth='100%'; el.style.boxSizing='border-box'; }
      });
      var wrap = root.querySelector('.mini-wrap');
      if (wrap && wrap.style){
        wrap.style.width='100%';
        wrap.style.maxWidth='100%';
        wrap.style.overflowX='hidden';
        wrap.style.overflowY='visible';
      }
      qa('svg', root).forEach(function(svg){
        if (svg && svg.style){ svg.style.width='100%'; svg.style.maxWidth='100%'; svg.style.height='auto'; svg.style.display='block'; }
      });
    }catch(e){}
  }

function killStrays(root, stack) {
    
    const kids = Array.from(root.querySelectorAll(':scope > .mini-field'));
    kids.forEach(k => { if (!stack.contains(k)) k.style.display = 'none'; });
  }

const _orig6 = renderMiniQ6;
renderMiniQ6 = function (intoEl, node) {
      _orig6(intoEl, node);
      const root = intoEl.querySelector('.mini-wrap') || intoEl;
      if (!root) return;

      const el = buildOneColumn(root, { id: 'q6' });
      const state = window.__q6State || { groups: [] };

      
      try {
        if (el.N && state.N != null) el.N.value = state.N;
        if (el.tgSev) el.tgSev.checked = !!state.tgSev;
        if (el.tgCost) el.tgCost.checked = !!state.tgCost;
        if (el.tgProb) el.tgProb.checked = !!state.tgProb;
        if (el.sExtraVal && state.sExtraVal != null) el.sExtraVal.value = state.sExtraVal;
        if (el.cExtraVal && state.cExtraVal != null) el.cExtraVal.value = state.cExtraVal;
        if (el.pMode && state.pModeVal != null) el.pMode.value = state.pModeVal;
        if (el.pVal && state.pVal != null) el.pVal.value = state.pVal;
        if (state.groups && state.groups.length) setTimeout(()=>drawGroups(),0);
      } catch(_) {}

      function setHidden(e,on){ if(e){ e.style.display=on?'none':''; e.classList.toggle('hidden',on);} }
      function setGrey(row,on){ if(row) row.classList.toggle('muted', on); }

      function refreshVisibility(){
        const N = Math.max(1, el.N ? (el.N.valueAsNumber || 1) : 1);
        const dis = (N === 1);

        [el.tgSev, el.tgCost, el.tgProb].forEach(cb=>{
          if (!cb) return;
          cb.disabled = dis;
          setGrey(cb.parentElement, dis);
          if (dis) cb.checked = false;
        });

        setHidden(el.sExtraWrap, dis || !el.tgSev || !el.tgSev.checked);
        setHidden(el.cExtraWrap, dis || !el.tgCost || !el.tgCost.checked);

        const hideGroups = dis || !el.tgProb || !el.tgProb.checked;
        setHidden(el.groupsWrap, hideGroups);
        if (el.addGroup) { el.addGroup.disabled = hideGroups; el.addGroup.classList.toggle('muted', hideGroups); }

        
        setHidden(el.modeRow, false);

        if (dis || !(el.tgSev && el.tgSev.checked)) if (el.sExtraVal) el.sExtraVal.value='';
        if (dis || !(el.tgCost && el.tgCost.checked)) if (el.cExtraVal) el.cExtraVal.value='';
        if (dis || !(el.tgProb && el.tgProb.checked)) { state.groups=[]; if (el.groups) el.groups.innerHTML=''; if (el.countMsg) el.countMsg.textContent=''; }

        
        window.__q6State = {
          N: el.N ? el.N.value : 1,
          tgSev: el.tgSev ? el.tgSev.checked : false,
          tgCost: el.tgCost ? el.tgCost.checked : false,
          tgProb: el.tgProb ? el.tgProb.checked : false,
          sExtraVal: el.sExtraVal ? el.sExtraVal.value : null,
          cExtraVal: el.cExtraVal ? el.cExtraVal.value : null,
          pModeVal: el.pMode ? el.pMode.value : null,
          pVal: el.pVal ? el.pVal.value : null,
          groups: JSON.parse(JSON.stringify(state.groups || []))
        };
      }

      function drawGroups(){
        if (!el.groups) return;
        el.groups.innerHTML='';
        (state.groups || []).forEach((g,i)=>{
          const wrap=document.createElement('div');
          wrap.className='mini-fields';
          wrap.innerHTML =
            '<div class="mini-field"><label>Group '+(i+1)+' count</label><input data-i="'+i+'" data-k="count" type="number" min="0" step="1" value="'+((g.count ?? 0))+'"></div>'+
            '<div class="mini-field"><label>Unit</label><select data-i="'+i+'" data-k="mode">'+
            '<option value="percent" '+(g.mode==='percent'?'selected':'')+'>Percentage (%)</option>'+
            '<option value="oneInX" '+(g.mode==='oneInX'?'selected':'')+'>1 in X</option>'+
            '<option value="micromort" '+(g.mode==='micromort'?'selected':'')+'>Micromorts</option>'+
            '</select></div>'+
            '<div class="mini-field"><label>Value</label><input data-i="'+i+'" data-k="val" type="number" step="any" value="'+((g.val ?? ''))+'" placeholder="e.g. 100,000"></div>'+
            '<div class="mini-field"><button class="back" data-remove="'+i+'" type="button" style="width:100%">Remove</button></div>';
          el.groups.appendChild(wrap);
    (function(){
      var unitSel = wrap.querySelector('select[data-k="mode"]');
      var valInput = wrap.querySelector('input[data-k="val"]') || wrap.querySelector('input[type="number"], input[type="text"]');
      if (!unitSel || !valInput || unitSel.__phBound) return;
      unitSel.__phBound = true;
      function setPH(){
        var v = unitSel.value || 'oneInX';
        if (v === 'percent') valInput.placeholder = 'e.g. 0.5';
        else if (v === 'micromort') valInput.placeholder = 'e.g. 10';
        else valInput.placeholder = 'e.g. 100,000';
      }
      unitSel.addEventListener('change', setPH);
      setPH();
    })();
        });
        if (el.countMsg) el.countMsg.textContent='';
      }

      ['input','change'].forEach(evt=>{
        [el.N, el.tgSev, el.tgCost, el.tgProb, el.sExtraVal, el.cExtraVal, el.pMode, el.pVal]
          .forEach(x => x && x.addEventListener(evt, refreshVisibility));
      });
      if (el.addGroup) el.addGroup.addEventListener('click', ()=>{
        (state.groups = state.groups || []).push({count:0, mode:(el.pMode && el.pMode.value) || 'oneInX', val:null});
        drawGroups(); refreshVisibility();
      });
      if (el.groups) {
        el.groups.addEventListener('input', e=>{
          const t=e.target, i=+t.dataset.i; if(!Number.isFinite(i)) return;
          const k=t.dataset.k;
          if (k==='count') state.groups[i].count = t.value===''?0:(t.value|0);
          if (k==='mode')  state.groups[i].mode  = t.value;
          if (k==='val')   state.groups[i].val   = t.value===''?null:+t.value;
          const used = (state.groups||[]).reduce((s,g)=>s+(g.count|0),0);
          if (el.countMsg && el.N) el.countMsg.textContent = used > (el.N.value|0) ? 'Group counts exceed N ('+used+'/'+el.N.value+').' : '';
          refreshVisibility();
        });
        el.groups.addEventListener('click', e=>{
          const idx = e.target.dataset.remove;
          if (idx != null) { state.groups.splice(+idx,1); drawGroups(); refreshVisibility(); }
        });
      }

      drawGroups();
      refreshVisibility();
    
      
      (function(){
        if (!el) return;
        
        function updateQ6ProbLabel(){
          if (!el.pMode) return;
          var mode = (el.pMode.value || '').toLowerCase();
          if (mode === 'percentage' || mode === '%' || mode === 'percent%') mode = 'percent';
          if (mode === 'oneinx' || mode === '1 in x' || mode === '1inx') mode = 'oneInX';
          if (mode === 'micromorts') mode = 'micromort';
          var lab = el.stack && el.stack.querySelector('#q6ProbLabel');
          if (lab){
            if (mode === 'percent'){ lab.textContent = 'Enter percentage (%)'; if (el.pVal) el.pVal.placeholder = 'e.g. 1'; }
            else if (mode === 'oneInX'){ lab.textContent = 'Enter X (for ‚Äú1 in X‚Äù)'; if (el.pVal) el.pVal.placeholder = 'e.g. 1,000'; }
            else { lab.textContent = 'Enter micromorts (¬µm)'; if (el.pVal) el.pVal.placeholder = 'e.g. 1'; }
          }
          var sym = (mode==='percent') ? '%' : (mode==='micromort' ? '¬µm' : 'X');
          var probName = document.getElementById('miniProbName') || (el.stack && el.stack.querySelector('#miniProbName'));
          if (probName) probName.textContent = sym;
        }
        updateQ6ProbLabel();
        if (el.pMode && !el.pMode.__q6LabelBound){
          el.pMode.addEventListener('change', function(){ updateQ6ProbLabel(); if (typeof refreshVisibility==='function') refreshVisibility(); });
          el.pMode.addEventListener('input',  updateQ6ProbLabel);
          el.pMode.__q6LabelBound = true;
        }

        
        if (el.N && !el.N.__intBound){
          el.N.setAttribute('step','1'); el.N.setAttribute('min','1'); el.N.setAttribute('inputmode','numeric');
          el.N.addEventListener('keydown', function(e){
            var k = e.key;
            if (k === '.' || k === ',' || k.toLowerCase() === 'e') e.preventDefault();
          });
          function sanitize(){
            var s = String(el.N.value || '').trim();
            if (s === '') return; 
            s = s.replace(/[^\d]/g, '');
            if (s === '') s = '1';
            var n = parseInt(s,10);
            if (!(n >= 1)) n = 1;
            el.N.value = String(n);
          }
          el.N.addEventListener('blur', sanitize);
          el.N.addEventListener('change', sanitize);
          el.N.__intBound = true;
        }
      })();

}
})();
</script>


<script>
(function(){
  try{
    // 1) Normalize flowchart nodes: collapse Q16‚ÄìQ18 trio into one Q16 (no HTML in JSON)
    if (Array.isArray(window.flowchart)){
      const idsToRemove = new Set(['Q17','Q18','Q19']);
      for (let i = window.flowchart.length - 1; i >= 0; i--) {
        const n = window.flowchart[i];
        if (!n) continue;
        if (idsToRemove.has(n.id)) window.flowchart.splice(i, 1);
      }
      const i16 = window.flowchart.findIndex(n => n && n.id === 'Q16');
      const mini16 = { id: 'Q16', type: 'mini16', text: 'Combined tradeoff (upfront + resulting cost vs benefit)' };
      if (i16 !== -1) window.flowchart[i16] = mini16; else window.flowchart.push(mini16);
    }

    // 2) Patch renderNode to handle mini16 without HTML in JSON
    const _renderNode = window.renderNode;
    window.renderNode = function(node){
      if (node && (node.id === 'Q16' || node.type === 'mini16')){
        const textDiv = document.getElementById('text');
        if (textDiv) textDiv.innerHTML = '';
        const btns = document.getElementById('buttons');
        if (btns) btns.innerHTML = '';
        if (typeof window.renderMiniQ16 === 'function'){
          window.renderMiniQ16(textDiv, node);
        } else {
          console.error('renderMiniQ16 missing');
        }
        return;
      }
      return _renderNode.apply(this, arguments);
    };

    // 3) Define renderMiniQ16 if it does not already exist
    if (typeof window.renderMiniQ16 !== 'function'){
      window.renderMiniQ16 = function(containerEl /*, node */){
        // helpers
        const el = (tag, cls, text) => {
          const x = document.createElement(tag);
          if (cls) x.className = cls;
          if (text != null) x.textContent = text;
          return x;
        };
        const makeInput = (id) => {
          const i = document.createElement('input');
          i.type = 'number';
          i.id = id;
          i.min = '0';
          i.max = '10';
          i.step = '0.01';
          i.inputMode = 'decimal';
          i.autocomplete = 'off';
          return i;
        };

        // wrapper (match Q6 base look)
        const wrap = el('div', 'mini-wrap');
        const heading = el('div', 'mini-heading', 'Combined Tradeoff (Single Screen)');
        const lead = el('div', 'mini-lead',
          'Enter 0‚Äì10 for Upfront Cost, Resulting Cost, and Benefit. We apply the same weighting as Q6, add the two costs, and compare to the benefit. If equal, we recommend acting to be safe.'
        );
        const sep1 = el('div', 'mini-sep');

        // fields
        const fields = el('div', 'mini-fields');

        const f1 = el('div', 'mini-field');
        const l1 = el('label', null, 'Upfront Cost (0‚Äì10)');
        const in1 = makeInput('q16_cost_up'); f1.append(l1, in1);

        const f2 = el('div', 'mini-field');
        const l2 = el('label', null, 'Resulting Cost (0‚Äì10)');
        const in2 = makeInput('q16_cost_res'); f2.append(l2, in2);

        const f3 = el('div', 'mini-field');
        const l3 = el('label', null, 'Benefit (0‚Äì10)');
        const in3 = makeInput('q16_benefit'); f3.append(l3, in3);

        fields.append(f1, f2, f3);

        const sep2 = el('div', 'mini-sep');

        const verdict = el('div', 'verdict');
        verdict.id = 'q16_verdict';
        verdict.setAttribute('aria-live','polite');

        wrap.append(heading, lead, sep1, fields, sep2, verdict);
        if (containerEl) containerEl.appendChild(wrap);

        // buttons area
        const btns = document.getElementById('buttons');
        if (btns) {
          btns.innerHTML = '';
          const cont = el('button', 'next', 'Continue');
          cont.type = 'button';
          cont.disabled = true;
          btns.appendChild(cont);

          function clampNormalize(elm){
            const raw = (elm.value || '').trim();
            if (raw === '' || raw === '.' || raw === '-.' || raw === '-') return null;
            let n = Number(raw);
            if (!Number.isFinite(n)) return null;
            if (n < 0) n = 0;
            if (n > 10) n = 10;
            // normalize on blur
            elm.addEventListener('blur', () => {
              elm.value = (n % 1 === 0) ? String(n) : String(Number(n.toFixed(2)));
            }, { once: true });
            return n;
          }

          function compute(){
            const cu = clampNormalize(in1);
            const cr = clampNormalize(in2);
            const b  = clampNormalize(in3);

            if (cu == null || cr == null || b == null){
              verdict.textContent = 'Enter all three values to see the recommendation.';
              verdict.classList.remove('ok','no');
              cont.disabled = true;
              cont.onclick = null;
              return;
            }

            // reuse Q6‚Äôs weighting (must exist globally)
            if (typeof window.weight10 !== 'function'){
              console.error('weight10 missing; Q6 weighting not available');
              verdict.textContent = 'Internal error: weight10 is not defined.';
              cont.disabled = true;
              return;
            }
            const totalCost = window.weight10(cu) + window.weight10(cr);
            const benW = window.weight10(b);

            let ok, msg;
            if (benW > totalCost) {
              ok = true;
              msg = '‚úÖ Benefit outweighs total cost ‚Äî Act should be considered.';
            } else if (benW === totalCost) {
              ok = true; // equal => act to be safe
              msg = '‚úÖ Costs and benefit are equal ‚Äî Act to be safe.';
            } else {
              ok = false;
              msg = 'ü§è Total cost outweighs benefit ‚Äî Hold/adjust plan.';
            }

            verdict.textContent = msg;
            verdict.classList.toggle('ok', ok);
            verdict.classList.toggle('no', !ok);

            cont.disabled = false;
            cont.onclick = () => {
              if (typeof window.goToNode !== 'function'){
                console.error('goToNode missing');
                return;
              }
              window.goToNode(benW >= totalCost ? 'Q22' : 'Q20');
            };
          }

          // live input
          [in1, in2, in3].forEach(inp => {
            inp.addEventListener('input', () => {
              const s = inp.value;
              const cleaned = s.replace(/[^0-9.]/g,'').replace(/(.*\..*)\./, '$1');
              if (cleaned !== s) inp.value = cleaned;
              compute();
            });
            inp.addEventListener('change', compute);
            inp.addEventListener('blur', compute);
          });

          compute();
        }
      };
    }
  } catch (e){
    console.error('Q16 mini integration error', e);
  }
})();
</script>

<style>
/* Q16 tune-ups, scoped */
#q16-entry .mini-lead { margin-bottom: 6px; }
#q16-entry .mini-sep { margin: 14px 0; } /* even spacing above and below */
#q16-entry .mini-field label {
  display: block;
  margin-bottom: 6px;
  font-weight: 700;           /* match mini-heading weight */
  font-size: 1.1rem;          /* strong, but smaller than main mini-heading */
  line-height: 1.2;
}
</style>
<script>
(function(){
  // Override/upgrade renderMiniQ16 with improved UX and persistence
  window.renderMiniQ16 = function(containerEl /*, node */){
    const el = (tag, cls, text) => {
      const x = document.createElement(tag);
      if (cls) x.className = cls;
      if (text != null) x.textContent = text;
      return x;
    };
    const makeInput = (id, placeholder) => {
      const i = document.createElement('input');
      i.type = 'number';
      i.id = id;
      i.min = '0.0000001'; // logically > 0, but we'll gate in logic
      i.max = '10';
      i.step = '0.01';
      i.inputMode = 'decimal';
      i.autocomplete = 'off';
      i.placeholder = placeholder || '';
      return i;
    };

    // Wrapper
    const wrap = el('div', 'mini-wrap');
    wrap.id = 'q16-entry';
    const heading = el('div', 'mini-heading', 'Combined Tradeoff (Single Screen)');
    const lead = el('div', 'mini-lead',
      'Enter 0‚Äì10 for Upfront Cost, Resulting Cost, and Benefit. We apply the same weighting as Q6, add the two costs, and compare to the benefit. If equal, we recommend acting to be safe.'
    );
    const sep1 = el('div', 'mini-sep');

    // Fields
    const fields = el('div', 'mini-fields');

    const f1 = el('div', 'mini-field');
    const l1 = el('label', null, 'Upfront Cost (0‚Äì10)');
    const in1 = makeInput('q16_cost_up', 'e.g., 3.5'); f1.append(l1, in1);

    const f2 = el('div', 'mini-field');
    const l2 = el('label', null, 'Resulting Cost (0‚Äì10)');
    const in2 = makeInput('q16_cost_res', 'e.g., 2'); f2.append(l2, in2);

    const f3 = el('div', 'mini-field');
    const l3 = el('label', null, 'Benefit (0‚Äì10)');
    const in3 = makeInput('q16_benefit', 'e.g., 8'); f3.append(l3, in3);

    fields.append(f1, f2, f3);

    const sep2 = el('div', 'mini-sep');

    const verdict = el('div', 'verdict');
    verdict.id = 'q16_verdict';
    verdict.setAttribute('aria-live','polite');

    wrap.append(heading, lead, sep1, fields, sep2, verdict);
    if (containerEl) containerEl.innerHTML = '', containerEl.appendChild(wrap);

    // Buttons area
    const btns = document.getElementById('buttons');
    if (btns) {
      btns.innerHTML = '';
      const cont = el('button', 'next', 'Continue');
      cont.type = 'button';
      cont.disabled = true;
      btns.appendChild(cont);

      const LS = {
        up: 'q16_cost_up',
        res: 'q16_cost_res',
        ben: 'q16_benefit',
      };

      // Load persisted values
      try {
        const upv = localStorage.getItem(LS.up); if (upv !== null) in1.value = upv;
        const rsv = localStorage.getItem(LS.res); if (rsv !== null) in2.value = rsv;
        const bnv = localStorage.getItem(LS.ben); if (bnv !== null) in3.value = bnv;
      } catch(e){ /* ignore */ }

      function save(){
        try {
          localStorage.setItem(LS.up, in1.value ?? '');
          localStorage.setItem(LS.res, in2.value ?? '');
          localStorage.setItem(LS.ben, in3.value ?? '');
        } catch(e){ /* ignore */ }
      }

      // Parsing/validation helpers
      function parseField(elm){
        const raw = (elm.value || '').trim();
        if (raw === '' || raw === '.' || raw === '-.' || raw === '-') return { n: null, ok: false };
        let n = Number(raw);
        if (!Number.isFinite(n)) return { n: null, ok: false };
        // clamp high; allow decimals below 1
        if (n > 10) n = 10;
        return { n, ok: n > 0 && n <= 10 };
      }

      function normalizeOnBlur(elm){
        const { n, ok } = parseField(elm);
        if (!ok){
          // leave as-is (allows full backspace and invalid until user corrects)
          return;
        }
        // Format to 2 decimals only if non-integer
        elm.value = (n % 1 === 0) ? String(n) : String(Number(n.toFixed(2)));
      }

      function compute(){
        save();
        const a = parseField(in1);
        const b = parseField(in2);
        const c = parseField(in3);

        const ready = a.ok && b.ok && c.ok;
        if (!ready){
          verdict.textContent = 'Enter all three values (> 0 and ‚â§ 10) to see the recommendation.';
          verdict.classList.remove('ok','no');
          cont.disabled = true;
          cont.onclick = null;
          return;
        }

        if (typeof window.weight10 !== 'function'){
          verdict.textContent = 'Internal error: weighting function not available.';
          cont.disabled = true;
          return;
        }

        // Use Q6 weighting; this preserves the sub-1 curve behavior
        const totalCost = window.weight10(a.n) + window.weight10(b.n);
        const benW = window.weight10(c.n);

        let ok, msg;
        if (benW > totalCost) {
          ok = true;
          msg = '‚úÖ Benefit outweighs total cost ‚Äî Act should be considered.';
        } else if (benW === totalCost) {
          ok = true;
          msg = '‚úÖ Costs and benefit are equal ‚Äî Act to be safe.';
        } else {
          ok = false;
          msg = 'ü§è Total cost outweighs benefit ‚Äî Hold/adjust plan.';
        }

        verdict.textContent = msg;
        verdict.classList.toggle('ok', ok);
        verdict.classList.toggle('no', !ok);

        cont.disabled = false;
        cont.onclick = () => {
          if (typeof window.goToNode === 'function'){
            window.goToNode(benW >= totalCost ? 'Q22' : 'Q20');
          }
        };
      }

      // Events: allow full backspace, live filtering, and blur normalization
      [in1, in2, in3].forEach(inp => {
        inp.addEventListener('input', () => {
          const s = inp.value;
          const cleaned = s.replace(/[^0-9.]/g,'').replace(/(.*\..*)\./, '$1');
          if (cleaned !== s) inp.value = cleaned;
          compute();
        });
        inp.addEventListener('change', compute);
        inp.addEventListener('blur', () => { normalizeOnBlur(inp); compute(); });
      });

      compute();
    }
  };
})();
</script>

<script>
(function(){
  // Re-wrap renderMiniQ16 to enforce the zero-handling rules silently
  const old = window.renderMiniQ16;
  window.renderMiniQ16 = function(containerEl /*, node */){
    // call the previous to build UI, then adjust behavior
    old && old(containerEl);
    const wrap = document.getElementById('q16-entry');
    if (!wrap) return;

    const in1 = wrap.querySelector('#q16_cost_up');
    const in2 = wrap.querySelector('#q16_cost_res');
    const in3 = wrap.querySelector('#q16_benefit');
    const verdict = document.getElementById('q16_verdict');
    const btns = document.getElementById('buttons');
    const cont = btns ? btns.querySelector('button.next') : null;

    if (!in1 || !in2 || !in3) return;

    let lastEdited = null;
    [in1, in2, in3].forEach(inp => {
      inp.addEventListener('input', () => { lastEdited = inp; }, { capture: true });
      inp.addEventListener('change', () => { lastEdited = inp; }, { capture: true });
      inp.addEventListener('blur', () => { lastEdited = inp; }, { capture: true });
    });

    // Replace compute with stricter zero-handling
    function parseNum(v){
      if (v == null) return null;
      const s = String(v).trim();
      if (s === '' || s === '.' || s === '-.' || s === '-') return null;
      let n = Number(s);
      if (!Number.isFinite(n)) return null;
      if (n < 0) n = 0;
      if (n > 10) n = 10;
      return n;
    }

    function normalize(el){
      const n = parseNum(el.value);
      if (n == null) return;
      el.value = (n % 1 === 0) ? String(n) : String(Number(n.toFixed(2)));
    }

    function save(){
      try {
        localStorage.setItem('q16_cost_up', in1.value ?? '');
        localStorage.setItem('q16_cost_res', in2.value ?? '');
        localStorage.setItem('q16_benefit', in3.value ?? '');
      } catch(e){}
    }

    function compute(){
      // benefit cannot be 0 ‚Üí auto 1e-9
      let b = parseNum(in3.value);
      if (b === 0){
        in3.value = '0.000000001';
        b = 0.000000001;
      }

      // costs: either can be 0 but not both
      let a = parseNum(in1.value);
      let c = parseNum(in2.value);

      if (a === null || c === null || b === null){
        verdict && (verdict.textContent = 'Enter all three values to see the recommendation.');
        verdict && verdict.classList.remove('ok','no');
        cont && (cont.disabled = true);
        return;
      }

      if (a === 0 && c === 0){
        // bump the last edited one to 1e-9; if unknown, bump the second
        const target = lastEdited && (lastEdited === in1 || lastEdited === in2) ? lastEdited : in2;
        target.value = '0.000000001';
        if (target === in1) a = 0.000000001; else c = 0.000000001;
      }

      // ok to proceed; normalize on blur handled by earlier layer
      save();

      if (typeof window.weight10 !== 'function'){
        verdict && (verdict.textContent = 'Internal error: weighting function not available.');
        cont && (cont.disabled = true);
        return;
      }
      const totalCost = window.weight10(a) + window.weight10(c);
      const benW = window.weight10(b);

      let ok, msg;
      if (benW > totalCost) {
        ok = true; msg = '‚úÖ Benefit outweighs total cost ‚Äî Act should be considered.';
      } else if (benW === totalCost) {
        ok = true; msg = '‚úÖ Costs and benefit are equal ‚Äî Act to be safe.';
      } else {
        ok = false; msg = 'ü§è Total cost outweighs benefit ‚Äî Hold/adjust plan.';
      }

      verdict && (verdict.textContent = msg);
      verdict && verdict.classList.toggle('ok', ok);
      verdict && verdict.classList.toggle('no', !ok);

      cont && (cont.disabled = false);
      cont && (cont.onclick = () => {
        if (typeof window.goToNode === 'function'){
          window.goToNode(benW >= totalCost ? 'Q22' : 'Q20');
        }
      });
    }

    // Wire up with existing handlers‚Äîrun after their compute
    [in1, in2, in3].forEach(inp => {
      inp.addEventListener('input', compute);
      inp.addEventListener('change', compute);
      inp.addEventListener('blur', compute);
    });

    // initial run (in case values already present)
    compute();
  };
})();
</script>

<script>
(function(){
  // Fully replace renderMiniQ16 to remove persistence and delay zero-correction until blur/change
  const buildQ16 = function(containerEl){
    const el = (tag, cls, text) => {
      const x = document.createElement(tag);
      if (cls) x.className = cls;
      if (text != null) x.textContent = text;
      return x;
    };
    const makeInput = (id, placeholder) => {
      const i = document.createElement('input');
      i.type = 'number';
      i.id = id;
      i.min = '0';
      i.max = '10';
      i.step = '0.01';
      i.inputMode = 'decimal';
      i.autocomplete = 'off';
      i.placeholder = placeholder || '';
      return i;
    };

    const wrap = el('div', 'mini-wrap'); wrap.id = 'q16-entry';
    const heading = el('div', 'mini-heading', 'Combined Tradeoff (Single Screen)');
    const lead = el('div', 'mini-lead',
      'Enter 0‚Äì10 for Upfront Cost, Resulting Cost, and Benefit. We apply the same weighting as Q6, add the two costs, and compare to the benefit. If equal, we recommend acting to be safe.'
    );
    const sep1 = el('div', 'mini-sep');

    const fields = el('div', 'mini-fields');
    const f1 = el('div', 'mini-field'); const l1 = el('label', null, 'Upfront Cost (0‚Äì10)'); const in1 = makeInput('q16_cost_up','e.g., 3.5'); f1.append(l1,in1);
    const f2 = el('div', 'mini-field'); const l2 = el('label', null, 'Resulting Cost (0‚Äì10)'); const in2 = makeInput('q16_cost_res','e.g., 2'); f2.append(l2,in2);
    const f3 = el('div', 'mini-field'); const l3 = el('label', null, 'Benefit (0‚Äì10)'); const in3 = makeInput('q16_benefit','e.g., 8'); f3.append(l3,in3);
    fields.append(f1,f2,f3);

    const sep2 = el('div', 'mini-sep');

    const verdict = el('div', 'verdict'); verdict.id = 'q16_verdict'; verdict.setAttribute('aria-live','polite');

    wrap.append(heading, lead, sep1, fields, sep2, verdict);
    if (containerEl) { containerEl.innerHTML=''; containerEl.appendChild(wrap); }

    const btns = document.getElementById('buttons');
    if (btns){
      btns.innerHTML='';
      const cont = el('button','next','Continue'); cont.type='button'; cont.disabled = true; btns.appendChild(cont);

      let lastEdited = null;
      [in1,in2,in3].forEach(inp => {
        inp.addEventListener('input', () => { // live filter only; no zero-correction here
          lastEdited = inp;
          const s = inp.value;
          const cleaned = s.replace(/[^0-9.]/g,'').replace(/(.*\..*)\./,'$1');
          if (cleaned !== s) inp.value = cleaned;
          compute(false);
        });
        inp.addEventListener('blur', () => { lastEdited = inp; finalizeField(inp); compute(true); });
        inp.addEventListener('change', () => { lastEdited = inp; finalizeField(inp); compute(true); });
      });

      function parseNum(v){
        if (v == null) return null;
        const s = String(v).trim();
        if (s === '' || s === '.' || s === '-.' || s === '-') return null;
        let n = Number(s);
        if (!Number.isFinite(n)) return null;
        if (n > 10) n = 10;
        if (n < 0) n = 0;
        return n;
      }

      function normalize(el){
        const n = parseNum(el.value);
        if (n == null) return;
        el.value = (n % 1 === 0) ? String(n) : String(Number(n.toFixed(2)));
      }

      function finalizeField(el){
        // Apply the 0 -> 1e-9 rules only when the user finishes editing (blur/change)
        const id = el.id;
        let n = parseNum(el.value);
        if (n == null) return;
        if (id === 'q16_benefit'){
          if (n === 0){ el.value = '0.000000001'; }
        } else {
          // costs: either can be 0, but not both simultaneously
          const other = (id === 'q16_cost_up') ? in2 : in1;
          let nOther = parseNum(other.value);
          if (n === 0 && nOther === 0){
            // bump the one the user just finished editing
            el.value = '0.000000001';
          }
        }
        normalize(el);
      }

      function compute(finalize){
        const a = parseNum(in1.value);
        const c = parseNum(in2.value);
        const b = parseNum(in3.value);

        // when not finalized, allow zeros to show without auto-adjustment; just gate the verdict
        if (a == null || c == null || b == null){
          verdict.textContent = 'Enter all three values to see the recommendation.';
          verdict.classList.remove('ok','no');
          cont.disabled = true;
          cont.onclick = null;
          return;
        }

        // If finalize==false and disallowed zeros exist, show neutral state without forcing change
        if (!finalize){
          const costsBothZero = (a === 0 && c === 0);
          const benZero = (b === 0);
          if (costsBothZero || benZero){
            verdict.textContent = 'Enter all three values to see the recommendation.';
            verdict.classList.remove('ok','no');
            cont.disabled = true;
            cont.onclick = null;
            return;
          }
        }

        if (typeof window.weight10 !== 'function'){
          verdict.textContent = 'Internal error: weighting function not available.';
          cont.disabled = true; return;
        }

        const totalCost = window.weight10(a) + window.weight10(c);
        const benW = window.weight10(b);

        let ok, msg;
        if (benW > totalCost) { ok = true; msg = '‚úÖ Benefit outweighs total cost ‚Äî Act should be considered.'; }
        else if (benW === totalCost) { ok = true; msg = '‚úÖ Costs and benefit are equal ‚Äî Act to be safe.'; }
        else { ok = false; msg = 'ü§è Total cost outweighs benefit ‚Äî Hold/adjust plan.'; }

        verdict.textContent = msg;
        verdict.classList.toggle('ok', ok);
        verdict.classList.toggle('no', !ok);

        cont.disabled = false;
        cont.onclick = () => {
          if (typeof window.goToNode === 'function'){
            window.goToNode(benW >= totalCost ? 'Q22' : 'Q20');
          }
        };
      }

      // Expose a restart hook to clear fields (if a restart button exists)
      function clearQ16Fields(){
        [in1,in2,in3].forEach(inp => { inp.value = ''; });
        compute(false);
      }
      // Try to attach to a button with id or class indicating restart
      document.addEventListener('click', function(e){
        const t = e.target;
        if (!t) return;
        const id = t.id || '';
        const cls = t.className || '';
        if (/restart/i.test(id) || /restart/i.test(cls) || t.dataset && /restart/i.test(t.dataset.action || '')){
          clearQ16Fields();
        }
      }, true);

      // initial neutral state
      compute(false);
    }
  };

  // Install the replacement into the app
  window.renderMiniQ16 = function(containerEl){ buildQ16(containerEl); };

  // Also clear any previous localStorage keys on load to ensure refresh reset
  try {
    localStorage.removeItem('q16_cost_up');
    localStorage.removeItem('q16_cost_res');
    localStorage.removeItem('q16_benefit');
  } catch(e){}
})();
</script>

<script>
(function(){
  // Replace renderMiniQ16 to ensure 0 -> 1e-9 persists (no rounding to 0.00)
  window.renderMiniQ16 = function(containerEl){
    const el = (tag, cls, text) => {
      const x = document.createElement(tag);
      if (cls) x.className = cls;
      if (text != null) x.textContent = text;
      return x;
    };
    const makeInput = (id, placeholder) => {
      const i = document.createElement('input');
      i.type = 'number';
      i.id = id;
      i.min = '0';
      i.max = '10';
      i.step = '0.01';
      i.inputMode = 'decimal';
      i.autocomplete = 'off';
      i.placeholder = placeholder || '';
      return i;
    };

    const wrap = el('div','mini-wrap'); wrap.id='q16-entry';
    const heading = el('div','mini-heading','Combined Tradeoff (Single Screen)');
    const lead = el('div','mini-lead','Enter 0‚Äì10 for Upfront Cost, Resulting Cost, and Benefit. We apply the same weighting as Q6, add the two costs, and compare to the benefit. If equal, we recommend acting to be safe.');
    const sep1 = el('div','mini-sep');
    const fields = el('div','mini-fields');
    const f1 = el('div','mini-field'); const l1 = el('label', null, 'Upfront Cost (0‚Äì10)'); const in1 = makeInput('q16_cost_up','e.g., 3.5'); f1.append(l1,in1);
    const f2 = el('div','mini-field'); const l2 = el('label', null, 'Resulting Cost (0‚Äì10)'); const in2 = makeInput('q16_cost_res','e.g., 2'); f2.append(l2,in2);
    const f3 = el('div','mini-field'); const l3 = el('label', null, 'Benefit (0‚Äì10)'); const in3 = makeInput('q16_benefit','e.g., 8'); f3.append(l3,in3);
    fields.append(f1,f2,f3);
    const sep2 = el('div','mini-sep');
    const verdict = el('div','verdict'); verdict.id='q16_verdict'; verdict.setAttribute('aria-live','polite');
    wrap.append(heading,lead,sep1,fields,sep2,verdict);
    if (containerEl){ containerEl.innerHTML=''; containerEl.appendChild(wrap); }

    const btns = document.getElementById('buttons');
    if (!btns) return;
    btns.innerHTML='';
    const cont = el('button','next','Continue'); cont.type='button'; cont.disabled=true; btns.appendChild(cont);

    let lastEdited = null;
    [in1,in2,in3].forEach(inp => {
      inp.addEventListener('input', () => {
        lastEdited = inp;
        const s = inp.value;
        const cleaned = s.replace(/[^0-9.]/g,'').replace(/(.*\..*)\./,'$1');
        if (cleaned !== s) inp.value = cleaned;
        compute(false);
      });
      inp.addEventListener('blur', () => { lastEdited = inp; finalizeField(inp); compute(true); });
      inp.addEventListener('change', () => { lastEdited = inp; finalizeField(inp); compute(true); });
    });

    function parseNum(v){
      if (v == null) return null;
      const s = String(v).trim();
      if (s === '' || s === '.' || s === '-.' || s === '-') return null;
      let n = Number(s);
      if (!Number.isFinite(n)) return null;
      if (n > 10) n = 10;
      if (n < 0) n = 0;
      return n;
    }

    function setToMin(el){
      // Always write a fixed string to avoid 0.00 formatting
      el.value = '0.000000001';
      el.dataset.minCorrected = '1';
    }

    function normalize(el){
      // If we just applied the minimum, keep exact string
      if (el.dataset.minCorrected === '1') {
        // leave as '0.000000001' and clear the flag
        delete el.dataset.minCorrected;
        return;
      }
      const n = parseNum(el.value);
      if (n == null) return;
      if (n > 0 && n < 0.01) {
        // preserve small numbers; do not round to 0.00
        el.value = String(n);
        return;
      }
      el.value = (n % 1 === 0) ? String(n) : String(Number(n.toFixed(2)));
    }

    function finalizeField(el){
      const id = el.id;
      let n = parseNum(el.value);
      if (n == null) return;
      if (id === 'q16_benefit'){
        if (n === 0){ setToMin(el); return; } // skip normalize to preserve
      } else {
        // costs: either can be 0, but not both
        const other = (id === 'q16_cost_up') ? in2 : in1;
        let nOther = parseNum(other.value);
        if (n === 0 && nOther === 0){
          setToMin(el); return; // skip normalize
        }
      }
      normalize(el);
    }

    function compute(finalize){
      const a = parseNum(in1.value);
      const c = parseNum(in2.value);
      const b = parseNum(in3.value);

      if (a == null || c == null || b == null){
        verdict.textContent = 'Enter all three values to see the recommendation.';
        verdict.classList.remove('ok','no');
        cont.disabled = true; cont.onclick = null;
        return;
      }

      if (!finalize){
        const costsBothZero = (a === 0 && c === 0);
        const benZero = (b === 0);
        if (costsBothZero || benZero){
          verdict.textContent = 'Enter all three values to see the recommendation.';
          verdict.classList.remove('ok','no');
          cont.disabled = true; cont.onclick = null;
          return;
        }
      }

      if (typeof window.weight10 !== 'function'){
        verdict.textContent = 'Internal error: weighting function not available.';
        cont.disabled = true; return;
      }
      const totalCost = window.weight10(a) + window.weight10(c);
      const benW = window.weight10(b);

      let ok, msg;
      if (benW > totalCost) { ok = true; msg = '‚úÖ Benefit outweighs total cost ‚Äî Act should be considered.'; }
      else if (benW === totalCost) { ok = true; msg = '‚úÖ Costs and benefit are equal ‚Äî Act to be safe.'; }
      else { ok = false; msg = 'ü§è Total cost outweighs benefit ‚Äî Hold/adjust plan.'; }

      verdict.textContent = msg;
      verdict.classList.toggle('ok', ok);
      verdict.classList.toggle('no', !ok);

      cont.disabled = false;
      cont.onclick = () => {
        if (typeof window.goToNode === 'function'){
          window.goToNode(benW >= totalCost ? 'Q22' : 'Q20');
        }
      };
    }

    // initial neutral state
    compute(false);
  };
})();
</script>
</body>
</html>